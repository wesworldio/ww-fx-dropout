<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WesWorld FX</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: #000;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
        }
        
        #videoContainer {
            width: 100vw;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }
        
        #videoInput {
            display: none;
        }
        
        #canvasOutput {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
            display: block;
            background: #000;
            width: 100%;
            height: 100%;
        }
        
        #controls {
            position: fixed;
            top: 10px;
            left: 10px;
            z-index: 1000;
            background: var(--surface-color, rgba(26, 26, 26, 0.95));
            color: var(--text-color, white);
            padding: 12px;
            border-radius: 8px;
            border: 1px solid var(--border-color, #333);
            font-size: 14px;
            min-width: 180px;
            max-width: 220px;
            transition: opacity 0.3s, transform 0.3s;
        }
        
        #controls.visible {
            opacity: 1;
            transform: translateX(0);
        }
        
        #controls.hidden {
            opacity: 0;
            transform: translateX(-100%);
            pointer-events: none;
        }
        
        #status {
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 1000;
            padding: 10px 15px;
            background: var(--surface-color, rgba(26, 26, 26, 0.95));
            color: var(--text-color, white);
            border-radius: 8px;
            font-size: 12px;
            border: 1px solid var(--border-color, #333);
            transition: opacity 0.3s;
        }
        
        #status.hidden {
            opacity: 0;
            pointer-events: none;
        }
        
        #status.connected {
            border-color: var(--status-connected-color, #4caf50);
        }
        
        #status.error {
            border-color: var(--status-error-color, #f44336);
        }
        
        .theme-selector {
            margin-bottom: 10px;
        }
        
        .theme-selector label {
            display: block;
            margin-bottom: 5px;
            font-size: 12px;
            color: var(--text-secondary-color, #cccccc);
        }
        
        .theme-selector select {
            width: 100%;
            padding: 6px;
            background: var(--surface-color, #1a1a1a);
            color: var(--text-color, white);
            border: 1px solid var(--border-color, #333);
            border-radius: 4px;
            font-size: 12px;
        }
        
        label {
            display: block;
            margin-bottom: 10px;
            font-size: 12px;
            color: var(--text-secondary-color, #cccccc);
        }
        
        select, input {
            width: 100%;
            padding: 8px;
            background: var(--surface-color, #1a1a1a);
            color: var(--text-color, white);
            border: 1px solid var(--border-color, #333);
            border-radius: 4px;
            font-size: 12px;
            margin-top: 4px;
        }
        
        select:focus, input:focus {
            outline: none;
            border-color: var(--accent-color, #5250ef);
        }
        
        button {
            width: 100%;
            padding: 10px;
            background: transparent;
            border: 2px solid var(--button-color, #4a9eff);
            color: var(--button-color, #4a9eff);
            cursor: pointer;
            transition: all 0.2s;
            border-radius: 4px;
            font-size: 14px;
            margin-bottom: 10px;
        }
        
        button:hover {
            background: var(--button-color, #4a9eff);
            color: var(--selected-text-color, #ffffff);
        }
        
        button#startButton,
        button#stopButton {
            background: var(--button-color, #4a9eff);
            color: var(--selected-text-color, #ffffff);
        }
        
        button#startButton:hover,
        button#stopButton:hover {
            background: var(--button-hover-color, #5aaeff);
        }
        
        .fx-dropdown {
            position: relative;
            width: 100%;
        }
        
        .fx-dropdown-button {
            width: 100%;
            padding: 12px;
            background: var(--surface-color, #1a1a1a);
            color: var(--text-color, white);
            border: 1px solid var(--border-color, #333);
            border-radius: 4px;
            font-size: 14px;
            cursor: pointer;
            text-align: left;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .fx-dropdown-button:hover {
            border-color: var(--accent-color, #5250ef);
        }
        
        .fx-dropdown-menu {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: var(--surface-color, #1a1a1a);
            border: 1px solid var(--border-color, #333);
            border-radius: 4px;
            margin-top: 4px;
            max-height: calc(100vh - 200px);
            overflow-y: auto;
            overflow-x: hidden;
            z-index: 1000;
            display: none;
        }
        
        .fx-dropdown-menu.open {
            display: block;
        }
        
        .fx-group {
            margin-bottom: 10px;
        }
        
        .fx-group-title {
            padding: 8px 12px;
            font-size: 11px;
            font-weight: bold;
            color: var(--group-title-color, #5250ef);
            text-transform: uppercase;
            background: var(--surface-hover-color, #2a2a2a);
            border-bottom: 1px solid var(--border-color, #333);
        }
        
        .fx-option {
            padding: 12px 16px;
            color: var(--text-color, white);
            cursor: pointer;
            border: none;
            background: transparent;
            width: 100%;
            text-align: left;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: background 0.2s;
        }
        
        .fx-option:hover {
            background: var(--surface-hover-color, #2a2a2a);
        }
        
        .fx-option.selected {
            background: var(--accent-color, #5250ef);
            color: var(--selected-text-color, #ffffff);
        }
        
        .fx-option-image {
            width: 40px;
            height: 40px;
            object-fit: cover;
            border-radius: 4px;
            border: 1px solid var(--border-color, #333);
        }
        
        .fx-option-text {
            flex: 1;
        }
        
        .fx-option-pin {
            cursor: pointer;
            font-size: 16px;
            padding: 4px;
            opacity: 0.7;
            transition: opacity 0.2s;
        }
        
        .fx-option-pin:hover {
            opacity: 1;
        }
        
        .fx-current-pin {
            cursor: pointer;
            font-size: 16px;
            padding: 4px;
            opacity: 0.7;
            transition: opacity 0.2s;
        }
        
        .fx-current-pin:hover {
            opacity: 1;
        }
        
        .fx-search-container {
            margin-bottom: 10px;
        }
        
        .fx-search-input {
            width: 100%;
            padding: 8px;
            background: var(--surface-color, #1a1a1a);
            color: var(--text-color, white);
            border: 1px solid var(--border-color, #333);
            border-radius: 4px;
            font-size: 12px;
        }
        
        .pinned-fx-container {
            margin-bottom: 10px;
            min-height: 20px;
        }
        
        .pinned-fx-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 10px;
            margin-bottom: 4px;
            background: var(--surface-hover-color, #2a2a2a);
            border: 1px solid var(--border-color, #333);
            border-radius: 4px;
            font-size: 12px;
            cursor: move;
            user-select: none;
            transition: all 0.2s;
            width: 100%;
        }
        
        .pinned-fx-item:hover {
            background: var(--accent-color, #5250ef);
            border-color: var(--accent-color, #5250ef);
        }
        
        .pinned-fx-item.pinned {
            border-color: var(--accent-color, #5250ef);
            background: var(--accent-color, #5250ef);
            color: var(--selected-text-color, #ffffff);
        }
        
        .pinned-fx-item.dragging {
            opacity: 0.5;
        }
        
        .pinned-fx-item.drag-over {
            border-color: var(--accent-color, #5250ef);
        }
        
        .pinned-fx-item-text {
            flex: 1;
            cursor: pointer;
        }
        
        .pinned-fx-item-remove {
            cursor: pointer;
            font-size: 18px;
            font-weight: bold;
            opacity: 0.7;
            padding: 0 4px;
        }
        
        .pinned-fx-item-remove:hover {
            opacity: 1;
        }
        
        @media (max-width: 768px) {
            #controls {
                max-width: 100%;
                width: calc(100vw - 20px);
            }
            
            .fx-dropdown-menu {
                max-height: calc(100vh - 150px);
            }
        }
    </style>
</head>
<body>
    <div id="controls" class="hidden">
        <div class="theme-selector">
            <label for="themeSelect">Theme:</label>
            <select id="themeSelect"></select>
        </div>
        <label>
            Camera:
            <select id="cameraSelect"></select>
        </label>
        <label>
            Search FX:
            <input type="text" id="fxSearchInput" class="fx-search-input" placeholder="Search FX..." autocomplete="off">
        </label>
        <label>
            Pinned:
            <div id="pinnedFxContainer"></div>
        </label>
        <label>
            Current FX:
            <div class="fx-dropdown">
                <button class="fx-dropdown-button" id="fxDropdownButton" type="button">
                    <span id="fxSelectedText">None (Original)</span>
                    <span id="fxCurrentPin" class="fx-current-pin" style="display: none;" title="Pin current FX"></span>
                </button>
                <div class="fx-dropdown-menu" id="fxDropdownMenu">
                    <div id="fxOptionsContainer"></div>
            </div>
            </div>
            <select id="filterSelect" style="display: none;"></select>
        </label>
        <button id="startButton">Start Camera</button>
        <button id="stopButton" style="display: none;">Stop Camera</button>
    </div>
    
    <div id="status" class="hidden">Initializing...</div>
    
    <div id="videoContainer">
        <video id="videoInput" autoplay playsinline></video>
        <canvas id="canvasOutput"></canvas>
    </div>
    
    <!-- Face-api.js for face detection (browser-optimized) -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@1.7.4/dist/tf.min.js"></script>
    <script src="https://unpkg.com/face-api.js@0.22.2/dist/face-api.min.js"></script>
    
    <!-- Shared filter implementations - inlined to avoid path issues -->
    <script>
        // Filter implementations (inlined from static/filters.js)
        const FilterImplementations = {
            applyBlackWhite(data) {
                for (let i = 0; i < data.length; i += 4) {
                    const gray = data[i] * 0.299 + data[i + 1] * 0.587 + data[i + 2] * 0.114;
                    data[i] = gray; data[i + 1] = gray; data[i + 2] = gray;
                }
            },
            applySepia(data) {
                for (let i = 0; i < data.length; i += 4) {
                    const r = data[i], g = data[i + 1], b = data[i + 2];
                    data[i] = Math.min(255, (r * 0.393) + (g * 0.769) + (b * 0.189));
                    data[i + 1] = Math.min(255, (r * 0.349) + (g * 0.686) + (b * 0.168));
                    data[i + 2] = Math.min(255, (r * 0.272) + (g * 0.534) + (b * 0.131));
                }
            },
            applyNegative(data) {
                for (let i = 0; i < data.length; i += 4) {
                    data[i] = 255 - data[i]; data[i + 1] = 255 - data[i + 1]; data[i + 2] = 255 - data[i + 2];
                }
            },
            applyVintage(data) {
                for (let i = 0; i < data.length; i += 4) {
                    data[i] = Math.min(255, data[i] * 0.9 + 20);
                    data[i + 1] = Math.min(255, data[i + 1] * 0.85 + 15);
                    data[i + 2] = Math.min(255, data[i + 2] * 0.8 + 10);
                }
            },
            applyNeonGlow(data) {
                for (let i = 0; i < data.length; i += 4) {
                    const brightness = (data[i] + data[i + 1] + data[i + 2]) / 3;
                    data[i] = Math.min(255, brightness * 1.5);
                    data[i + 1] = Math.min(255, brightness * 1.2);
                    data[i + 2] = Math.min(255, brightness * 2);
                }
            },
            applyRedTint(data) {
                for (let i = 0; i < data.length; i += 4) data[i] = Math.min(255, data[i] * 1.5);
            },
            applyBlueTint(data) {
                for (let i = 0; i < data.length; i += 4) data[i + 2] = Math.min(255, data[i + 2] * 1.5);
            },
            applyGreenTint(data) {
                for (let i = 0; i < data.length; i += 4) data[i + 1] = Math.min(255, data[i + 1] * 1.5);
            },
            applyPosterize(data) {
                const levels = 4;
                for (let i = 0; i < data.length; i += 4) {
                    data[i] = Math.floor(data[i] / (256 / levels)) * (256 / levels);
                    data[i + 1] = Math.floor(data[i + 1] / (256 / levels)) * (256 / levels);
                    data[i + 2] = Math.floor(data[i + 2] / (256 / levels)) * (256 / levels);
                }
            },
            applyThermal(data) {
                for (let i = 0; i < data.length; i += 4) {
                    const gray = (data[i] + data[i + 1] + data[i + 2]) / 3;
                    if (gray < 85) {
                        data[i] = 0; data[i + 1] = 0; data[i + 2] = gray * 3;
                    } else if (gray < 170) {
                        data[i] = (gray - 85) * 3; data[i + 1] = 255; data[i + 2] = 255;
                    } else {
                        data[i] = 255; data[i + 1] = 255 - (gray - 170) * 3; data[i + 2] = 0;
                    }
                }
            },
            applyPixelate(data, width, height) {
                const pixelSize = 10;
                for (let y = 0; y < height; y += pixelSize) {
                    for (let x = 0; x < width; x += pixelSize) {
                        let r = 0, g = 0, b = 0, count = 0;
                        for (let dy = 0; dy < pixelSize && y + dy < height; dy++) {
                            for (let dx = 0; dx < pixelSize && x + dx < width; dx++) {
                                const idx = ((y + dy) * width + (x + dx)) * 4;
                                r += data[idx]; g += data[idx + 1]; b += data[idx + 2]; count++;
                            }
                        }
                        r = Math.floor(r / count); g = Math.floor(g / count); b = Math.floor(b / count);
                        for (let dy = 0; dy < pixelSize && y + dy < height; dy++) {
                            for (let dx = 0; dx < pixelSize && x + dx < width; dx++) {
                                const idx = ((y + dy) * width + (x + dx)) * 4;
                                data[idx] = r; data[idx + 1] = g; data[idx + 2] = b;
                            }
                        }
                    }
                }
            },
            applyBlur(data, width, height) {
                const radius = 5;
                const temp = new Uint8ClampedArray(data);
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        let r = 0, g = 0, b = 0, count = 0;
                        for (let dy = -radius; dy <= radius; dy++) {
                            for (let dx = -radius; dx <= radius; dx++) {
                                const nx = x + dx, ny = y + dy;
                                if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                                    const idx = (ny * width + nx) * 4;
                                    r += temp[idx]; g += temp[idx + 1]; b += temp[idx + 2]; count++;
                                }
                            }
                        }
                        const idx = (y * width + x) * 4;
                        data[idx] = r / count; data[idx + 1] = g / count; data[idx + 2] = b / count;
                    }
                }
            },
            applySharpen(data, width, height) {
                const kernel = [[0, -1, 0], [-1, 5, -1], [0, -1, 0]];
                const temp = new Uint8ClampedArray(data);
                for (let y = 1; y < height - 1; y++) {
                    for (let x = 1; x < width - 1; x++) {
                        let r = 0, g = 0, b = 0;
                        for (let ky = -1; ky <= 1; ky++) {
                            for (let kx = -1; kx <= 1; kx++) {
                                const idx = ((y + ky) * width + (x + kx)) * 4;
                                const weight = kernel[ky + 1][kx + 1];
                                r += temp[idx] * weight; g += temp[idx + 1] * weight; b += temp[idx + 2] * weight;
                            }
                        }
                        const idx = (y * width + x) * 4;
                        data[idx] = Math.max(0, Math.min(255, r));
                        data[idx + 1] = Math.max(0, Math.min(255, g));
                        data[idx + 2] = Math.max(0, Math.min(255, b));
                    }
                }
            },
            applyEmboss(data, width, height) {
                const kernel = [[-2, -1, 0], [-1, 1, 1], [0, 1, 2]];
                const temp = new Uint8ClampedArray(data);
                for (let y = 1; y < height - 1; y++) {
                    for (let x = 1; x < width - 1; x++) {
                        let r = 0, g = 0, b = 0;
                        for (let ky = -1; ky <= 1; ky++) {
                            for (let kx = -1; kx <= 1; kx++) {
                                const idx = ((y + ky) * width + (x + kx)) * 4;
                                const weight = kernel[ky + 1][kx + 1];
                                r += temp[idx] * weight; g += temp[idx + 1] * weight; b += temp[idx + 2] * weight;
                            }
                        }
                        const idx = (y * width + x) * 4;
                        const gray = (r + g + b) / 3;
                        data[idx] = Math.max(0, Math.min(255, gray + 128));
                        data[idx + 1] = Math.max(0, Math.min(255, gray + 128));
                        data[idx + 2] = Math.max(0, Math.min(255, gray + 128));
                    }
                }
            },
            applySketch(data, width, height) {
                this.applyBlur(data, width, height);
                for (let i = 0; i < data.length; i += 4) {
                    const gray = (data[i] + data[i + 1] + data[i + 2]) / 3;
                    const inverted = 255 - gray;
                    data[i] = data[i + 1] = data[i + 2] = Math.min(255, inverted);
                }
            },
            applyCartoon(data, width, height) {
                this.applyBlur(data, width, height);
                this.applyPosterize(data);
            },
            applyRainbow(data, width, height) {
                for (let y = 0; y < height; y++) {
                    const hue = (y / height) * 360;
                    for (let x = 0; x < width; x++) {
                        const idx = (y * width + x) * 4;
                        const gray = (data[idx] + data[idx + 1] + data[idx + 2]) / 3;
                        const rgb = this.hslToRgb(hue / 360, 1, gray / 255);
                        data[idx] = rgb[0]; data[idx + 1] = rgb[1]; data[idx + 2] = rgb[2];
                    }
                }
            },
            applyBulge(data, width, height) {
                const centerX = width / 2, centerY = height / 2;
                const radius = Math.min(width, height) / 2, strength = 0.5;
                const temp = new Uint8ClampedArray(data);
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const dx = x - centerX, dy = y - centerY;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist < radius) {
                            const angle = Math.atan2(dy, dx);
                            const r = dist / radius;
                            const newR = r * (1 - strength * (1 - r));
                            const newX = Math.round(centerX + Math.cos(angle) * newR * radius);
                            const newY = Math.round(centerY + Math.sin(angle) * newR * radius);
                            if (newX >= 0 && newX < width && newY >= 0 && newY < height) {
                                const srcIdx = (y * width + x) * 4;
                                const dstIdx = (newY * width + newX) * 4;
                                data[srcIdx] = temp[dstIdx];
                                data[srcIdx + 1] = temp[dstIdx + 1];
                                data[srcIdx + 2] = temp[dstIdx + 2];
                                data[srcIdx + 3] = temp[dstIdx + 3];
                            }
                        }
                    }
                }
            },
            hslToRgb(h, s, l) {
                let r, g, b;
                if (s === 0) {
                    r = g = b = l;
                } else {
                    const hue2rgb = (p, q, t) => {
                        if (t < 0) t += 1; if (t > 1) t -= 1;
                        if (t < 1/6) return p + (q - p) * 6 * t;
                        if (t < 1/2) return q;
                        if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                        return p;
                    };
                    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                    const p = 2 * l - q;
                    r = hue2rgb(p, q, h + 1/3);
                    g = hue2rgb(p, q, h);
                    b = hue2rgb(p, q, h - 1/3);
                }
                return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
            }
        };
    </script>
    
    <script>
        // State
        let localStream = null;
        let currentFilter = '';
        let animationFrameId = null;
        let faceDetection = null;
        let faceApiModelsLoaded = false;
        let camera = null;
        let allFilters = [];
        let pinnedFilters = [];
        let currentFilterIndex = -1;
        let isRandomCycling = false;
        let randomCycleInterval = null;
        let controlsVisible = false;
        let uiHideTimeout = null;
        let frameCount = 0;
        let faceMaskImages = {}; // Cache for face mask images
        
        // Initialize playlist storage
        window.fxPlaylist = null;
        window.fxPlaylistIndex = 0;
        
        // Elements
        const videoInput = document.getElementById('videoInput');
        const canvasOutput = document.getElementById('canvasOutput');
        const ctx = canvasOutput.getContext('2d');
        const cameraSelect = document.getElementById('cameraSelect');
        const filterSelect = document.getElementById('filterSelect');
        const fxDropdownButton = document.getElementById('fxDropdownButton');
        const fxDropdownMenu = document.getElementById('fxDropdownMenu');
        const fxSelectedText = document.getElementById('fxSelectedText');
        const startButton = document.getElementById('startButton');
        const stopButton = document.getElementById('stopButton');
        const statusDiv = document.getElementById('status');
        const controls = document.getElementById('controls');
        const themeSelect = document.getElementById('themeSelect');
        let currentTheme = 'wesworld';
        
        // Filter definitions
        const FILTER_CATEGORIES = {
            'DROPOUT': ['dropout_logo', 'dropout_face_mask_sam', 'dropout_face_mask_ariel'],
            'Distortion': ['bulge', 'stretch', 'swirl', 'fisheye', 'pinch', 'wave', 'mirror',
                          'twirl', 'ripple', 'sphere', 'tunnel', 'water_ripple',
                          'radial_blur', 'cylinder', 'barrel', 'pincushion', 'whirlpool', 'radial_zoom',
                          'concave', 'convex', 'spiral', 'radial_stretch', 'radial_compress',
                          'vertical_wave', 'horizontal_wave', 'skew_horizontal', 'skew_vertical',
                          'rotate_zoom', 'radial_wave', 'zoom_in', 'zoom_out', 'fast_zoom_in',
                          'fast_zoom_out', 'shake', 'pulse', 'spiral_zoom', 'extreme_closeup',
                          'puzzle', 'rotate', 'rotate_45', 'rotate_90', 'flip_horizontal',
                          'flip_vertical', 'flip_both', 'quad_mirror', 'tile', 'radial_tile',
                          'zoom_blur', 'melt', 'kaleidoscope', 'glitch', 'double_vision'],
            'Color & Style': ['black_white', 'sepia', 'vintage', 'neon_glow',
                             'pixelate', 'blur', 'sharpen', 'emboss', 'red_tint', 'blue_tint',
                             'green_tint', 'rainbow', 'negative', 'posterize', 'sketch', 'cartoon',
                             'thermal', 'ice', 'ocean', 'plasma', 'jet', 'turbo', 'inferno',
                             'magma', 'viridis', 'cool', 'hot', 'spring', 'summer', 'autumn',
                             'winter', 'rainbow_shift', 'acid_trip', 'vhs', 'retro', 'cyberpunk',
                             'anime', 'glow', 'solarize', 'edge_detect', 'halftone']
        };
        
        // Build flat list
        Object.values(FILTER_CATEGORIES).forEach(categoryFilters => {
            allFilters.push(...categoryFilters);
        });
        
        // Initialize face-api.js for face detection
        async function initFaceDetection() {
            try {
                // Check if face-api.js is loaded
                if (typeof faceapi === 'undefined') {
                    console.error('face-api.js not loaded');
                    updateStatus('Face detection library not loaded', 'error');
                    return false;
                }
                
                console.log('Loading face-api.js models...');
                updateStatus('Loading face detection models...', 'connected');
                
                // Load face-api.js models (detector + landmarks for eye alignment)
                // Use GitHub raw content for weights (most reliable)
                const modelPath = 'https://raw.githubusercontent.com/justadudewhohacks/face-api.js/master/weights';
                console.log('Loading face detection models from:', modelPath);
                try {
                    await Promise.all([
                        faceapi.nets.tinyFaceDetector.loadFromUri(modelPath),
                        faceapi.nets.faceLandmark68Net.loadFromUri(modelPath)
                    ]);
                    console.log('Face detection and landmark models loaded successfully');
                } catch (error) {
                    console.error('Failed to load from GitHub, trying unpkg:', error);
                    // Fallback to unpkg
                    const unpkgPath = 'https://unpkg.com/face-api.js@0.22.2/weights';
                    await Promise.all([
                        faceapi.nets.tinyFaceDetector.loadFromUri(unpkgPath),
                        faceapi.nets.faceLandmark68Net.loadFromUri(unpkgPath)
                    ]);
                    console.log('Face detection and landmark models loaded from unpkg');
                }
                
                faceApiModelsLoaded = true;
                faceDetection = true; // Mark as available
                
                console.log('Face detection models loaded successfully');
                updateStatus('Face detection ready', 'connected');
                
                return true;
            } catch (error) {
                console.error('Error loading face detection models:', error);
                updateStatus('Face detection unavailable: ' + error.message, 'error');
                faceDetection = null;
                faceApiModelsLoaded = false;
                return false;
            }
        }
        
        // Process video frame with face detection
        let lastFaceDetectionTime = 0;
        const faceDetectionInterval = 500; // Detect faces every 500ms (2fps for face detection) - reduced frequency to prevent flickering
        let cachedDetections = [];
        let lastValidDetections = []; // Keep last valid detections to prevent flickering
        let normalizedDetectionsCache = []; // Cache normalized detections to avoid re-processing every frame
        let isDetecting = false; // Prevent multiple simultaneous detections
        let lastSuccessfulMaskTime = 0; // Timestamp of last successful mask draw
        const maskPersistenceTimeout = Infinity; // Keep mask visible forever - never hide it
        let lastSuccessfulMaskData = null; // Store last successful mask position and size
        let lastKnownMaskPosition = null; // Store the last known mask position (x, y, width, height) - always keep visible
        let lastDrawnMaskPosition = null; // Store last drawn mask position to prevent jitter
        const maskPositionThreshold = 50; // Only update mask position if it moves more than 50 pixels (very high threshold to prevent flickering)
        const maskSmoothingFactor = 0.99; // Use 99% old position, 1% new (extremely smooth, prevents flickering)
        let lockedMaskPosition = null; // Completely locked position - only update on very large movements
        let cachedMaskPosition = null; // Cache the calculated mask position to avoid recalculating every frame
        let lastDetectionHash = null; // Hash of detection to detect when it actually changes
        
        async function processVideoFrame() {
            try {
                if (!localStream || !videoInput.videoWidth) {
                    requestAnimationFrame(processVideoFrame);
                    return;
                }
                
                // Set canvas size to match video
                if (canvasOutput.width !== videoInput.videoWidth || canvasOutput.height !== videoInput.videoHeight) {
                    canvasOutput.width = videoInput.videoWidth;
                    canvasOutput.height = videoInput.videoHeight;
                }
                
                // Draw video frame
            ctx.drawImage(videoInput, 0, 0, canvasOutput.width, canvasOutput.height);
            
            // Apply filter if selected
                if (currentFilter) {
                    if (currentFilter.includes('face_mask') || currentFilter.includes('logo')) {
                        // Face-specific filters - detect faces using face-api.js
                        if (faceApiModelsLoaded) {
                            // Get current time for both detection interval and persistence checks
                            const now = Date.now();
                            
                            // If we have a locked position, run detection less frequently (every 1 second instead of 500ms)
                            // This allows tracking of large movements while preventing flickering
                            const detectionInterval = lockedMaskPosition ? 1000 : faceDetectionInterval;
                            
                            // Only detect faces periodically to improve performance
                            // Use cached detections between intervals to prevent flickering
                            if (now - lastFaceDetectionTime > detectionInterval && !isDetecting) {
                                isDetecting = true;
                                try {
                                    // Use withFaceLandmarks to get eye positions for proper mask alignment
                                    const detections = await faceapi
                                        .detectAllFaces(videoInput, new faceapi.TinyFaceDetectorOptions())
                                        .withFaceLandmarks();
                                    
                                    if (detections && detections.length > 0) {
                                        // If we have a locked position, ONLY check for very large movements to unlock
                                        // Don't update any detection data unless movement is huge
                                        if (lockedMaskPosition) {
                                            const newDetection = detections[0];
                                            const newBox = (newDetection.detection && newDetection.detection.box) || newDetection.box;
                                            if (newBox) {
                                                // Calculate what the new position would be (rough estimate from box)
                                                const scaleFactor = 1.6;
                                                const newWidth = newBox.width * scaleFactor;
                                                const newHeight = newBox.height * scaleFactor;
                                                const offsetX = (newWidth - newBox.width) / 2;
                                                const offsetY = (newHeight - newBox.height) / 2;
                                                const estimatedX = newBox.x - offsetX;
                                                const estimatedY = newBox.y - offsetY;
                                                
                                                // Check if movement is LARGE enough to unlock (75+ pixels - very strict)
                                                const dx = Math.abs(estimatedX - lockedMaskPosition.x);
                                                const dy = Math.abs(estimatedY - lockedMaskPosition.y);
                                                
                                                if (dx > 75 || dy > 75) {
                                                    // Very large movement detected - unlock position to allow tracking
                                                    lockedMaskPosition = null;
                                                    lastDrawnMaskPosition = null;
                                                    cachedMaskPosition = null;
                                                    lastDetectionHash = null;
                                                    // Now update detection data since we unlocked
                                                    cachedDetections = detections;
                                                    lastValidDetections = detections;
                                                    normalizedDetectionsCache = [];
                                                    lastSuccessfulMaskTime = Date.now();
                                                }
                                                // If movement is not large enough, do NOTHING - keep position locked
                                                // This prevents any flickering from detection updates
                                            }
                                        } else {
                                            // No locked position - normal detection update logic
                                            // Only update if we got valid detections AND they're significantly different
                                            let shouldUpdate = true;
                                            if (lastValidDetections && lastValidDetections.length > 0 && 
                                                detections.length > 0) {
                                                const oldDetection = lastValidDetections[0];
                                                const newDetection = detections[0];
                                                const oldBox = (oldDetection.detection && oldDetection.detection.box) || oldDetection.box;
                                                const newBox = (newDetection.detection && newDetection.detection.box) || newDetection.box;
                                                if (oldBox && newBox) {
                                                    const dx = Math.abs(newBox.x - oldBox.x);
                                                    const dy = Math.abs(newBox.y - oldBox.y);
                                                    const dw = Math.abs(newBox.width - oldBox.width);
                                                    const dh = Math.abs(newBox.height - oldBox.height);
                                                    // Only update if detection changed significantly (more than 15 pixels)
                                                    if (dx < 15 && dy < 15 && dw < 15 && dh < 15) {
                                                        shouldUpdate = false; // Keep using old detection
                                                    }
                                                }
                                            }
                                            
                                            if (shouldUpdate) {
                                                cachedDetections = detections;
                                                lastValidDetections = detections;
                                                normalizedDetectionsCache = [];
                                                cachedMaskPosition = null;
                                                lastDetectionHash = null;
                                                lastSuccessfulMaskTime = Date.now();
                                            }
                                        }
                                    }
                                    // If no detections, keep using lastValidDetections (don't clear)
                                    // The mask will persist for 5 seconds using lastSuccessfulMaskData
                                    // If no detections, keep using lastValidDetections (don't clear)
                                    lastFaceDetectionTime = now;
                                } catch (err) {
                                    console.warn('Face detection error:', err);
                                    // Keep using last valid detections on error (don't clear)
                                } finally {
                                    isDetecting = false;
                                }
                            }
                            
                            // Always draw mask with 5-second persistence (prevents flickering)
                            // This ensures mask stays visible even if detection fails temporarily
                            // Reuse 'now' variable from above (declared at line 785)
                            let shouldDrawMask = false;
                            let maskDataToUse = null;
                            
                            // First, try to use current detections
                            if (lastValidDetections && Array.isArray(lastValidDetections) && lastValidDetections.length > 0) {
                                // Only normalize if we don't have cached normalized detections or if detections changed
                                if (normalizedDetectionsCache.length === 0 || normalizedDetectionsCache.length !== lastValidDetections.length) {
                                    // When using .withFaceLandmarks(), face-api.js returns detections with nested structure:
                                    // detection.detection.box (the bounding box)
                                    // detection.landmarks (the landmarks)
                                    // We need to normalize this structure for our code
                                    normalizedDetectionsCache = lastValidDetections.map(d => {
                                        // If detection has nested structure, extract the box
                                        if (d.detection && d.detection.box) {
                                            return {
                                                box: d.detection.box,
                                                landmarks: d.landmarks
                                            };
                                        }
                                        // If box is directly on the detection object
                                        if (d.box) {
                                            return {
                                                box: d.box,
                                                landmarks: d.landmarks
                                            };
                                        }
                                        // Return null if no box found
                                        return null;
                                    }).filter(d => {
                                        if (!d || typeof d !== 'object') return false;
                                        if (!d.box || typeof d.box !== 'object') return false;
                                        // Check all required box properties
                                        return typeof d.box.x === 'number' && 
                                               typeof d.box.y === 'number' &&
                                               typeof d.box.width === 'number' &&
                                               typeof d.box.height === 'number';
                                    });
                                }
                                
                                // Use cached normalized detections
                                if (normalizedDetectionsCache.length > 0) {
                                    shouldDrawMask = true;
                                    maskDataToUse = normalizedDetectionsCache;
                                    // Only update last successful mask time if this is a NEW detection (not cached)
                                    // Check if detection actually changed by comparing with lastSuccessfulMaskData
                                    const currentBox = maskDataToUse[0] && maskDataToUse[0].box;
                                    if (currentBox) {
                                        let isNewDetection = true;
                                        if (lastSuccessfulMaskData && lastSuccessfulMaskData.box) {
                                            const dx = Math.abs(currentBox.x - lastSuccessfulMaskData.box.x);
                                            const dy = Math.abs(currentBox.y - lastSuccessfulMaskData.box.y);
                                            const dw = Math.abs(currentBox.width - lastSuccessfulMaskData.box.width);
                                            const dh = Math.abs(currentBox.height - lastSuccessfulMaskData.box.height);
                                            // If detection hasn't changed significantly, don't reset smoothing
                                            if (dx < 15 && dy < 15 && dw < 15 && dh < 15) {
                                                isNewDetection = false;
                                            }
                                        }
                                        
                                        if (isNewDetection) {
                                            // Only update on truly new detection
                                            lastSuccessfulMaskTime = now;
                                            lastSuccessfulMaskData = {
                                                box: { ...currentBox },
                                                landmarks: maskDataToUse[0].landmarks
                                            };
                                            // Only reset locked position if detection changed by a VERY large amount
                                            // This prevents flickering from small variations
                                            if (lockedMaskPosition) {
                                                const dx = Math.abs(currentBox.x - (lockedMaskPosition.x || 0));
                                                const dy = Math.abs(currentBox.y - (lockedMaskPosition.y || 0));
                                                if (dx > 50 || dy > 50) {
                                                    // Only unlock for very large movements (50+ pixels)
                                                    lockedMaskPosition = null;
                                                    lastDrawnMaskPosition = null;
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            
                            // Always use last successful mask data if available (never hide mask)
                            if (!shouldDrawMask && lastSuccessfulMaskData) {
                                // Use last successful mask position - keep mask visible forever
                                maskDataToUse = [lastSuccessfulMaskData];
                                shouldDrawMask = true;
                            }
                            
                            // If we have a last known position but no detection data, use the cached position
                            if (!shouldDrawMask && lastKnownMaskPosition) {
                                // Create a fake detection from the last known position
                                maskDataToUse = [{
                                    box: {
                                        x: lastKnownMaskPosition.x,
                                        y: lastKnownMaskPosition.y,
                                        width: lastKnownMaskPosition.width,
                                        height: lastKnownMaskPosition.height
                                    },
                                    landmarks: null
                                }];
                                shouldDrawMask = true;
                            }
                            
                            // Always draw mask if we have any data (never hide it)
                            // PRIORITY: If we have a locked position, use it directly without ANY recalculation
                            // This completely bypasses applyFilterWithFaceApi to prevent any position recalculation
                            if (lockedMaskPosition) {
                                // Bypass ALL position calculation - just draw at locked position
                                // This prevents ANY flickering from position recalculation
                                applyFaceMaskSync(ctx, lockedMaskPosition.x, lockedMaskPosition.y, 
                                                 lockedMaskPosition.width, lockedMaskPosition.height);
                            } else if (shouldDrawMask && maskDataToUse && maskDataToUse.length > 0) {
                                // Only call applyFilterWithFaceApi if we don't have a locked position
                                // This will calculate and lock the position on first detection
                                applyFilterWithFaceApi(ctx, maskDataToUse);
                            } else if (lastKnownMaskPosition) {
                                // Even if no detection, draw mask at last known position
                                // This ensures mask never disappears
                                applyFaceMaskSync(ctx, lastKnownMaskPosition.x, lastKnownMaskPosition.y, 
                                                 lastKnownMaskPosition.width, lastKnownMaskPosition.height);
                            }
                        }
                    } else {
                        // Apply full image filters
                        applyFullImageFilter(ctx);
                    }
                }
                
                // Continue processing
                requestAnimationFrame(processVideoFrame);
            } catch (error) {
                console.error('Error in processVideoFrame:', error);
                requestAnimationFrame(processVideoFrame);
            }
        }
        
        
        // Initialize canvas with default size
        function initCanvas() {
            if (canvasOutput.width === 0 || canvasOutput.height === 0) {
                canvasOutput.width = 1280;
                canvasOutput.height = 720;
                // Fill with black background
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, canvasOutput.width, canvasOutput.height);
            }
        }
        
        // Apply filter to canvas using face-api.js detections
        function applyFilterWithFaceApi(ctx, detections) {
            // If we already have a locked position, don't recalculate - just return
            // The caller should use the locked position directly instead
            if (lockedMaskPosition) {
                return;
            }
            
            if (!detections || !Array.isArray(detections) || detections.length === 0) return;
            
            if (currentFilter.includes('face_mask')) {
                // Apply face mask to each detected face with proper offsets
                // Filter out invalid detections first - check each property safely
                const validDetections = detections.filter(d => {
                    try {
                        return d && 
                               typeof d === 'object' && 
                               d.box && 
                               typeof d.box === 'object' &&
                               typeof d.box.x === 'number' && 
                               typeof d.box.y === 'number' &&
                               typeof d.box.width === 'number' &&
                               typeof d.box.height === 'number';
                    } catch (e) {
                        return false;
                    }
                });
                
                validDetections.forEach(detection => {
                    if (!detection || !detection.box) return;
                    
                    const box = detection.box;
                    // Validate box has all required properties
                    if (typeof box.x !== 'number' || typeof box.y !== 'number' || 
                        typeof box.width !== 'number' || typeof box.height !== 'number') {
                        console.warn('Invalid box structure:', box);
                        return;
                    }
                    
                    // Create a hash of the detection to detect when it actually changes
                    const detectionHash = `${Math.round(box.x)}_${Math.round(box.y)}_${Math.round(box.width)}_${Math.round(box.height)}`;
                    
                    // Check if we can reuse cached position
                    let x, y, width, height;
                    if (cachedMaskPosition && lastDetectionHash === detectionHash) {
                        // Reuse cached position - detection hasn't changed
                        x = cachedMaskPosition.x;
                        y = cachedMaskPosition.y;
                        width = cachedMaskPosition.width;
                        height = cachedMaskPosition.height;
                    } else {
                        // Recalculate position from detection
                        x = box.x;
                        y = box.y;
                        width = box.width;
                        height = box.height;
                    
                        // Use landmarks if available for better positioning
                        try {
                        if (detection.landmarks) {
                            // face-api.js landmarks: positions array with {x, y} objects
                            // Left eye landmarks: 36-41, Right eye landmarks: 42-47
                            let landmarks = null;
                            
                            // Try different possible structures
                            if (detection.landmarks.positions) {
                                landmarks = detection.landmarks.positions;
                            } else if (Array.isArray(detection.landmarks)) {
                                landmarks = detection.landmarks;
                            } else if (detection.landmarks.landmarks) {
                                landmarks = detection.landmarks.landmarks;
                            }
                            
                            if (landmarks && Array.isArray(landmarks) && landmarks.length >= 48) {
                                // Calculate left eye center (average of left eye landmarks 36-41)
                                let leftEyeX = 0, leftEyeY = 0;
                                let leftEyeCount = 0;
                                for (let i = 36; i <= 41 && i < landmarks.length; i++) {
                                    const landmark = landmarks[i];
                                    if (landmark && typeof landmark === 'object' && typeof landmark.x === 'number' && typeof landmark.y === 'number') {
                                        leftEyeX += landmark.x;
                                        leftEyeY += landmark.y;
                                        leftEyeCount++;
                                    }
                                }
                                
                                // Calculate right eye center (average of right eye landmarks 42-47)
                                let rightEyeX = 0, rightEyeY = 0;
                                let rightEyeCount = 0;
                                for (let i = 42; i <= 47 && i < landmarks.length; i++) {
                                    const landmark = landmarks[i];
                                    if (landmark && typeof landmark === 'object' && typeof landmark.x === 'number' && typeof landmark.y === 'number') {
                                        rightEyeX += landmark.x;
                                        rightEyeY += landmark.y;
                                        rightEyeCount++;
                                    }
                                }
                                
                                if (leftEyeCount > 0 && rightEyeCount > 0) {
                                    leftEyeX /= leftEyeCount;
                                    leftEyeY /= leftEyeCount;
                                    rightEyeX /= rightEyeCount;
                                    rightEyeY /= rightEyeCount;
                                    
                                    const eyeCenterX = (leftEyeX + rightEyeX) / 2;
                                    const eyeCenterY = (leftEyeY + rightEyeY) / 2;
                                    
                                    // Scale mask larger for better coverage (same as Python: 1.6x)
                                    const scaleFactor = 1.6;
                                    width = box.width * scaleFactor;
                                    height = box.height * scaleFactor;
                                    
                                    // Position mask: center horizontally on eye center
                                    x = eyeCenterX - width / 2;
                                    
                                    // Position vertically so eyes align - place eye center at ~35% from top of mask
                                    // Adjust upward by 40 pixels to better align eyes (same as Python implementation)
                                    y = eyeCenterY - height * 0.35 - 40;
                                } else {
                                    // Fallback to bounding box with scale factor
                                    const scaleFactor = 1.6;
                                    width = box.width * scaleFactor;
                                    height = box.height * scaleFactor;
                                    
                                    // Center the larger mask on the detected face
                                    const offsetX = (width - box.width) / 2;
                                    const offsetY = (height - box.height) / 2;
                                    x = box.x - offsetX;
                                    y = box.y - offsetY;
                                }
                            } else {
                                // Fallback to bounding box with scale factor
                                const scaleFactor = 1.6;
                                width = box.width * scaleFactor;
                                height = box.height * scaleFactor;
                                
                                // Center the larger mask on the detected face
                                const offsetX = (width - box.width) / 2;
                                const offsetY = (height - box.height) / 2;
                                x = box.x - offsetX;
                                y = box.y - offsetY;
                            }
                        } else {
                            // No landmarks, use bounding box with scale factor
                            const scaleFactor = 1.6;
                            width = box.width * scaleFactor;
                            height = box.height * scaleFactor;
                            
                            // Center the larger mask on the detected face
                            const offsetX = (width - box.width) / 2;
                            const offsetY = (height - box.height) / 2;
                            x = box.x - offsetX;
                            y = box.y - offsetY;
                        }
                    } catch (landmarkError) {
                        // If landmark processing fails, fallback to bounding box
                        console.warn('Error processing landmarks, using bounding box:', landmarkError);
                        const scaleFactor = 1.6;
                        width = box.width * scaleFactor;
                        height = box.height * scaleFactor;
                        
                        const offsetX = (width - box.width) / 2;
                        const offsetY = (height - box.height) / 2;
                        x = box.x - offsetX;
                        y = box.y - offsetY;
                    }
                    
                        // Cache the calculated position
                        cachedMaskPosition = { x, y, width, height };
                        lastDetectionHash = detectionHash;
                    } // End of else block (recalculation)
                    
                    // Ensure we don't go out of bounds
                    const canvasWidth = canvasOutput.width;
                    const canvasHeight = canvasOutput.height;
                    if (x + width > canvasWidth) x = canvasWidth - width;
                    if (y + height > canvasHeight) y = canvasHeight - height;
                    if (x < 0) x = 0;
                    if (y < 0) y = 0;
                    
                    // Round coordinates to prevent sub-pixel jitter
                    x = Math.round(x);
                    y = Math.round(y);
                    width = Math.round(width);
                    height = Math.round(height);
                    
                    // Completely lock position to prevent ANY flickering
                    // Only update if position changed by a very large amount
                    if (lockedMaskPosition) {
                        const dx = Math.abs(x - lockedMaskPosition.x);
                        const dy = Math.abs(y - lockedMaskPosition.y);
                        const dw = Math.abs(width - lockedMaskPosition.width);
                        const dh = Math.abs(height - lockedMaskPosition.height);
                        
                        // Only update if position changed by a VERY large amount (50+ pixels)
                        if (dx > maskPositionThreshold || dy > maskPositionThreshold || 
                            dw > maskPositionThreshold || dh > maskPositionThreshold) {
                            // Very smooth interpolation (99% old, 1% new) to prevent sudden jumps
                            const newFactor = 1 - maskSmoothingFactor;
                            x = Math.round(lockedMaskPosition.x * maskSmoothingFactor + x * newFactor);
                            y = Math.round(lockedMaskPosition.y * maskSmoothingFactor + y * newFactor);
                            width = Math.round(lockedMaskPosition.width * maskSmoothingFactor + width * newFactor);
                            height = Math.round(lockedMaskPosition.height * maskSmoothingFactor + height * newFactor);
                            // Update locked position with smoothed values
                            lockedMaskPosition = { x, y, width, height };
                            lastDrawnMaskPosition = { x, y, width, height };
                        } else {
                            // ALWAYS use locked position - never change it for small movements
                            x = lockedMaskPosition.x;
                            y = lockedMaskPosition.y;
                            width = lockedMaskPosition.width;
                            height = lockedMaskPosition.height;
                            // Don't update anything - keep using exact same position
                        }
                    } else {
                        // First time drawing - lock position immediately
                        lockedMaskPosition = { x, y, width, height };
                        lastDrawnMaskPosition = { x, y, width, height };
                    }
                    
                    // Always draw mask (canvas is cleared every frame, so we need to redraw)
                    // But use smoothed/stable position to prevent flickering
                    
                    // Store the last known position so mask never disappears
                    // Use locked position if available, otherwise use current calculated position
                    lastKnownMaskPosition = lockedMaskPosition || { x, y, width, height };
                    
                    // Draw face mask synchronously (images are preloaded)
                    applyFaceMaskSync(ctx, x, y, width, height);
                });
            } else if (currentFilter === 'dropout_logo') {
                // Apply logo to first detected face
                if (detections.length > 0 && detections[0] && detections[0].box) {
                    const detection = detections[0];
                    const box = detection.box;
                    const x = box.x;
                    const y = box.y;
                    const width = box.width;
                    const height = box.height;
                    
                    applyDropoutLogo(ctx, x, y, width, height);
                }
            }
        }
        
        // Apply face mask synchronously (for use when images are preloaded)
        function applyFaceMaskSync(ctx, x, y, width, height) {
            // Extract mask name from filter (e.g., dropout_face_mask_sam -> sam)
            const parts = currentFilter.split('_');
            const maskName = parts[parts.length - 1];
            
            // Determine asset path
            let assetPath = '';
            if (currentFilter.startsWith('dropout_')) {
                assetPath = `assets/dropout/face_mask/${maskName}.png`;
            } else if (currentFilter.startsWith('assets_')) {
                assetPath = `assets/face_mask/${maskName}.png`;
            }
            
            if (!assetPath) {
                return;
            }
            
            // Get cached image (should be preloaded)
            const img = faceMaskImages[assetPath];
            if (!img || !img.complete || !img.naturalWidth || !img.naturalHeight) {
                // Image not ready yet, skip this frame
                return;
            }
            
            // Save context state to prevent any side effects
            ctx.save();
            
            // Use exact pixel coordinates (no rounding needed since we already rounded)
            const drawX = Math.round(x);
            const drawY = Math.round(y);
            const drawW = Math.round(width);
            const drawH = Math.round(height);
            
            // Set composite operation to ensure mask draws correctly
            ctx.globalCompositeOperation = 'source-over';
            
            // Disable image smoothing for crisp rendering
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';
            
            // Draw mask with exact coordinates
            ctx.drawImage(img, drawX, drawY, drawW, drawH);
            
            // Restore context state
            ctx.restore();
        }
        
        // Apply face mask (async version - deprecated, use applyFaceMaskSync instead)
        async function applyFaceMask(ctx, x, y, width, height) {
            // This function is kept for backward compatibility but should not be used in the render loop
            // Use applyFaceMaskSync instead for synchronous drawing
            // Immediately call sync version to prevent flickering
            return applyFaceMaskSync(ctx, x, y, width, height);
        }
        
        // Apply dropout logo
        async function applyDropoutLogo(ctx, x, y, width, height) {
            // Similar to face mask but for logo
            // This would need a logo image asset
            // For now, just draw a placeholder
            ctx.save();
            ctx.fillStyle = '#5250ef';
            ctx.fillRect(x, y, width, height * 0.3);
            ctx.restore();
        }
        
        // Apply distortion filter to face region
        function applyDistortionFilter(ctx, x, y, width, height) {
            // Get image data for face region
            const faceData = ctx.getImageData(x, y, width, height);
            const data = faceData.data;
            
            // Apply distortion based on filter type
            switch(currentFilter) {
                case 'bulge':
                    applyBulge(data, width, height);
                    break;
                case 'pixelate':
                    applyPixelate(data, width, height);
                    break;
                // Add more distortion filters as needed
            }
            
            ctx.putImageData(faceData, x, y);
        }
        
        // Apply full image filter using shared implementations
        function applyFullImageFilter(ctx) {
            // Check if FilterImplementations is available
            if (typeof FilterImplementations === 'undefined') {
                console.error('FilterImplementations not loaded - filters.js may not be loaded. Check browser console for 404 errors.');
                return;
            }
            
            const imageData = ctx.getImageData(0, 0, canvasOutput.width, canvasOutput.height);
            const data = imageData.data;
            const width = canvasOutput.width;
            const height = canvasOutput.height;
            
            // Use shared filter implementations
            const filterMap = {
                'black_white': () => FilterImplementations.applyBlackWhite(data),
                'sepia': () => FilterImplementations.applySepia(data),
                'negative': () => FilterImplementations.applyNegative(data),
                'pixelate': () => FilterImplementations.applyPixelate(data, width, height),
                'blur': () => FilterImplementations.applyBlur(data, width, height),
                'vintage': () => FilterImplementations.applyVintage(data),
                'neon_glow': () => FilterImplementations.applyNeonGlow(data),
                'sharpen': () => FilterImplementations.applySharpen(data, width, height),
                'emboss': () => FilterImplementations.applyEmboss(data, width, height),
                'red_tint': () => FilterImplementations.applyRedTint(data),
                'blue_tint': () => FilterImplementations.applyBlueTint(data),
                'green_tint': () => FilterImplementations.applyGreenTint(data),
                'rainbow': () => FilterImplementations.applyRainbow(data, width, height),
                'posterize': () => FilterImplementations.applyPosterize(data),
                'sketch': () => FilterImplementations.applySketch(data, width, height),
                'cartoon': () => FilterImplementations.applyCartoon(data, width, height),
                'thermal': () => FilterImplementations.applyThermal(data),
                'bulge': () => FilterImplementations.applyBulge(data, width, height)
            };
            
            const filterFunc = filterMap[currentFilter];
            if (filterFunc) {
                try {
                    filterFunc();
                } catch (error) {
                    console.error('Error applying filter:', currentFilter, error);
                }
            } else {
                console.warn('Filter not implemented:', currentFilter);
            }
            
            ctx.putImageData(imageData, 0, 0);
        }
        
        // Filter implementations
        function applyBulge(data, width, height) {
            // Simple bulge effect
            const centerX = width / 2;
            const centerY = height / 2;
            const radius = Math.min(width, height) / 2;
            const strength = 0.5;
            
            const temp = new Uint8ClampedArray(data);
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const dx = x - centerX;
                    const dy = y - centerY;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist < radius) {
                        const angle = Math.atan2(dy, dx);
                        const r = dist / radius;
                        const newR = r * (1 - strength * (1 - r));
                        const newX = Math.round(centerX + Math.cos(angle) * newR * radius);
                        const newY = Math.round(centerY + Math.sin(angle) * newR * radius);
                        
                        if (newX >= 0 && newX < width && newY >= 0 && newY < height) {
                            const srcIdx = (y * width + x) * 4;
                            const dstIdx = (newY * width + newX) * 4;
                            data[srcIdx] = temp[dstIdx];
                            data[srcIdx + 1] = temp[dstIdx + 1];
                            data[srcIdx + 2] = temp[dstIdx + 2];
                            data[srcIdx + 3] = temp[dstIdx + 3];
                        }
                    }
                }
            }
        }
        
        function applyPixelate(data, width, height) {
            const pixelSize = 10;
            for (let y = 0; y < height; y += pixelSize) {
                for (let x = 0; x < width; x += pixelSize) {
                    let r = 0, g = 0, b = 0, count = 0;
                    for (let dy = 0; dy < pixelSize && y + dy < height; dy++) {
                        for (let dx = 0; dx < pixelSize && x + dx < width; dx++) {
                            const idx = ((y + dy) * width + (x + dx)) * 4;
                            r += data[idx];
                            g += data[idx + 1];
                            b += data[idx + 2];
                            count++;
                        }
                    }
                    r = Math.floor(r / count);
                    g = Math.floor(g / count);
                    b = Math.floor(b / count);
                    for (let dy = 0; dy < pixelSize && y + dy < height; dy++) {
                        for (let dx = 0; dx < pixelSize && x + dx < width; dx++) {
                            const idx = ((y + dy) * width + (x + dx)) * 4;
                            data[idx] = r;
                            data[idx + 1] = g;
                            data[idx + 2] = b;
                        }
                    }
                }
            }
        }
        
        function applyBlackWhite(data) {
            for (let i = 0; i < data.length; i += 4) {
                const gray = data[i] * 0.299 + data[i + 1] * 0.587 + data[i + 2] * 0.114;
                data[i] = gray;
                data[i + 1] = gray;
                data[i + 2] = gray;
            }
        }
        
        function applySepia(data) {
            for (let i = 0; i < data.length; i += 4) {
                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];
                data[i] = Math.min(255, (r * 0.393) + (g * 0.769) + (b * 0.189));
                data[i + 1] = Math.min(255, (r * 0.349) + (g * 0.686) + (b * 0.168));
                data[i + 2] = Math.min(255, (r * 0.272) + (g * 0.534) + (b * 0.131));
            }
        }
        
        function applyNegative(data) {
            for (let i = 0; i < data.length; i += 4) {
                data[i] = 255 - data[i];
                data[i + 1] = 255 - data[i + 1];
                data[i + 2] = 255 - data[i + 2];
            }
        }
        
        function applyBlur(data, width, height) {
            const radius = 5;
            const temp = new Uint8ClampedArray(data);
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    let r = 0, g = 0, b = 0, count = 0;
                    for (let dy = -radius; dy <= radius; dy++) {
                        for (let dx = -radius; dx <= radius; dx++) {
                            const nx = x + dx;
                            const ny = y + dy;
                            if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                                const idx = (ny * width + nx) * 4;
                                r += temp[idx];
                                g += temp[idx + 1];
                                b += temp[idx + 2];
                                count++;
                            }
                        }
                    }
                    const idx = (y * width + x) * 4;
                    data[idx] = r / count;
                    data[idx + 1] = g / count;
                    data[idx + 2] = b / count;
                }
            }
        }
        
        // UI Functions (copied from main version)
        function formatFilterName(filter) {
            if (filter === 'dropout_logo') return 'DROPOUT';
            if (filter === 'dropout_face_mask_sam' || filter === 'assets_face_mask_sam' || filter === 'sam_face_mask') return 'Sam';
            if (filter === 'dropout_face_mask_ariel' || filter === 'assets_face_mask_ariel' || filter === 'ariel_face_mask') return 'Ariel';
            const parts = filter.split('_');
            if (parts.length >= 3) {
                const option = parts[parts.length - 1];
                return option.charAt(0).toUpperCase() + option.slice(1);
            }
            return filter.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
        }
        
        function updateStatus(message, type = '') {
            statusDiv.textContent = message;
            statusDiv.className = type;
            if (controlsVisible) {
                statusDiv.classList.remove('hidden');
            } else {
                statusDiv.classList.add('hidden');
            }
        }
        
        function toggleUI() {
            controlsVisible = !controlsVisible;
            if (controlsVisible) {
                controls.classList.remove('hidden');
                controls.classList.add('visible');
                statusDiv.classList.remove('hidden');
                // Auto-hide after 5 seconds
                clearTimeout(uiHideTimeout);
                uiHideTimeout = setTimeout(() => {
                    if (controlsVisible) {
                        toggleUI();
                    }
                }, 5000);
            } else {
                controls.classList.remove('visible');
                controls.classList.add('hidden');
                statusDiv.classList.add('hidden');
            }
        }
        
        // Load cameras
        async function loadCameras() {
            try {
                const devices = await navigator.mediaDevices.enumerateDevices();
                const videoDevices = devices.filter(device => device.kind === 'videoinput');
                cameraSelect.innerHTML = '';
                videoDevices.forEach((device, index) => {
                    const option = document.createElement('option');
                    option.value = device.deviceId;
                    option.textContent = device.label || `Camera ${index + 1}`;
                    cameraSelect.appendChild(option);
                });
                const savedCameraId = localStorage.getItem('wesworld-fx-camera');
                if (savedCameraId) {
                    const cameraExists = Array.from(cameraSelect.options).some(opt => opt.value === savedCameraId);
                    if (cameraExists) {
                        cameraSelect.value = savedCameraId;
                    }
                }
            } catch (error) {
                console.error('Error loading cameras:', error);
                updateStatus('Error loading cameras', 'error');
            }
        }
        
        // Start camera
        async function startCamera() {
            try {
                const deviceId = cameraSelect.value;
                const constraints = {
                    video: {
                        deviceId: deviceId ? { exact: deviceId } : undefined,
                        width: { ideal: 1280 },
                        height: { ideal: 720 }
                    }
                };
                
                localStream = await navigator.mediaDevices.getUserMedia(constraints);
                videoInput.srcObject = localStream;
                
                if (deviceId) {
                    localStorage.setItem('wesworld-fx-camera', deviceId);
                }
                localStorage.setItem('wesworld-fx-camera-active', 'true');
                
                videoInput.onloadedmetadata = () => {
                    // Set canvas size to match video
                    canvasOutput.width = videoInput.videoWidth;
                    canvasOutput.height = videoInput.videoHeight;
                    
                    // Start processing video frames
                    processVideoFrame();
                    
                    updateStatus('Camera active', 'connected');
                    startButton.style.display = 'none';
                    stopButton.style.display = 'block';
                };
            } catch (error) {
                console.error('Error starting camera:', error);
                updateStatus('Camera error: ' + error.message, 'error');
                localStorage.setItem('wesworld-fx-camera-active', 'false');
            }
        }
        
        // Stop camera
        function stopCamera() {
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
                localStream = null;
            }
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
            videoInput.srcObject = null;
            ctx.clearRect(0, 0, canvasOutput.width, canvasOutput.height);
            startButton.style.display = 'block';
            stopButton.style.display = 'none';
            updateStatus('Camera stopped', '');
            localStorage.setItem('wesworld-fx-camera-active', 'false');
        }
        
        // Load filters
        function loadFilters() {
            const fxOptionsContainer = document.getElementById('fxOptionsContainer');
            fxOptionsContainer.innerHTML = '';
            filterSelect.innerHTML = '<option value="">None (Original)</option>';
            
            // Add "None" option
            const noneOption = document.createElement('button');
            noneOption.className = 'fx-option none-option';
            noneOption.textContent = 'None (Original)';
            noneOption.value = '';
            noneOption.onclick = () => selectFilter('');
            fxOptionsContainer.appendChild(noneOption);
            
            // Add filters by category
            Object.entries(FILTER_CATEGORIES).forEach(([category, filters]) => {
                const group = document.createElement('div');
                group.className = 'fx-group';
                
                const groupTitle = document.createElement('div');
                groupTitle.className = 'fx-group-title';
                groupTitle.textContent = category;
                group.appendChild(groupTitle);
                
            filters.forEach(filter => {
                    if (pinnedFilters.includes(filter)) return;
                    
                    const option = createFxOption(filter);
                    group.appendChild(option);
                    
                    const selectOption = document.createElement('option');
                    selectOption.value = filter;
                    selectOption.textContent = formatFilterName(filter);
                    filterSelect.appendChild(selectOption);
                });
                
                fxOptionsContainer.appendChild(group);
            });
        }
        
        function createFxOption(filter) {
                const option = document.createElement('button');
                option.className = 'fx-option';
            option.value = filter;
            
            if (filter.includes('face_mask')) {
                const optionText = document.createElement('span');
                optionText.className = 'fx-option-text';
                optionText.textContent = formatFilterName(filter);
                
                const optionImage = document.createElement('img');
                optionImage.className = 'fx-option-image';
                const parts = filter.split('_');
                const optionName = parts[parts.length - 1];
                if (filter.startsWith('dropout_')) {
                    optionImage.src = `assets/dropout/face_mask/${optionName}.png`;
                }
                optionImage.alt = formatFilterName(filter);
                optionImage.onerror = function() {
                    this.style.display = 'none';
                };
                
                option.appendChild(optionImage);
                option.appendChild(optionText);
            } else {
                const optionText = document.createElement('span');
                optionText.className = 'fx-option-text';
                optionText.textContent = formatFilterName(filter);
                option.appendChild(optionText);
            }
            
            if (filter) {
                const pinIcon = document.createElement('span');
                pinIcon.className = 'fx-option-pin';
                pinIcon.innerHTML = pinnedFilters.includes(filter) ? '' : '';
                pinIcon.title = pinnedFilters.includes(filter) ? 'Unpin' : 'Pin';
                pinIcon.onclick = (e) => {
                    e.stopPropagation();
                    if (pinnedFilters.includes(filter)) {
                        unpinFilter(filter);
                    } else {
                        if (!pinnedFilters.includes(filter)) {
                            pinnedFilters.unshift(filter);
                            savePinnedFilters();
                            updatePinnedFxDisplay();
                            loadFilters();
                        }
                    }
                };
                option.appendChild(pinIcon);
            }
            
            option.onclick = () => selectFilter(filter);
            return option;
        }
        
        // Update URL with current FX and pinned playlist
        function updateURLWithFX(filterValue, playlist = null) {
            const url = new URL(window.location.href);
            
            // Always include pinned FX in playlist if they exist
            let finalPlaylist = playlist;
            if (pinnedFilters && pinnedFilters.length > 0) {
                // Merge pinned filters with provided playlist (pinned first)
                if (playlist && Array.isArray(playlist)) {
                    // Remove duplicates, keep pinned order first
                    const pinnedSet = new Set(pinnedFilters);
                    const playlistSet = new Set(playlist);
                    finalPlaylist = [...pinnedFilters, ...playlist.filter(f => !pinnedSet.has(f))];
                } else {
                    finalPlaylist = [...pinnedFilters];
                }
            }
            
            if (finalPlaylist && Array.isArray(finalPlaylist) && finalPlaylist.length > 0) {
                // Set playlist parameter
                url.searchParams.set('playlist', finalPlaylist.join(','));
                // Also set current FX
                if (filterValue) {
                    url.searchParams.set('fx', filterValue);
                }
            } else if (filterValue) {
                // Set single FX
                url.searchParams.set('fx', filterValue);
                url.searchParams.delete('playlist');
            } else {
                // Clear FX parameters
                url.searchParams.delete('fx');
                url.searchParams.delete('playlist');
            }
            
            // Update URL without reloading page
            window.history.pushState({}, '', url);
        }
        
        // Load FX from URL parameters
        function loadFXFromURL() {
            const urlParams = new URLSearchParams(window.location.search);
            const fxParam = urlParams.get('fx');
            const playlistParam = urlParams.get('playlist');
            
            console.log('Loading FX from URL - fx:', fxParam, 'playlist:', playlistParam);
            console.log('Available filters:', allFilters.length);
            
            if (playlistParam) {
                // Load playlist
                const playlist = playlistParam.split(',').filter(f => f.trim() !== '');
                console.log('Parsed playlist:', playlist);
                if (playlist.length > 0) {
                    // Store playlist for cycling
                    window.fxPlaylist = playlist;
                    window.fxPlaylistIndex = 0;
                    
                    // Load first FX in playlist (or use fx param if provided)
                    const firstFX = fxParam || playlist[0];
                    console.log('Attempting to load FX:', firstFX, 'in allFilters:', allFilters.includes(firstFX));
                    if (firstFX) {
                        // Try to select it - selectFilter will handle validation
                        selectFilter(firstFX, false); // false = don't update URL (already set)
                        console.log('Selected FX from URL:', firstFX);
                    }
                }
            } else if (fxParam) {
                // Load single FX
                console.log('Loading single FX:', fxParam);
                selectFilter(fxParam, false); // false = don't update URL (already set)
                console.log('Selected FX from URL:', fxParam);
            }
        }
        
        function selectFilter(filterValue, updateURL = true) {
            currentFilter = filterValue || '';
            filterSelect.value = currentFilter;
            
            if (currentFilter === '') {
                fxSelectedText.textContent = 'None (Original)';
                const fxCurrentPin = document.getElementById('fxCurrentPin');
                if (fxCurrentPin) fxCurrentPin.style.display = 'none';
            } else {
                fxSelectedText.textContent = formatFilterName(currentFilter);
                const fxCurrentPin = document.getElementById('fxCurrentPin');
                if (fxCurrentPin) {
                    fxCurrentPin.style.display = 'flex';
                    updateCurrentPinIcon(currentFilter);
                }
            }
            
            const allOptions = fxDropdownMenu.querySelectorAll('.fx-option');
            allOptions.forEach(opt => {
                opt.classList.remove('selected');
                if (opt.value === currentFilter) {
                    opt.classList.add('selected');
                }
            });
            
                    fxDropdownMenu.classList.remove('open');
                    fxDropdownButton.classList.remove('open');
            
            // Update URL if requested
            if (updateURL) {
                // Initialize playlist if not exists
                if (!window.fxPlaylist) {
                    window.fxPlaylist = null;
                }
                const playlist = window.fxPlaylist || null;
                updateURLWithFX(filterValue, playlist);
                console.log('URL updated with FX:', filterValue, 'Playlist:', playlist);
            }
        }
        
        function updateCurrentPinIcon(filterValue) {
            const fxCurrentPin = document.getElementById('fxCurrentPin');
            if (!fxCurrentPin || !filterValue) return;
            const isPinned = pinnedFilters.includes(filterValue);
            fxCurrentPin.innerHTML = isPinned ? '' : '';
            fxCurrentPin.title = isPinned ? 'Unpin current FX' : 'Pin current FX';
        }
        
        function pinCurrentFilter() {
            const currentFilter = filterSelect.value || '';
            if (currentFilter && !pinnedFilters.includes(currentFilter)) {
                pinnedFilters.unshift(currentFilter);
                savePinnedFilters();
                updatePinnedFxDisplay();
                updateCurrentPinIcon(currentFilter);
                loadFilters();
            }
        }
        
        function unpinFilter(filterName) {
            pinnedFilters = pinnedFilters.filter(f => f !== filterName);
            savePinnedFilters();
            updatePinnedFxDisplay();
            if (filterSelect.value === filterName) {
                updateCurrentPinIcon(filterName);
            }
            loadFilters();
        }
        
        function loadPinnedFilters() {
            try {
                const saved = localStorage.getItem('wesworld-fx-pinned');
                if (saved) {
                    pinnedFilters = JSON.parse(saved);
                } else {
                    pinnedFilters = [];
                }
                updatePinnedFxDisplay();
                const currentFilter = filterSelect.value || '';
                if (currentFilter) {
                    updateCurrentPinIcon(currentFilter);
                }
            } catch (error) {
                console.error('Error loading pinned filters:', error);
                pinnedFilters = [];
            }
        }
        
        function savePinnedFilters() {
            try {
                localStorage.setItem('wesworld-fx-pinned', JSON.stringify(pinnedFilters));
            } catch (error) {
                console.error('Error saving pinned filters:', error);
            }
        }
        
        function updatePinnedFxDisplay() {
            const container = document.getElementById('pinnedFxContainer');
            container.innerHTML = '';
            container.className = 'pinned-fx-container';
            
            if (pinnedFilters.length === 0) {
                container.innerHTML = '<span style="color: var(--text-secondary-color, #cccccc); font-size: 11px;">No pinned FX</span>';
                return;
            }
            
            pinnedFilters.forEach((filterName) => {
                const item = document.createElement('div');
                item.className = 'pinned-fx-item pinned';
                item.draggable = true;
                item.dataset.filterName = filterName;
                
                const text = document.createElement('span');
                text.className = 'pinned-fx-item-text';
                text.textContent = formatFilterName(filterName);
                text.onclick = () => selectFilter(filterName);
                
                const removeBtn = document.createElement('span');
                removeBtn.className = 'pinned-fx-item-remove';
                removeBtn.textContent = '';
                removeBtn.onclick = (e) => {
                    e.stopPropagation();
                    unpinFilter(filterName);
                };
                
                item.appendChild(text);
                item.appendChild(removeBtn);
                
                // Drag and drop
                item.addEventListener('dragstart', (e) => {
                    e.dataTransfer.effectAllowed = 'move';
                    e.dataTransfer.setData('text/plain', filterName);
                    item.classList.add('dragging');
                });
                
                item.addEventListener('dragend', (e) => {
                    item.classList.remove('dragging');
                    document.querySelectorAll('.pinned-fx-item').forEach(el => {
                        el.classList.remove('drag-over');
                    });
                });
                
                item.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    e.dataTransfer.dropEffect = 'move';
                    item.classList.add('drag-over');
                });
                
                item.addEventListener('dragleave', (e) => {
                    item.classList.remove('drag-over');
                });
                
                item.addEventListener('drop', (e) => {
                    e.preventDefault();
                    item.classList.remove('drag-over');
                    const draggedFilterName = e.dataTransfer.getData('text/plain');
                    if (draggedFilterName && draggedFilterName !== filterName) {
                        const draggedIndex = pinnedFilters.indexOf(draggedFilterName);
                        const targetIndex = pinnedFilters.indexOf(filterName);
                        if (draggedIndex !== -1 && targetIndex !== -1) {
                            pinnedFilters.splice(draggedIndex, 1);
                            pinnedFilters.splice(targetIndex, 0, draggedFilterName);
                            savePinnedFilters();
                            updatePinnedFxDisplay();
                        }
                    }
                });
                
                container.appendChild(item);
            });
        }
        
        function filterFxOptions(searchQuery) {
            const searchLower = searchQuery.toLowerCase().trim();
            const optionsContainer = document.getElementById('fxOptionsContainer');
            const pinnedContainer = document.getElementById('pinnedFxContainer');
            
            if (!searchLower) {
                if (optionsContainer) {
                    const allOptions = optionsContainer.querySelectorAll('.fx-option');
                    const allGroups = optionsContainer.querySelectorAll('.fx-group');
                    allOptions.forEach(option => option.style.display = '');
                    allGroups.forEach(group => group.style.display = '');
                }
                if (pinnedContainer) {
                    const pinnedItems = pinnedContainer.querySelectorAll('.pinned-fx-item');
                    pinnedItems.forEach(item => item.style.display = '');
                }
                return;
            }
            
            function matchesFilter(filterValue, displayText) {
                const filterName = formatFilterName(filterValue).toLowerCase();
                const text = displayText.toLowerCase();
                return text.includes(searchLower) || filterName.includes(searchLower) || filterValue.toLowerCase().includes(searchLower);
            }
            
            if (pinnedContainer) {
                const pinnedItems = pinnedContainer.querySelectorAll('.pinned-fx-item');
                pinnedItems.forEach(item => {
                    const filterName = item.dataset.filterName || '';
                    const text = item.textContent.toLowerCase();
                    item.style.display = matchesFilter(filterName, text) ? '' : 'none';
                });
            }
            
            if (optionsContainer) {
                const allGroups = optionsContainer.querySelectorAll('.fx-group');
                const allOptions = optionsContainer.querySelectorAll('.fx-option');
                
                allOptions.forEach(option => {
                    const textElement = option.querySelector('.fx-option-text');
                    const text = textElement ? textElement.textContent.toLowerCase() : option.textContent.toLowerCase().replace(/|/g, '').trim();
                    const filterValue = option.value || '';
                    const filterName = formatFilterName(filterValue).toLowerCase();
                    const isPinned = pinnedFilters.includes(filterValue);
                    
                    if (isPinned) {
                        option.style.display = 'none';
                    } else {
                        const matches = text.includes(searchLower) || filterName.includes(searchLower) || filterValue.toLowerCase().includes(searchLower);
                        option.style.display = matches ? '' : 'none';
                    }
                });
                
                allGroups.forEach(group => {
                    const childOptions = group.querySelectorAll('.fx-option');
                    let hasVisibleChild = false;
                    childOptions.forEach(child => {
                        if (child.style.display !== 'none') {
                            hasVisibleChild = true;
                        }
                    });
                    group.style.display = hasVisibleChild ? '' : 'none';
                });
            }
        }
        
        function toggleFxDropdown() {
            const isOpen = fxDropdownMenu.classList.contains('open');
            if (isOpen) {
                fxDropdownMenu.classList.remove('open');
                fxDropdownButton.classList.remove('open');
                const fxSearchInput = document.getElementById('fxSearchInput');
                if (fxSearchInput) {
                    fxSearchInput.value = '';
                    filterFxOptions('');
                }
            } else {
                fxDropdownMenu.classList.add('open');
                fxDropdownButton.classList.add('open');
                const fxSearchInput = document.getElementById('fxSearchInput');
                if (fxSearchInput) {
                    setTimeout(() => fxSearchInput.focus(), 100);
                }
            }
        }
        
        function cycleNextFilter() {
            if (pinnedFilters.length > 0) {
                const currentIndex = pinnedFilters.indexOf(currentFilter);
                const nextIndex = (currentIndex + 1) % pinnedFilters.length;
                selectFilter(pinnedFilters[nextIndex]);
            } else {
                const currentIndex = allFilters.indexOf(currentFilter);
                const nextIndex = (currentIndex + 1) % allFilters.length;
                selectFilter(allFilters[nextIndex]);
            }
        }
        
        function cyclePrevFilter() {
            if (pinnedFilters.length > 0) {
                const currentIndex = pinnedFilters.indexOf(currentFilter);
                const prevIndex = (currentIndex - 1 + pinnedFilters.length) % pinnedFilters.length;
                selectFilter(pinnedFilters[prevIndex]);
            } else {
                const currentIndex = allFilters.indexOf(currentFilter);
                const prevIndex = (currentIndex - 1 + allFilters.length) % allFilters.length;
                selectFilter(allFilters[prevIndex]);
            }
        }
        
        function startRandomCycle() {
            if (isRandomCycling) return;
            isRandomCycling = true;
            const filters = pinnedFilters.length > 0 ? pinnedFilters : allFilters;
            if (filters.length === 0) {
                isRandomCycling = false;
                return;
            }
            let cycles = 0;
            const maxCycles = 10;
            randomCycleInterval = setInterval(() => {
                const randomFilter = filters[Math.floor(Math.random() * filters.length)];
                selectFilter(randomFilter, false);
                cycles++;
                if (cycles >= maxCycles) {
                    clearInterval(randomCycleInterval);
                    const finalFilter = filters[Math.floor(Math.random() * filters.length)];
                    selectFilter(finalFilter, true);
                    isRandomCycling = false;
                }
            }, 100);
        }
        
        // Theme definitions (hardcoded for standalone)
        const THEMES = {
            wesworld: {
                name: "WesWorld",
                colors: {
                    background: "#000000",
                    surface: "#1a1a1a",
                    surfaceHover: "#2a2a2a",
                    text: "#ffffff",
                    textSecondary: "#cccccc",
                    accent: "#5250ef",
                    accentHover: "#6260ff",
                    border: "#333333",
                    borderHover: "#5250ef",
                    button: "#5250ef",
                    buttonHover: "#6260ff",
                    statusConnected: "#4caf50",
                    statusError: "#f44336",
                    groupTitle: "#5250ef",
                    selectedText: "#ffffff"
                }
            },
            dropout: {
                name: "Dropout",
                colors: {
                    background: "#0a0a0a",
                    surface: "#1a1a1a",
                    surfaceHover: "#2a2a2a",
                    text: "#ffffff",
                    textSecondary: "#e0e0e0",
                    accent: "#feea3b",
                    accentHover: "#fff04a",
                    border: "#333333",
                    borderHover: "#feea3b",
                    button: "#feea3b",
                    buttonHover: "#fff04a",
                    statusConnected: "#4caf50",
                    statusError: "#ff4444",
                    groupTitle: "#feea3b",
                    selectedText: "#000000"
                }
            }
        };
        
        // Load themes
        async function loadThemes() {
            // Populate theme dropdown
            themeSelect.innerHTML = '';
            Object.keys(THEMES).forEach(themeKey => {
                const option = document.createElement('option');
                option.value = themeKey;
                option.textContent = THEMES[themeKey].name;
                themeSelect.appendChild(option);
            });
            
            // Load saved theme or use default
            const savedTheme = localStorage.getItem('wesworld-fx-theme') || 'wesworld';
            if (THEMES[savedTheme]) {
                themeSelect.value = savedTheme;
                applyTheme(THEMES[savedTheme]);
            } else {
                applyTheme(THEMES.wesworld);
            }
        }
        
        // Theme change handler
        themeSelect.addEventListener('change', (e) => {
            const themeKey = e.target.value;
            if (THEMES[themeKey]) {
                applyTheme(THEMES[themeKey]);
                localStorage.setItem('wesworld-fx-theme', themeKey);
            }
        });
        
        function applyTheme(theme) {
            if (theme.colors) {
                const root = document.documentElement;
                // Map theme color keys to CSS variable names
                const colorMap = {
                    background: 'background-color',
                    surface: 'surface-color',
                    surfaceHover: 'surface-hover-color',
                    text: 'text-color',
                    textSecondary: 'text-secondary-color',
                    accent: 'accent-color',
                    accentHover: 'accent-hover-color',
                    border: 'border-color',
                    borderHover: 'border-hover-color',
                    button: 'button-color',
                    buttonHover: 'button-hover-color',
                    statusConnected: 'status-connected-color',
                    statusError: 'status-error-color',
                    groupTitle: 'group-title-color',
                    selectedText: 'selected-text-color'
                };
                
                Object.entries(theme.colors).forEach(([key, value]) => {
                    const cssVar = colorMap[key] || key.replace(/([A-Z])/g, '-$1').toLowerCase();
                    root.style.setProperty(`--${cssVar}`, value);
                });
            }
        }
        
        // Auto-start camera if needed
        function autoStartCameraIfNeeded() {
            const wasCameraActive = localStorage.getItem('wesworld-fx-camera-active') === 'true';
            if (wasCameraActive && cameraSelect.value) {
                startCamera();
            }
        }
        
        // Event listeners
        startButton.addEventListener('click', startCamera);
        stopButton.addEventListener('click', stopCamera);
        
        cameraSelect.addEventListener('change', async () => {
            if (localStream) {
                stopCamera();
                setTimeout(() => startCamera(), 100);
            }
        });
        
        fxDropdownButton.addEventListener('click', (e) => {
            if (e.target.id === 'fxCurrentPin' || e.target.closest('#fxCurrentPin')) {
                return;
            }
            toggleFxDropdown();
        });
        
        const fxCurrentPin = document.getElementById('fxCurrentPin');
        if (fxCurrentPin) {
            fxCurrentPin.addEventListener('click', (e) => {
                e.stopPropagation();
                const currentFilter = filterSelect.value || '';
                if (currentFilter) {
                    if (pinnedFilters.includes(currentFilter)) {
                        unpinFilter(currentFilter);
                    } else {
                        pinCurrentFilter();
                    }
                }
            });
        }
        
        const fxSearchInput = document.getElementById('fxSearchInput');
        if (fxSearchInput) {
            fxSearchInput.addEventListener('input', (e) => {
                const searchValue = e.target.value;
                if (searchValue.trim()) {
                    const fxDropdownMenu = document.getElementById('fxDropdownMenu');
                    const fxDropdownButton = document.getElementById('fxDropdownButton');
                    if (fxDropdownMenu && !fxDropdownMenu.classList.contains('open')) {
                        fxDropdownMenu.classList.add('open');
                        fxDropdownButton.classList.add('open');
                    }
                }
                filterFxOptions(searchValue);
            });
            
            fxSearchInput.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    fxSearchInput.value = '';
                    filterFxOptions('');
                } else if (e.key === 'Enter') {
                    const pinnedContainer = document.getElementById('pinnedFxContainer');
                    const optionsContainer = document.getElementById('fxOptionsContainer');
                    let firstVisible = null;
                    if (pinnedContainer) {
                        firstVisible = pinnedContainer.querySelector('.pinned-fx-item:not([style*="display: none"])');
                        if (firstVisible && firstVisible.dataset.filterName) {
                            selectFilter(firstVisible.dataset.filterName);
                            return;
                        }
                    }
                    if (optionsContainer) {
                        firstVisible = optionsContainer.querySelector('.fx-option:not([style*="display: none"])');
                        if (firstVisible && firstVisible.value !== undefined) {
                            selectFilter(firstVisible.value);
                        }
                    }
                }
            });
        }
        
        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT' || e.target.tagName === 'TEXTAREA') {
                return;
            }
            if (e.key === 'h' || e.key === 'H') {
                e.preventDefault();
                toggleUI();
            } else if (e.key === 'ArrowUp') {
                e.preventDefault();
                cyclePrevFilter();
            } else if (e.key === 'ArrowDown') {
                e.preventDefault();
                cycleNextFilter();
            } else if (e.key === ' ') {
                e.preventDefault();
                startRandomCycle();
            }
        });
        
        // Wait for face-api.js to load
        function waitForFaceApi() {
            return new Promise((resolve, reject) => {
                if (typeof faceapi !== 'undefined') {
                    resolve();
                    return;
                }
                
                // Check if script tag exists and wait for it to load
                const scriptTag = document.querySelector('script[src*="face-api"]');
                if (scriptTag) {
                    scriptTag.addEventListener('load', () => {
                        if (typeof faceapi !== 'undefined') {
                            resolve();
                        } else {
                            reject(new Error('face-api.js script loaded but faceapi object not found'));
                        }
                    });
                    scriptTag.addEventListener('error', () => {
                        reject(new Error('Failed to load face-api.js script'));
                    });
                    
                    // Also check periodically as fallback
                    let attempts = 0;
                    const maxAttempts = 100;
                    const checkInterval = setInterval(() => {
                        attempts++;
                        if (typeof faceapi !== 'undefined') {
                            clearInterval(checkInterval);
                            resolve();
                        } else if (attempts >= maxAttempts) {
                            clearInterval(checkInterval);
                            reject(new Error('face-api.js failed to load after 10 seconds'));
                        }
                    }, 100);
                } else {
                    reject(new Error('face-api.js script tag not found'));
                }
            });
        }
        
        // Preload face mask images
        async function preloadFaceMasks() {
            const masksToPreload = ['sam', 'ariel'];
            console.log('Preloading face mask images...');
            
            for (const maskName of masksToPreload) {
                const assetPath = `assets/dropout/face_mask/${maskName}.png`;
                if (!faceMaskImages[assetPath]) {
                    try {
                        const img = new Image();
                        img.crossOrigin = 'anonymous';
                        await new Promise((resolve, reject) => {
                            img.onload = () => {
                                console.log('Preloaded face mask:', assetPath);
                                resolve();
                            };
                            img.onerror = (err) => {
                                console.error('Failed to preload face mask:', assetPath, err);
                                reject(err);
                            };
                            img.src = assetPath;
                        });
                        faceMaskImages[assetPath] = img;
                    } catch (error) {
                        console.error('Error preloading face mask:', assetPath, error);
                    }
                }
            }
            console.log('Face mask preloading complete');
        }
        
        // Initialize
        async function init() {
            // Initialize canvas first
            initCanvas();
            
            // Check if FilterImplementations loaded
            if (typeof FilterImplementations === 'undefined') {
                console.error('FilterImplementations not loaded! Check if static/filters.js is accessible.');
                updateStatus('Filter library failed to load', 'error');
            } else {
                console.log('FilterImplementations loaded successfully');
            }
            
            // Wait for face-api.js to load
            try {
                await waitForFaceApi();
                console.log('face-api.js loaded successfully');
            } catch (error) {
                console.error('Failed to load face-api.js:', error);
                updateStatus('Face detection library failed to load', 'error');
            }
            
            await initFaceDetection();
            await loadThemes();
            loadPinnedFilters();
            await loadCameras();
            loadFilters();
            
            // Preload face mask images
            await preloadFaceMasks();
            
            // Load FX from URL parameters (playlist and current FX)
            loadFXFromURL();
            
            // Show UI initially
            controlsVisible = true;
            controls.classList.add('visible');
            updateStatus('Ready - Click "Start Camera" to begin', 'connected');
            
            // Auto-start camera if it was active before
            autoStartCameraIfNeeded();
            
            setTimeout(() => {
                if (controlsVisible) {
                    toggleUI();
                }
            }, 3000);
        }
        
        // Wait for DOM to be ready, then initialize
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', init);
        } else {
            // DOM is already ready, but wait a bit for scripts to load
            setTimeout(init, 100);
        }
    </script>
</body>
</html>
