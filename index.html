<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="description" content="WesWorld FX - High-performance face filters using WebAssembly. Works on desktop, mobile, and all modern browsers.">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>WesWorld FX</title>
    
    <!-- Favicon -->
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üé≠</text></svg>">
    
    <!-- Preconnect for performance -->
    <link rel="preconnect" href="https://cdn.jsdelivr.net">
    <link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }
        
        body {
            background: #000;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            touch-action: none;
            -webkit-user-select: none;
            user-select: none;
        }
        
        #videoContainer {
            width: 100vw;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            background: #000;
            cursor: pointer;
            -webkit-tap-highlight-color: transparent;
        }
        
        #videoInput {
            display: none;
        }
        
        #canvasOutput {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
            display: block;
            background: #000;
            width: 100%;
            height: 100%;
            image-rendering: -webkit-optimize-contrast;
            image-rendering: crisp-edges;
            pointer-events: auto;
            -webkit-tap-highlight-color: transparent;
        }
        
        /* Controls panel */
        #controls {
            position: fixed;
            top: 10px;
            left: 10px;
            z-index: 1000;
            background: var(--surface-color, rgba(26, 26, 26, 0.95));
            color: var(--text-color, white);
            padding: 12px;
            border-radius: 8px;
            border: 1px solid var(--border-color, #333);
            font-size: 14px;
            min-width: 180px;
            max-width: 220px;
            transition: opacity 0.3s, transform 0.3s;
            -webkit-backdrop-filter: blur(10px);
            backdrop-filter: blur(10px);
            max-height: calc(100vh - 20px);
            overflow-y: auto;
        }
        
        @media (max-width: 768px) {
            #controls {
                min-width: 200px;
                max-width: 90vw;
                font-size: 16px;
                padding: 16px;
            }
        }
        
        #controls.visible {
            opacity: 1;
            transform: translateX(0);
        }
        
        #controls.hidden {
            opacity: 0;
            transform: translateX(-100%);
            pointer-events: none;
        }
        
        /* Hide menu button */
        #hideMenuButton {
            width: 100%;
            padding: 10px 12px;
            margin-bottom: 12px;
            background: var(--surface-hover-color, #2a2a2a);
            color: var(--text-color, white);
            border: 1px solid var(--border-color, #333);
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            transition: background-color 0.2s, transform 0.1s, border-color 0.2s;
            -webkit-tap-highlight-color: transparent;
            user-select: none;
        }
        
        #hideMenuButton:hover {
            background: var(--surface-hover-color, #333);
            border-color: var(--border-color, #444);
        }
        
        #hideMenuButton:active {
            transform: scale(0.98);
            background: var(--surface-hover-color, #2d2d2d);
        }
        
        #hideMenuButton:focus {
            outline: 2px solid rgba(82, 80, 239, 0.5);
            outline-offset: 2px;
        }
        
        @media (max-width: 768px) {
            #hideMenuButton {
                padding: 14px 16px;
                font-size: 16px;
                min-height: 48px; /* Larger touch target for mobile */
                margin-bottom: 16px;
            }
        }
        
        /* Status widget removed - camera status shown in settings section */
        #status {
            display: none !important;
        }
        
        #loadingIndicator {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 2000;
            background: rgba(26, 26, 26, 0.95);
            color: white;
            padding: 20px 30px;
            border-radius: 8px;
            text-align: center;
            border: 1px solid var(--border-color, #333);
        }
        
        #loadingIndicator.hidden {
            display: none;
        }
        
        .spinner {
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-top: 3px solid var(--accent-color, #5250ef);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 10px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* Screen reader only - accessible but visually hidden */
        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border-width: 0;
        }
        
        .settings-section,
        .fx-section,
        .help-section {
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid var(--border-color, #333);
        }
        
        .settings-section:last-child,
        .fx-section:last-child,
        .help-section:last-child {
            border-bottom: none;
        }
        
        .section-title {
            font-size: 14px;
            font-weight: bold;
            color: var(--group-title-color, #5250ef);
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            cursor: pointer;
            user-select: none;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .section-title::before {
            content: '‚ñ∂';
            font-size: 10px;
            transition: transform 0.2s;
        }
        
        .section-title.expanded::before {
            transform: rotate(90deg);
        }
        
        .settings-section-content,
        .help-section-content {
            display: none;
        }
        
        .settings-section.expanded .settings-section-content,
        .help-section.expanded .help-section-content {
            display: block;
        }
        
        .help-section-content {
            font-size: 12px;
            line-height: 1.6;
        }
        
        .help-category {
            margin-bottom: 16px;
        }
        
        .help-category-title {
            font-weight: bold;
            color: var(--accent-color, #5250ef);
            margin-bottom: 8px;
            font-size: 13px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .help-command {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 6px;
            padding: 4px 0;
        }
        
        .help-command-desc {
            flex: 1;
            color: var(--text-secondary-color, #cccccc);
            margin-right: 12px;
        }
        
        .help-command-key {
            font-family: 'Monaco', 'Menlo', 'Courier New', monospace;
            background: var(--surface-hover-color, #2a2a2a);
            border: 1px solid var(--border-color, #333);
            border-radius: 4px;
            padding: 2px 6px;
            font-size: 11px;
            color: var(--text-color, white);
            white-space: nowrap;
            min-width: fit-content;
        }
        
        .help-command-key.combo {
            padding: 2px 4px;
        }
        
        .help-command-key kbd {
            display: inline-block;
            padding: 1px 4px;
            margin: 0 2px;
            background: var(--surface-color, #1a1a1a);
            border: 1px solid var(--border-color, #333);
            border-radius: 3px;
        }
        
        /* Legacy dropdown removed - using modal search instead */
        
        .camera-status {
            padding: 8px 12px;
            background: var(--surface-hover-color, #2a2a2a);
            border-radius: 4px;
            margin-bottom: 10px;
            font-size: 13px;
        }
        
        .camera-status.connected {
            color: var(--status-connected-color, #4caf50);
        }
        
        .camera-status.stopped {
            color: var(--text-secondary-color, #cccccc);
        }
        
        .camera-status.error {
            color: var(--status-error-color, #f44336);
        }
        
        .current-fx-display {
            padding: 12px;
            background: var(--surface-color, #1a1a1a);
            border: 1px solid var(--border-color, #333);
            border-radius: 4px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 14px;
            min-height: 20px;
        }
        
        .current-fx-actions {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .clear-filter-button {
            padding: 4px 8px;
            background: transparent;
            border: 1px solid var(--border-color, #333);
            border-radius: 4px;
            color: var(--text-color, white);
            cursor: pointer;
            font-size: 14px;
            line-height: 1;
            transition: all 0.2s;
            min-width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .clear-filter-button:hover {
            background: var(--status-error-color, #f44336);
            border-color: var(--status-error-color, #f44336);
            color: white;
        }
        
        label {
            display: block;
            margin-bottom: 10px;
            font-size: 12px;
            color: var(--text-secondary-color, #cccccc);
        }
        
        select, input {
            width: 100%;
            padding: 8px;
            background: var(--surface-color, #1a1a1a);
            color: var(--text-color, white);
            border: 1px solid var(--border-color, #333);
            border-radius: 4px;
            font-size: 12px;
            margin-top: 4px;
        }
        
        select:focus, input:focus {
            outline: none;
            border-color: var(--accent-color, #5250ef);
        }
        
        button {
            width: 100%;
            padding: 10px;
            background: transparent;
            border: 2px solid var(--button-color, #4a9eff);
            color: var(--button-color, #4a9eff);
            cursor: pointer;
            transition: all 0.2s;
            border-radius: 4px;
            font-size: 14px;
            margin-bottom: 10px;
            touch-action: manipulation;
        }
        
        button:hover, button:active {
            background: var(--button-color, #4a9eff);
            color: var(--selected-text-color, #ffffff);
        }
        
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        button#startButton,
        button#stopButton {
            background: var(--button-color, #4a9eff);
            color: var(--selected-text-color, #ffffff);
        }
        
        button#startButton:hover,
        button#stopButton:hover {
            background: var(--button-hover-color, #5aaeff);
        }
        
        @media (max-width: 768px) {
            select, input, button {
                font-size: 16px;
                padding: 12px;
            }
            button {
                min-height: 44px;
            }
        }
        
        .all-fx-container {
            width: 100%;
        }
        
        /* FX options container in modal */
        .fx-dropdown-menu {
            position: relative;
            width: 100%;
            max-height: 400px;
            overflow-y: auto;
            display: none; /* Hidden by default, shown when search input focused */
        }
        
        /* Show FX list when search input is focused */
        .fx-search-modal.active .fx-search-input:focus ~ .fx-search-results .fx-dropdown-menu,
        .fx-search-modal.active .fx-search-input:not(:placeholder-shown) ~ .fx-search-results .fx-dropdown-menu {
            display: block;
        }
        
        .all-fx-container .pinned-fx-container {
            margin-bottom: 8px;
        }
        
        /* Spotlight-style search trigger */
        .fx-search-trigger {
            width: 100%;
            padding: 12px;
            background: var(--surface-color, #1a1a1a);
            color: var(--text-secondary-color, #cccccc);
            border: 1px solid var(--border-color, #333);
            border-radius: 8px;
            font-size: 14px;
            cursor: pointer;
            text-align: left;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: all 0.2s;
            margin-top: 4px;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
            user-select: none;
        }
        
        .fx-search-trigger:hover,
        .fx-search-trigger:active {
            background: var(--surface-hover-color, #2a2a2a);
            border-color: var(--accent-color, #5250ef);
        }
        
        .fx-search-trigger span {
            font-size: 16px;
        }
        
        @media (max-width: 768px) {
            .fx-search-trigger {
                padding: 16px;
                font-size: 16px;
                min-height: 48px;
            }
        }
        
        /* Spotlight-style search modal - Full screen */
        .fx-search-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            z-index: 10000;
            align-items: flex-start;
            justify-content: center;
            padding: 0;
            animation: fadeIn 0.2s ease-out;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            touch-action: pan-y;
            /* Ensure it's above everything */
            isolation: isolate;
        }
        
        .fx-search-modal.active,
        .fx-search-modal[aria-hidden="false"] {
            display: flex;
        }
        
        .fx-search-modal[aria-hidden="true"] {
            display: none;
        }
        
        @keyframes fadeIn {
            from {
                opacity: 0;
            }
            to {
                opacity: 1;
            }
        }
        
        .fx-search-modal-content {
            width: 100%;
            max-width: 600px;
            background: #1e1e1e;
            border-radius: 0;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.6);
            overflow: hidden;
            animation: slideDown 0.2s ease-out;
            max-height: 85vh;
            display: flex;
            flex-direction: column;
            margin: 0;
            position: relative;
            pointer-events: auto;
            /* Better contrast and readability */
            color: #ffffff;
            border: 1px solid #333;
        }
        
        /* Prevent clicks inside content from closing modal */
        .fx-search-modal-content * {
            pointer-events: auto;
        }
        
        /* Mobile-first responsive design */
        @media (max-width: 768px) {
            .fx-search-modal {
                padding: 0;
                align-items: stretch;
                /* Safe area insets for notched devices */
                padding-top: env(safe-area-inset-top);
                padding-bottom: env(safe-area-inset-bottom);
                padding-left: env(safe-area-inset-left);
                padding-right: env(safe-area-inset-right);
            }
            
            .fx-search-modal-content {
                width: 100%;
                max-width: 100%;
                border-radius: 0;
                max-height: 100vh;
                min-height: 100vh;
                /* Account for safe areas */
                max-height: calc(100vh - env(safe-area-inset-top) - env(safe-area-inset-bottom));
                min-height: calc(100vh - env(safe-area-inset-top) - env(safe-area-inset-bottom));
            }
        }
        
        /* Tablet and desktop */
        @media (min-width: 769px) {
            .fx-search-modal {
                padding-top: 8vh;
                padding-bottom: 8vh;
                padding-left: 2vw;
                padding-right: 2vw;
            }
            
            .fx-search-modal-content {
                border-radius: 8px;
                max-height: 75vh;
                box-shadow: 0 12px 48px rgba(0, 0, 0, 0.7);
                /* Better spacing on larger screens */
                margin: 0 auto;
            }
        }
        
        /* Large desktop */
        @media (min-width: 1200px) {
            .fx-search-modal-content {
                max-width: 550px;
            }
        }
        
        @keyframes slideDown {
            from {
                transform: translateY(-20px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }
        
        .fx-search-header {
            padding: 16px;
            border-bottom: 1px solid #333;
            display: flex;
            flex-direction: column;
            align-items: stretch;
            position: relative;
            flex-shrink: 0;
            background: #1e1e1e;
            /* Better spacing and touch targets */
            gap: 8px;
        }
        
        @media (max-width: 768px) {
            .fx-search-header {
                padding: 14px 16px;
                /* Safe area padding for notched devices */
                padding-left: max(16px, env(safe-area-inset-left));
                padding-right: max(16px, env(safe-area-inset-right));
                padding-top: max(14px, env(safe-area-inset-top));
            }
        }
        
        .fx-search-input-wrapper {
            position: relative;
            display: flex;
            align-items: center;
            width: 100%;
        }
        
        .fx-search-icon {
            position: absolute;
            left: 14px;
            top: 50%;
            transform: translateY(-50%);
            color: #888;
            pointer-events: none;
            z-index: 1;
            transition: color 0.2s;
        }
        
        .fx-search-header .fx-search-input:focus ~ .fx-search-icon,
        .fx-search-header .fx-search-input:not(:placeholder-shown) ~ .fx-search-icon {
            color: #ffd700;
        }
        
        .fx-search-header .fx-search-input {
            width: 100%;
            padding: 12px 40px 12px 42px;
            background: #2a2a2a;
            border: 1px solid #444;
            border-radius: 8px;
            font-size: 15px;
            color: #ffffff !important;
            min-width: 0;
            -webkit-appearance: none;
            appearance: none;
            /* Better focus visibility */
            transition: border-color 0.2s, box-shadow 0.2s, background-color 0.2s;
            font-weight: 400;
        }
        
        .fx-search-header .fx-search-input:focus {
            outline: none;
            border-color: #ffd700;
            box-shadow: 0 0 0 3px rgba(255, 215, 0, 0.15);
            background: #2f2f2f;
        }
        
        .fx-search-header .fx-search-input:hover:not(:focus) {
            border-color: #555;
            background: #2d2d2d;
        }
        
        @media (max-width: 768px) {
            .fx-search-header .fx-search-input {
                padding: 14px 48px 14px 48px;
                font-size: 16px;
                min-height: 48px; /* Larger touch target for mobile */
                border-width: 1px;
                border-radius: 10px;
            }
            
            .fx-search-icon {
                left: 16px;
                width: 20px;
                height: 20px;
            }
        }
        
        .fx-search-clear {
            position: absolute;
            right: 0px;
            top: 7px;
            width: 40px;
            background: none;
            border: none;
            color: #666666;
            cursor: pointer;
            font-size: 20px;
            line-height: 1;
            padding: 8px;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s, color 0.2s, background-color 0.2s, transform 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 36px;
            border-radius: 50%;
            z-index: 2;
            -webkit-tap-highlight-color: transparent;
        }
        
        .fx-search-clear.visible {
            opacity: 1;
            pointer-events: all;
        }
        
        .fx-search-clear:hover,
        .fx-search-clear:focus {
            color: #ffffff;
            background-color: rgba(255, 255, 255, 0.15);
            outline: 2px solid rgba(255, 215, 0, 0.3);
            outline-offset: 2px;
            transform: scale(1.1);
        }
        
        .fx-search-clear:active {
            background-color: rgba(255, 255, 255, 0.25);
            transform: scale(0.95);
        }
        
        @media (max-width: 768px) {
            .fx-search-clear {
                right: 0px;
                width: 44px;
                min-height: 44px;
                font-size: 22px;
            }
        }
        
        .fx-search-header .fx-search-input::placeholder {
            color: #999 !important;
            opacity: 1;
        }
        
        .fx-search-header .fx-search-input:focus::placeholder {
            color: #777 !important;
        }
        
        .fx-search-header .fx-search-input:-webkit-autofill,
        .fx-search-header .fx-search-input:-webkit-autofill:hover,
        .fx-search-header .fx-search-input:-webkit-autofill:focus {
            -webkit-text-fill-color: #ffffff !important;
            -webkit-box-shadow: 0 0 0px 1000px var(--surface-hover-color, #2a2a2a) inset !important;
        }
        
        .fx-search-results {
            overflow-y: auto;
            max-height: calc(85vh - 80px);
            padding: 4px;
            -webkit-overflow-scrolling: touch;
            flex: 1;
            background: #1e1e1e;
            /* Better scrollbar styling */
            scrollbar-width: thin;
            scrollbar-color: #ffd700 transparent;
        }
        
        .fx-search-results::-webkit-scrollbar {
            width: 6px;
        }
        
        .fx-search-results::-webkit-scrollbar-track {
            background: transparent;
        }
        
        .fx-search-results::-webkit-scrollbar-thumb {
            background: #555;
            border-radius: 3px;
        }
        
        .fx-search-results::-webkit-scrollbar-thumb:hover {
            background: #666;
        }
        
        @media (max-width: 768px) {
            .fx-search-results {
                max-height: calc(85vh - 100px);
                padding: 8px;
                /* Account for safe areas */
                padding-left: max(8px, env(safe-area-inset-left));
                padding-right: max(8px, env(safe-area-inset-right));
                padding-bottom: max(8px, env(safe-area-inset-bottom));
            }
        }
        
        .fx-search-results .fx-dropdown-menu,
        .fx-search-results #fxOptionsContainer {
            display: block !important;
            position: relative;
            top: auto;
            left: auto;
            right: auto;
            margin: 0;
            max-height: none;
            border: none;
            background: transparent;
        }
        
        .fx-search-results .fx-group {
            margin-bottom: 6px;
        }
        
        .fx-search-results .fx-option {
            padding: 10px 12px;
            align-items: center;
        }
        
        .fx-search-results .fx-option-text {
            display: flex;
            align-items: center;
        }
        
        .fx-search-results .fx-option-pin {
            align-self: center;
        }
        
        /* Ensure all text in modal is visible */
        .fx-search-modal-content,
        .fx-search-modal-content * {
            color: #ffffff;
        }
        
        .fx-search-modal-content .fx-group-title,
        .fx-search-modal-content button {
            color: inherit;
        }
        
        /* Text color is handled by .fx-option-text rules above */
        .fx-search-modal-content .fx-option-text {
            color: #ffffff;
        }
        
        .fx-search-modal-content .fx-option.selected .fx-option-text {
            color: #000000 !important;
        }
        
        .fx-group {
            margin-bottom: 4px;
        }
        
        .fx-group-title {
            padding: 6px 12px;
            font-size: 10px;
            font-weight: 700;
            color: #ffd700;
            text-transform: uppercase;
            background: #252525;
            border-bottom: 1px solid #333;
            letter-spacing: 0.5px;
        }
        
        .fx-option {
            padding: 10px 12px;
            color: #ffffff !important;
            cursor: pointer;
            border: none;
            background: transparent;
            width: 100%;
            text-align: left;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 10px;
            transition: all 0.15s;
            min-height: 40px; /* WCAG minimum touch target */
            -webkit-tap-highlight-color: transparent;
            position: relative;
            user-select: none;
            font-weight: 400;
            box-sizing: border-box;
        }
        
        .fx-option:hover,
        .fx-option:focus {
            background: #2a2a2a;
            outline: none;
        }
        
        .fx-option:hover,
        .fx-option:focus,
        .fx-option.selected {
            border-radius: 0;
        }
        
        .fx-option:active {
            background: #333;
            transform: scale(0.99);
        }
        
        /* Better touch feedback on mobile */
        @media (hover: none) and (pointer: coarse) {
            .fx-option:active {
                background: #333;
                transform: scale(0.98);
            }
        }
        
        .fx-option.selected {
            background: #ffd700 !important;
            color: #000000 !important;
            font-weight: 600;
            border: none;
        }
        
        .fx-option.selected:focus {
            outline: none;
            background: #ffd700 !important;
        }
        
        .fx-option.selected:hover {
            background: #ffed4e !important;
        }
        
        @media (max-width: 768px) {
            .fx-option {
                padding: 12px 14px;
                font-size: 15px;
                min-height: 48px; /* Larger touch target on mobile */
            }
        }
        
        .fx-option-image {
            width: 36px;
            height: 36px;
            object-fit: cover;
            border-radius: 50%;
            border: 2px solid #444;
            flex-shrink: 0;
        }
        
        .fx-option.selected .fx-option-image {
            border-color: #000;
        }
        
        .fx-option-text {
            flex: 1;
            min-width: 0; /* Allow text to shrink if needed */
            text-overflow: ellipsis;
            white-space: nowrap;
            color: #ffffff; /* Default white text for non-selected items */
            display: flex;
            align-items: center;
            line-height: 1.4;
        }
        
        /* Black text when selected */
        .fx-option.selected .fx-option-text {
            color: #000000 !important;
        }
        
        /* White text when not selected (explicit for clarity) */
        .fx-option:not(.selected) .fx-option-text {
            color: #ffffff !important;
        }
        
        .fx-option-pin {
            cursor: pointer;
            font-size: 14px;
            padding: 0;
            opacity: 0.6;
            transition: opacity 0.2s, background-color 0.2s, transform 0.1s;
            background: transparent;
            border: none;
            border-radius: 4px;
            min-width: 32px;
            min-height: 32px;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            -webkit-tap-highlight-color: transparent;
            flex-shrink: 0;
            margin-left: auto;
            margin-right: 0;
            box-sizing: border-box;
            line-height: 1;
        }
        
        .fx-option:hover .fx-option-pin {
            opacity: 0.9;
        }
        
        .fx-option-pin:hover,
        .fx-option-pin:focus {
            opacity: 1;
            background-color: rgba(255, 255, 255, 0.15);
            outline: none;
        }
        
        .fx-option-pin:active {
            background-color: rgba(255, 255, 255, 0.25);
            transform: scale(0.9);
        }
        
        /* Ensure pin button doesn't interfere with option click */
        .fx-option-pin:active,
        .fx-option-pin:focus {
            z-index: 1;
            position: relative;
        }
        
        @media (max-width: 768px) {
            .fx-option-pin {
                min-width: 36px;
                min-height: 36px;
                font-size: 16px;
            }
        }
        
        .fx-current-pin {
            cursor: pointer;
            font-size: 16px;
            padding: 4px;
            opacity: 0.7;
            transition: opacity 0.2s;
        }
        
        .fx-current-pin:hover {
            opacity: 1;
        }
        
        .fx-search-input {
            width: 100%;
            padding: 8px;
            background: var(--surface-color, #1a1a1a);
            color: var(--text-color, white);
            border: 1px solid var(--border-color, #333);
            border-radius: 4px;
            font-size: 12px;
        }
        
        .pinned-fx-container {
            margin-bottom: 10px;
            min-height: 20px;
        }
        
        .pinned-fx-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 10px;
            margin-bottom: 4px;
            background: var(--surface-hover-color, #2a2a2a);
            border: 1px solid var(--border-color, #333);
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
            user-select: none;
            transition: all 0.2s;
            width: 100%;
        }
        
        .pinned-fx-item:hover {
            background: var(--accent-color, #5250ef);
            border-color: var(--accent-color, #5250ef);
        }
        
        .pinned-fx-item-text {
            flex: 1;
            cursor: pointer;
        }
        
        .pinned-fx-item-remove {
            cursor: pointer;
            font-size: 18px;
            font-weight: bold;
            opacity: 0.7;
            padding: 0 4px;
        }
        
        .pinned-fx-item-remove:hover {
            opacity: 1;
        }
        
        /* Tutorial Modal */
        .tutorial-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            z-index: 20000;
            align-items: center;
            justify-content: center;
            padding: 20px;
            animation: fadeIn 0.3s ease-out;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
        }
        
        .tutorial-modal[aria-hidden="false"] {
            display: flex;
        }
        
        .tutorial-modal[aria-hidden="true"] {
            display: none;
        }
        
        .tutorial-modal-content {
            width: 100%;
            max-width: 600px;
            background: var(--surface-color, #1e1e1e);
            border-radius: 12px;
            box-shadow: 0 12px 48px rgba(0, 0, 0, 0.8);
            overflow: hidden;
            animation: slideUp 0.3s ease-out;
            color: var(--text-color, #ffffff);
            border: 1px solid var(--border-color, #333);
            display: flex;
            flex-direction: column;
            max-height: 90vh;
        }
        
        @keyframes slideUp {
            from {
                transform: translateY(30px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }
        
        .tutorial-header {
            padding: 24px;
            border-bottom: 1px solid var(--border-color, #333);
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: var(--surface-color, #1e1e1e);
        }
        
        .tutorial-header h2 {
            margin: 0;
            font-size: 24px;
            font-weight: 600;
            color: var(--text-color, #ffffff);
        }
        
        .tutorial-close {
            background: transparent;
            border: none;
            color: var(--text-color, #ffffff);
            font-size: 32px;
            line-height: 1;
            cursor: pointer;
            padding: 0;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            transition: background 0.2s;
        }
        
        .tutorial-close:hover {
            background: var(--surface-hover-color, rgba(255, 255, 255, 0.1));
        }
        
        .tutorial-body {
            padding: 24px;
            flex: 1;
            overflow-y: auto;
        }
        
        .tutorial-step {
            margin-bottom: 32px;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        
        .tutorial-step:last-child {
            margin-bottom: 0;
        }
        
        .tutorial-icon {
            font-size: 48px;
            text-align: center;
            margin-bottom: 8px;
        }
        
        .tutorial-step h3 {
            margin: 0;
            font-size: 20px;
            font-weight: 600;
            color: var(--text-color, #ffffff);
        }
        
        .tutorial-step p {
            margin: 0;
            font-size: 16px;
            line-height: 1.6;
            color: var(--text-secondary-color, #cccccc);
        }
        
        .tutorial-step kbd {
            background: var(--surface-hover-color, #333);
            border: 1px solid var(--border-color, #555);
            border-radius: 4px;
            padding: 2px 6px;
            font-family: monospace;
            font-size: 14px;
            color: var(--text-color, #ffffff);
        }
        
        .tutorial-footer {
            padding: 20px 24px;
            border-top: 1px solid var(--border-color, #333);
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 16px;
            background: var(--surface-color, #1e1e1e);
            flex-wrap: wrap;
        }
        
        .tutorial-checkbox {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            font-size: 14px;
            color: var(--text-secondary-color, #cccccc);
            user-select: none;
        }
        
        .tutorial-checkbox input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }
        
        .tutorial-button {
            background: var(--accent-color, #5250ef);
            color: var(--selected-text-color, #ffffff);
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.2s, transform 0.1s;
            min-width: 120px;
        }
        
        .tutorial-button:hover {
            background: var(--accent-hover-color, #6361ff);
            transform: translateY(-1px);
        }
        
        .tutorial-button:active {
            transform: translateY(0);
        }
        
        @media (max-width: 768px) {
            .tutorial-modal {
                padding: 16px;
            }
            
            .tutorial-modal-content {
                max-width: 100%;
                border-radius: 8px;
                max-height: 95vh;
            }
            
            .tutorial-header {
                padding: 20px;
            }
            
            .tutorial-header h2 {
                font-size: 20px;
            }
            
            .tutorial-body {
                padding: 20px;
            }
            
            .tutorial-step {
                margin-bottom: 24px;
            }
            
            .tutorial-icon {
                font-size: 40px;
            }
            
            .tutorial-step h3 {
                font-size: 18px;
            }
            
            .tutorial-step p {
                font-size: 15px;
            }
            
            .tutorial-footer {
                padding: 16px 20px;
                flex-direction: column;
                align-items: stretch;
            }
            
            .tutorial-button {
                width: 100%;
            }
        }
        
        /* Corner tap areas - invisible but clickable for easy menu access */
        .corner-tap-area {
            position: fixed;
            z-index: 9999;
            background: transparent;
            pointer-events: auto;
            display: block; /* Shown on all screen sizes */
        }
        
        .corner-tap-area.top-left {
            top: 0;
            left: 0;
            width: 80px;
            height: 80px;
        }
        
        .corner-tap-area.top-right {
            top: 0;
            right: 0;
            width: 80px;
            height: 80px;
        }
        
        .corner-tap-area.bottom-left {
            bottom: 0;
            left: 0;
            width: 80px;
            height: 80px;
        }
        
        .corner-tap-area.bottom-right {
            bottom: 0;
            right: 0;
            width: 80px;
            height: 80px;
        }
        
        /* Visibility is controlled by JavaScript based on device type */
    </style>
</head>
<body>
    <div id="loadingIndicator">
        <div class="spinner"></div>
        <div>Loading...</div>
    </div>
    
    <div id="controls" class="hidden">
        <!-- Hide Menu Button -->
        <button id="hideMenuButton" type="button" aria-label="Hide menu">
            <span>‚úï</span> Hide Menu
        </button>
        
        <!-- Settings Section -->
        <div class="settings-section">
            <div class="section-title" id="settingsToggle">Settings</div>
            <div class="settings-section-content">
                <label>
                    Theme:
                    <select id="themeSelect">
                        <option value="wesworld">WesWorld</option>
                        <option value="dropout">Dropout</option>
                    </select>
                </label>
                <label>
                    Camera:
                    <select id="cameraSelect"></select>
                </label>
                <div class="camera-status">
                    <span id="cameraStatusText">Camera: Stopped</span>
                </div>
                <button id="startButton">Start Camera</button>
                <button id="stopButton" style="display: none;">Stop Camera</button>
                <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid var(--border-color, #333);">
                    <label style="display: block; margin-bottom: 8px;">
                        Face Mask Zoom:
                        <span id="faceMaskZoomDisplay" style="font-weight: bold; color: var(--accent-color, #5250ef);">100%</span>
                    </label>
                    <button id="resetFaceMaskZoomButton" style="width: 100%;">Reset to Default</button>
                </div>
                <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid var(--border-color, #333);">
                    <div style="font-size: 12px; color: var(--text-secondary-color, #cccccc);">
                        <div style="margin-bottom: 4px;">
                            <strong>Version:</strong> <span id="appVersion">1.0.0</span>
                        </div>
                        <div style="margin-bottom: 4px;">
                            <strong>Build:</strong> <span id="appBuild">0</span>
                        </div>
                        <div>
                            <strong>Last Update:</strong> <span id="lastUpdateTime">Never</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Search FX (moved above FX section) -->
        <div style="margin-bottom: 20px; padding-bottom: 15px; border-bottom: 1px solid var(--border-color, #333);">
            <button id="fxSearchTrigger" class="fx-search-trigger" type="button" style="width: 100%;">
                <span>üîç</span> Search FX...
            </button>
        </div>
        
        <!-- FX Section -->
        <div class="fx-section">
            <div class="section-title">FX</div>
            <label>
                Current FX:
                <div class="current-fx-display">
                    <span id="fxSelectedText">None (Original)</span>
                    <div class="current-fx-actions">
                        <span id="fxCurrentPin" class="fx-current-pin" style="display: none;" title="Pin current FX"></span>
                        <button id="clearFilterButton" class="clear-filter-button" type="button" title="Clear filter (C)" style="display: none;">‚úï</button>
                    </div>
                </div>
            </label>
            <label>
                Pinned FX:
                <div class="all-fx-container">
                    <button id="startRouletteButton" type="button" style="width: 100%; margin-bottom: 8px;">üé∞ Start Roulette</button>
                    <div id="pinnedFxContainer" class="pinned-fx-container"></div>
                </div>
            </label>
            
        </div>
        
        <!-- Help Section -->
        <div class="help-section">
            <div class="section-title" id="helpToggle">Help</div>
            <div class="help-section-content">
                <div class="help-category">
                    <div class="help-category-title">Navigation</div>
                    <div class="help-command">
                        <span class="help-command-desc">Toggle UI visibility</span>
                        <span class="help-command-key">H</span>
                    </div>
                    <div class="help-command">
                        <span class="help-command-desc">Open FX search</span>
                        <span class="help-command-key"><kbd>F</kbd></span>
                    </div>
                </div>
                
                <div class="help-category">
                    <div class="help-category-title">Filter Controls</div>
                    <div class="help-command">
                        <span class="help-command-desc">Previous filter</span>
                        <span class="help-command-key">‚Üë / ‚Üê</span>
                    </div>
                    <div class="help-command">
                        <span class="help-command-desc">Next filter</span>
                        <span class="help-command-key">‚Üì / ‚Üí</span>
                    </div>
                    <div class="help-command">
                        <span class="help-command-desc">Random cycle</span>
                        <span class="help-command-key">Space</span>
                    </div>
                    <div class="help-command">
                        <span class="help-command-desc">Clear filter</span>
                        <span class="help-command-key">C / Esc</span>
                    </div>
                </div>
                
                <div class="help-category">
                    <div class="help-category-title">Face Mask Controls</div>
                    <div class="help-command">
                        <span class="help-command-desc">Increase mask size</span>
                        <span class="help-command-key">+ / =</span>
                    </div>
                    <div class="help-command">
                        <span class="help-command-desc">Decrease mask size</span>
                        <span class="help-command-key">- / _</span>
                    </div>
                    <div class="help-command">
                        <span class="help-command-desc">(Only active when face mask filter is selected)</span>
                        <span class="help-command-key" style="visibility: hidden;"></span>
                    </div>
                </div>
                
                <div class="help-category">
                    <div class="help-category-title">Tips</div>
                    <div style="color: var(--text-secondary-color, #cccccc); font-size: 11px; line-height: 1.5;">
                        ‚Ä¢ Click the pin icon (üìå) to save favorite filters<br>
                        ‚Ä¢ Drag pinned filters to reorder them<br>
                        ‚Ä¢ Use search (F) to quickly find filters<br>
                        ‚Ä¢ Press H to hide/show the UI for clean video capture
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Spotlight-style FX Search Modal - Outside controls for full viewport coverage -->
    <div 
        id="fxSearchModal" 
        class="fx-search-modal" 
        role="dialog" 
        aria-modal="true" 
        aria-labelledby="fxSearchModalTitle" 
        aria-hidden="true"
        tabindex="-1"
    >
        <div class="fx-search-modal-content">
            <div class="fx-search-header">
                <h2 id="fxSearchModalTitle" class="sr-only">Search Filters</h2>
                <label for="fxSearchInput" class="sr-only">Search for filters</label>
                <div class="fx-search-input-wrapper">
                    <svg class="fx-search-icon" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
                        <circle cx="11" cy="11" r="8"></circle>
                        <path d="m21 21-4.35-4.35"></path>
                    </svg>
                    <input 
                        type="text" 
                        id="fxSearchInput" 
                        class="fx-search-input" 
                        placeholder="Search filters and face masks..." 
                        autocomplete="off"
                        aria-label="Search filters"
                        aria-describedby="fxSearchHint"
                        aria-controls="fxSearchResults"
                        aria-expanded="false"
                    >
                    <button 
                        class="fx-search-clear" 
                        id="fxSearchClear" 
                        type="button" 
                        aria-label="Clear search"
                        tabindex="0"
                    >√ó</button>
                </div>
                <span id="fxSearchHint" class="sr-only">Type to search filters. Press Escape to close, Enter to select first result.</span>
            </div>
            <div 
                class="fx-search-results" 
                id="fxSearchResults" 
                role="listbox" 
                aria-label="Filter options"
                aria-live="polite"
                aria-atomic="false"
            >
                <div id="fxOptionsContainer" class="fx-dropdown-menu" role="group"></div>
            </div>
        </div>
    </div>
    
    <div id="status" class="hidden">Initializing...</div>
    
    <!-- Corner tap areas - invisible but clickable for easy menu access -->
    <div class="corner-tap-area top-left" id="cornerTopLeft" aria-label="Tap to open menu"></div>
    <div class="corner-tap-area top-right" id="cornerTopRight" aria-label="Tap to open menu"></div>
    <div class="corner-tap-area bottom-left" id="cornerBottomLeft" aria-label="Tap to open menu"></div>
    <div class="corner-tap-area bottom-right" id="cornerBottomRight" aria-label="Tap to open menu"></div>
    
    <div id="videoContainer">
        <video id="videoInput" autoplay playsinline muted></video>
        <canvas id="canvasOutput"></canvas>
    </div>
    
    <!-- MediaPipe Face Detection (WASM) -->
    <script type="module">
        import { FaceLandmarker, FilesetResolver } from 'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3';
        
        // Production detection: hide console logs in production (not localhost or file://)
        const isDevelopment = (() => {
            const hostname = window.location.hostname;
            const protocol = window.location.protocol;
            // Development if: localhost, 127.0.0.1, file:// protocol, or any IP address (likely local dev)
            return hostname === 'localhost' || 
                   hostname === '127.0.0.1' || 
                   hostname.startsWith('192.168.') ||
                   hostname.startsWith('10.') ||
                   protocol === 'file:';
        })();
        
        // Store original console methods
        const originalConsole = {
            log: console.log.bind(console),
            warn: console.warn.bind(console),
            info: console.info.bind(console),
            error: console.error.bind(console)
        };
        
        // Override console methods to only log in development
        console.log = function(...args) {
            if (isDevelopment) {
                originalConsole.log(...args);
            }
        };
        
        console.warn = function(...args) {
            if (isDevelopment) {
                const message = args.join(' ');
                // Suppress MediaPipe warnings even in development (they're just noise)
                if (message.includes('Face blendshape model contains CPU only ops') ||
                    message.includes('OpenGL error checking is disabled') ||
                    message.includes('Sets FaceBlendshapesGraph acceleration')) {
                    return; // Suppress MediaPipe warnings
                }
                originalConsole.warn(...args);
            }
        };
        
        console.info = function(...args) {
            if (isDevelopment) {
                const message = args.join(' ');
                // Suppress MediaPipe info messages even in development (they're just noise)
                if (message.includes('GL version:') || 
                    message.includes('renderer:') ||
                    message.includes('Graph successfully started') ||
                    message.includes('Created TensorFlow Lite') ||
                    message.includes('XNNPACK delegate')) {
                    return; // Suppress MediaPipe info messages
                }
                originalConsole.info(...args);
            }
        };
        
        // console.error always logs real errors, but we'll filter MediaPipe noise and expected errors
        console.error = function(...args) {
            const message = args.join(' ');
            
            // Suppress MediaPipe internal log messages that come through as errors
            if (message.includes('vision_wasm_internal') || message.includes('installHook.js')) {
                // Suppress MediaPipe/TensorFlow info messages that come through as errors
                if (message.includes('W1207') || message.includes('I1207') || message.includes('I1208') ||
                    message.includes('INFO:') || message.includes('Created TensorFlow') ||
                    message.includes('XNNPACK delegate') || message.includes('GL version:') ||
                    message.includes('renderer:') || message.includes('Graph successfully started')) {
                    return; // Suppress MediaPipe internal log messages
                }
            }
            
            // Suppress expected 404 errors during mask discovery
            if ((message.includes('face_mask') || message.includes('mask_')) && 
                (message.includes('404') || message.includes('Failed to load') || 
                 message.includes('GET') || message.includes('Not Found'))) {
                return; // Suppress expected mask discovery errors
            }
            
            // Log real errors (always, not just in development)
            originalConsole.error(...args);
        };
        
        // Mobile device detection
        function isMobileDevice() {
            // Check user agent for mobile devices
            const userAgent = navigator.userAgent || navigator.vendor || window.opera;
            const mobileRegex = /android|webos|iphone|ipad|ipod|blackberry|iemobile|opera mini/i;
            
            // Also check screen width as a fallback
            const isSmallScreen = window.innerWidth <= 768;
            
            return mobileRegex.test(userAgent) || isSmallScreen;
        }
        
        // Check if device is iPad without keyboard (touch device with large screen)
        function isTabletWithoutKeyboard() {
            // Check if it's a touch device
            const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
            
            // Check if it's iPad (has touch points but might not have keyboard)
            const userAgent = navigator.userAgent || navigator.vendor || window.opera;
            const isIPad = /ipad/i.test(userAgent) || (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
            
            // Check screen size (tablets typically have larger screens)
            const isLargeScreen = window.innerWidth >= 768 && window.innerWidth <= 1024;
            
            return (isTouchDevice && (isIPad || isLargeScreen));
        }
        
        // Check if corner tap areas should be enabled
        function shouldShowCornerTaps() {
            // Allow corner taps on all screen sizes for easy menu access
            return true;
        }
        
        // State
        let faceLandmarker = null;
        let wasmModule = null;
        let localStream = null;
        let testImage = null; // For testing with static images
        let isProcessing = false;
        let currentFilter = '';
        let frameCount = 0;
        let animationFrameId = null;
        let allFilters = [];
        let pinnedFilters = [];
        let controlsVisible = true;
        let isRandomCycling = false;
        let randomCycleInterval = null;
        let faceMaskImages = {}; // Cache for face mask images
        let discoveredFaceMasks = []; // Dynamically discovered face mask names
        let maskProcessingCanvas = null; // Cached canvas for mask processing (reused to reduce allocations)
        let maskProcessingCtx = null; // Cached context
        let offscreenCanvas = null; // OffscreenCanvas for better performance (if supported)
        let offscreenCtx = null; // OffscreenCanvas context
        let lastFrameTime = 0; // Frame rate limiting
        const targetFPS = 60;
        let faceMaskScale = 1.0; // Scale factor for face mask size adjustment
        const frameInterval = 1000 / targetFPS;
        
        // Version and build tracking
        const APP_VERSION = '1.0.0';
        let BUILD_INFO = null; // Will be loaded from build-info.json
        
        // Load build info from build-info.json (generated by build script)
        async function loadBuildInfo() {
            try {
                const response = await fetch('build-info.json?' + Date.now());
                if (response.ok) {
                    BUILD_INFO = await response.json();
                    console.log('Loaded build info:', BUILD_INFO);
                    return BUILD_INFO;
                } else {
                    console.warn('build-info.json not found or not accessible:', response.status, response.statusText);
                }
            } catch (e) {
                console.warn('Could not load build-info.json:', e.message);
            }
            
            // Fallback: use file modification time or current time
            console.warn('Using fallback build info');
            BUILD_INFO = {
                buildNumber: 0,
                buildTimestamp: Date.now(),
                commitHash: 'unknown',
                commitTime: Date.now()
            };
            return BUILD_INFO;
        }
        
        // Get build number from build info
        function getBuildNumber() {
            if (BUILD_INFO) {
                return BUILD_INFO.buildNumber || 0;
            }
            return 0;
        }
        
        // Get build timestamp from build info
        function getBuildTimestamp() {
            if (BUILD_INFO && BUILD_INFO.commitTime) {
                return BUILD_INFO.commitTime;
            }
            if (BUILD_INFO && BUILD_INFO.buildTimestamp) {
                return BUILD_INFO.buildTimestamp;
            }
            return Date.now();
        }
        
        // Format time since last update
        function formatTimeSince(timestamp) {
            const now = Date.now();
            const diff = now - timestamp;
            const seconds = Math.floor(diff / 1000);
            const minutes = Math.floor(seconds / 60);
            const hours = Math.floor(minutes / 60);
            const days = Math.floor(hours / 24);
            const weeks = Math.floor(days / 7);
            const months = Math.floor(days / 30);
            
            if (seconds < 60) {
                return `${seconds} sec${seconds !== 1 ? 's' : ''} ago`;
            } else if (minutes < 60) {
                return `${minutes} min${minutes !== 1 ? 's' : ''} ago`;
            } else if (hours < 24) {
                return `${hours} hr${hours !== 1 ? 's' : ''} ago`;
            } else if (days < 7) {
                return `${days} day${days !== 1 ? 's' : ''} ago`;
            } else if (weeks < 4) {
                return `${weeks} week${weeks !== 1 ? 's' : ''} ago`;
            } else if (months < 12) {
                return `${months} month${months !== 1 ? 's' : ''} ago`;
            } else {
                const years = Math.floor(months / 12);
                return `${years} year${years !== 1 ? 's' : ''} ago`;
            }
        }
        
        // Update version display
        function updateVersionDisplay() {
            const versionEl = document.getElementById('appVersion');
            const buildEl = document.getElementById('appBuild');
            const updateEl = document.getElementById('lastUpdateTime');
            
            if (versionEl) {
                versionEl.textContent = APP_VERSION;
            }
            
            if (buildEl) {
                const buildNum = getBuildNumber();
                buildEl.textContent = buildNum.toString();
            }
            
            if (updateEl) {
                const buildTimestamp = getBuildTimestamp();
                updateEl.textContent = formatTimeSince(buildTimestamp);
            }
        }
        
        // Update time display periodically
        function startTimeUpdateInterval() {
            const updateEl = document.getElementById('lastUpdateTime');
            if (updateEl) {
                setInterval(async () => {
                    // Reload build info to get the latest timestamp
                    await loadBuildInfo();
                    const buildTimestamp = getBuildTimestamp();
                    updateEl.textContent = formatTimeSince(buildTimestamp);
                }, 60000); // Update every minute
            }
        }
        
        // Filter categories (matching original)
        // Face masks will be added dynamically after discovery
        const FILTER_CATEGORIES = {
            'DROPOUT': [],
            'Distortion': ['bulge', 'stretch', 'swirl', 'fisheye', 'pinch', 'wave', 'mirror',
                          'twirl', 'ripple', 'sphere', 'tunnel', 'water_ripple',
                          'radial_blur', 'cylinder', 'barrel', 'pincushion', 'whirlpool', 'radial_zoom',
                          'concave', 'convex', 'spiral', 'radial_stretch', 'radial_compress',
                          'vertical_wave', 'horizontal_wave', 'skew_horizontal', 'skew_vertical',
                          'rotate_zoom', 'radial_wave', 'zoom_in', 'zoom_out', 'fast_zoom_in',
                          'fast_zoom_out', 'shake', 'pulse', 'spiral_zoom', 'extreme_closeup',
                          'puzzle', 'rotate', 'rotate_45', 'rotate_90', 'flip_horizontal',
                          'flip_vertical', 'flip_both', 'quad_mirror', 'tile', 'radial_tile',
                          'zoom_blur', 'melt', 'kaleidoscope', 'glitch', 'double_vision'],
            'Color & Style': ['black_white', 'sepia', 'vintage', 'neon_glow',
                             'pixelate', 'blur', 'sharpen', 'emboss', 'red_tint', 'blue_tint',
                             'green_tint', 'rainbow', 'negative', 'posterize', 'sketch', 'cartoon',
                             'thermal', 'ice', 'ocean', 'plasma', 'jet', 'turbo', 'inferno',
                             'magma', 'viridis', 'cool', 'hot', 'spring', 'summer', 'autumn',
                             'winter', 'rainbow_shift', 'acid_trip', 'vhs', 'retro', 'cyberpunk',
                             'anime', 'glow', 'solarize', 'edge_detect', 'halftone']
        };
        
        // Build flat filter list
        Object.values(FILTER_CATEGORIES).forEach(categoryFilters => {
            allFilters.push(...categoryFilters);
        });
        
        // Elements
        const videoInput = document.getElementById('videoInput');
        const canvasOutput = document.getElementById('canvasOutput');
        const ctx = canvasOutput.getContext('2d', { willReadFrequently: true });
        const cameraSelect = document.getElementById('cameraSelect');
        // Legacy dropdown removed - using modal search instead
        const fxSelectedText = document.getElementById('fxSelectedText');
        const fxCurrentPin = document.getElementById('fxCurrentPin');
        const clearFilterButton = document.getElementById('clearFilterButton');
        const fxOptionsContainer = document.getElementById('fxOptionsContainer');
        const fxSearchInput = document.getElementById('fxSearchInput');
        const fxSearchTrigger = document.getElementById('fxSearchTrigger');
        const fxSearchModal = document.getElementById('fxSearchModal');
        const fxSearchClear = document.getElementById('fxSearchClear');
        const pinnedFxContainer = document.getElementById('pinnedFxContainer');
        const startButton = document.getElementById('startButton');
        const stopButton = document.getElementById('stopButton');
        const statusDiv = document.getElementById('status');
        const cameraStatusText = document.getElementById('cameraStatusText');
        const controls = document.getElementById('controls');
        const themeSelect = document.getElementById('themeSelect');
        const loadingIndicator = document.getElementById('loadingIndicator');
        const testImageInput = document.getElementById('testImageInput');
        const videoContainer = document.getElementById('videoContainer');
        // Legacy dropdown elements (may not exist if using modal search)
        const fxDropdownMenu = document.getElementById('fxDropdownMenu');
        const fxDropdownButton = document.getElementById('fxDropdownButton');
        const clearTestImageButton = document.getElementById('clearTestImageButton');
        
        // Check WASM support
        const wasmSupported = typeof WebAssembly !== 'undefined';
        
        // Format filter name for display
        function formatFilterName(filter) {
            if (!filter) return 'None (Original)';
            return filter.split('_').map(word => 
                word.charAt(0).toUpperCase() + word.slice(1)
            ).join(' ');
        }
        
        // Update status (status widget removed, only update camera status in settings)
        function updateStatus(message, className = '') {
            // Status widget is hidden, but keep function for compatibility
            // Update camera status text in settings section
            if (cameraStatusText) {
                if (className === 'connected' && message.includes('Camera')) {
                    cameraStatusText.textContent = 'Camera: Active';
                    cameraStatusText.parentElement.className = 'camera-status connected';
                } else if (message.includes('Camera stopped') || message.includes('Stopped')) {
                    cameraStatusText.textContent = 'Camera: Stopped';
                    cameraStatusText.parentElement.className = 'camera-status stopped';
                } else if (className === 'error' && message.includes('Camera')) {
                    cameraStatusText.textContent = 'Camera: Error';
                    cameraStatusText.parentElement.className = 'camera-status error';
                }
            }
        }
        
        // Initialize MediaPipe Face Landmarker
        async function initFaceDetection() {
            try {
                // Console suppression is handled globally at the top of the script
                const vision = await FilesetResolver.forVisionTasks(
                    "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm"
                );
                
                faceLandmarker = await FaceLandmarker.createFromOptions(vision, {
                    baseOptions: {
                        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task`,
                        delegate: "GPU"
                    },
                    outputFaceBlendshapes: false,
                    runningMode: "VIDEO",
                    numFaces: 1
                });
                
                console.log('MediaPipe Face Landmarker initialized');
                return true;
            } catch (error) {
                console.error('Failed to initialize MediaPipe:', error);
                return false;
            }
        }
        
        // Initialize WASM module (placeholder - will load actual module when built)
        async function initWasm() {
            if (!wasmSupported) {
                console.warn('WebAssembly not supported. Using JavaScript filters.');
                return false;
            }
            
            try {
                // TODO: Load actual WASM module when built
                // const wwfx = new WWFXWasm();
                // await wwfx.init('wasm/wwfx_module.wasm');
                // wasmModule = wwfx;
                
                console.log('WASM module placeholder (using JS filters)');
                return true;
            } catch (error) {
                console.error('Failed to load WASM module:', error);
                return false;
            }
        }
        
        // Track current camera facing mode for mobile toggle
        let currentFacingMode = 'user'; // 'user' = front, 'environment' = back
        let hasFrontCamera = false;
        let hasBackCamera = false;
        
        // Load cameras
        async function loadCameras() {
            try {
                // Request permission first to get camera labels on mobile
                try {
                    await navigator.mediaDevices.getUserMedia({ video: true });
                } catch (e) {
                    // Permission denied or not available, continue anyway
                }
                
                const devices = await navigator.mediaDevices.enumerateDevices();
                const videoDevices = devices.filter(device => device.kind === 'videoinput');
                
                cameraSelect.innerHTML = '';
                
                // Detect front and back cameras on mobile
                hasFrontCamera = false;
                hasBackCamera = false;
                
                videoDevices.forEach(device => {
                    const option = document.createElement('option');
                    option.value = device.deviceId;
                    const label = device.label || `Camera ${cameraSelect.options.length + 1}`;
                    option.textContent = label;
                    cameraSelect.appendChild(option);
                    
                    // Check if this is a front or back camera based on label
                    const labelLower = label.toLowerCase();
                    if (labelLower.includes('front') || labelLower.includes('user') || labelLower.includes('face')) {
                        hasFrontCamera = true;
                    }
                    if (labelLower.includes('back') || labelLower.includes('rear') || labelLower.includes('environment')) {
                        hasBackCamera = true;
                    }
                });
                
                // Also check if we can detect by trying constraints (for mobile)
                if (isMobileDevice() && videoDevices.length >= 2) {
                    // If we have 2+ cameras on mobile, assume we have both front and back
                    hasFrontCamera = true;
                    hasBackCamera = true;
                }
                
                // Load saved camera
                const savedCamera = localStorage.getItem('wesworld-fx-camera');
                if (savedCamera) {
                    cameraSelect.value = savedCamera;
                }
            } catch (error) {
                console.error('Error loading cameras:', error);
            }
        }
        
        // Toggle between front and back camera
        async function toggleCamera() {
            if (!localStream) {
                return; // Can't toggle if camera isn't running
            }
            
            // Switch facing mode
            currentFacingMode = currentFacingMode === 'user' ? 'environment' : 'user';
            
            // Stop current stream and cancel animation frame
            localStream.getTracks().forEach(track => track.stop());
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
            
            // Start new stream with new facing mode
            try {
                const constraints = {
                    video: {
                        facingMode: currentFacingMode,
                        width: { ideal: 1280 },
                        height: { ideal: 720 }
                    }
                };
                
                localStream = await navigator.mediaDevices.getUserMedia(constraints);
                
                // Ensure video element has required attributes
                videoInput.setAttribute('autoplay', '');
                videoInput.setAttribute('playsinline', '');
                videoInput.setAttribute('muted', '');
                
                videoInput.srcObject = localStream;
                
                // Force play on mobile with retries
                let playAttempts = 0;
                const maxPlayAttempts = 5;
                const tryPlay = async () => {
                    try {
                        await videoInput.play();
                        console.log('Video play successful after toggle');
                    } catch (playError) {
                        playAttempts++;
                        if (playAttempts < maxPlayAttempts) {
                            console.warn(`Video play() attempt ${playAttempts} failed after toggle, retrying:`, playError);
                            setTimeout(tryPlay, 100 * playAttempts);
                        } else {
                            console.warn('Video play() failed after toggle after max attempts:', playError);
                        }
                    }
                };
                await tryPlay();
                
                // Wait for video to be ready and restart processing
                let isInitialized = false;
                const initializeAfterToggle = () => {
                    if (isInitialized) return;
                    
                    if (videoInput.readyState >= 2 && videoInput.videoWidth > 0 && videoInput.videoHeight > 0) {
                        isInitialized = true;
                        
                        canvasOutput.width = videoInput.videoWidth;
                        canvasOutput.height = videoInput.videoHeight;
                        
                        // Ensure video is playing
                        if (videoInput.paused) {
                            videoInput.play().catch(err => console.warn('Play failed in initializeAfterToggle:', err));
                        }
                        
                        // Start processing loop
                        if (!animationFrameId) {
                            processVideoFrame();
                        }
                    }
                };
                
                // Handle video ready events
                videoInput.onloadedmetadata = () => {
                    console.log('Video metadata loaded after toggle');
                    initializeAfterToggle();
                };
                
                videoInput.addEventListener('loadeddata', () => {
                    console.log('Video data loaded after toggle');
                    initializeAfterToggle();
                }, { once: true });
                
                videoInput.addEventListener('canplay', () => {
                    console.log('Video can play after toggle');
                    initializeAfterToggle();
                }, { once: true });
                
                // Fallback: check periodically
                let checkCount = 0;
                const maxChecks = 30;
                const checkInterval = setInterval(() => {
                    checkCount++;
                    if (isInitialized) {
                        clearInterval(checkInterval);
                    } else if (checkCount >= maxChecks) {
                        clearInterval(checkInterval);
                        if (!isInitialized && videoInput.readyState >= 1) {
                            console.warn('Forcing video initialization after toggle timeout');
                            canvasOutput.width = videoInput.videoWidth || 640;
                            canvasOutput.height = videoInput.videoHeight || 480;
                            isInitialized = true;
                            if (!animationFrameId) {
                                processVideoFrame();
                            }
                        }
                    } else {
                        initializeAfterToggle();
                    }
                }, 100);
                
                // Save preference
                localStorage.setItem('wesworld-fx-camera-facing', currentFacingMode);
            } catch (error) {
                console.error('Error toggling camera:', error);
                updateStatus('Camera toggle error: ' + error.message, 'error');
                // Revert facing mode on error
                currentFacingMode = currentFacingMode === 'user' ? 'environment' : 'user';
            }
        }
        
        // Load pinned filters
        function loadPinnedFilters() {
            try {
                const saved = localStorage.getItem('wesworld-fx-pinned');
                if (saved) {
                    pinnedFilters = JSON.parse(saved);
                } else {
                    pinnedFilters = [];
                }
                updatePinnedFxDisplay();
            } catch (error) {
                console.error('Error loading pinned filters:', error);
                pinnedFilters = [];
            }
        }
        
        // Save pinned filters
        function savePinnedFilters() {
            try {
                localStorage.setItem('wesworld-fx-pinned', JSON.stringify(pinnedFilters));
            } catch (error) {
                console.error('Error saving pinned filters:', error);
            }
        }
        
        // Update pinned FX display
        function updatePinnedFxDisplay() {
            pinnedFxContainer.innerHTML = '';
            
            if (pinnedFilters.length === 0) {
                return;
            }
            
            pinnedFilters.forEach(filterName => {
                const item = document.createElement('div');
                item.className = 'pinned-fx-item';
                item.dataset.filterName = filterName;
                // Make entire item clickable to load filter
                item.onclick = () => selectFilter(filterName);
                
                const text = document.createElement('span');
                text.className = 'pinned-fx-item-text';
                text.textContent = formatFilterName(filterName);
                
                const remove = document.createElement('span');
                remove.className = 'pinned-fx-item-remove';
                remove.textContent = '√ó';
                remove.onclick = (e) => {
                    e.stopPropagation();
                    unpinFilter(filterName);
                };
                
                item.appendChild(text);
                item.appendChild(remove);
                pinnedFxContainer.appendChild(item);
            });
        }
        
        // Pin current filter
        function pinCurrentFilter() {
            if (currentFilter && !pinnedFilters.includes(currentFilter)) {
                pinnedFilters.unshift(currentFilter);
                savePinnedFilters();
                updatePinnedFxDisplay();
                updateCurrentPinIcon();
                loadFilters();
            }
        }
        
        // Unpin filter
        function unpinFilter(filterName) {
            pinnedFilters = pinnedFilters.filter(f => f !== filterName);
            savePinnedFilters();
            updatePinnedFxDisplay();
            if (currentFilter === filterName) {
                updateCurrentPinIcon();
            }
            loadFilters();
        }
        
        // Update current pin icon
        function updateCurrentPinIcon() {
            if (!currentFilter) {
                fxCurrentPin.style.display = 'none';
                return;
            }
            
            fxCurrentPin.style.display = 'flex';
            const isPinned = pinnedFilters.includes(currentFilter);
            fxCurrentPin.innerHTML = isPinned ? 'üìå' : 'üìç';
            fxCurrentPin.title = isPinned ? 'Unpin current FX' : 'Pin current FX';
        }
        
        // Load filters
        function loadFilters() {
            fxOptionsContainer.innerHTML = '';
            
            // Add "None" option
            const noneOption = document.createElement('button');
            noneOption.className = 'fx-option' + (currentFilter === '' ? ' selected' : '');
            noneOption.textContent = 'None (Original)';
            noneOption.value = '';
            const handleNoneClick = (e) => {
                e.preventDefault();
                e.stopPropagation();
                selectFilter('');
                closeFxSearchModal();
            };
            noneOption.onclick = handleNoneClick;
            // Also handle touch events for mobile
            noneOption.addEventListener('touchend', (e) => {
                e.preventDefault();
                e.stopPropagation();
                handleNoneClick(e);
            }, { passive: false });
            fxOptionsContainer.appendChild(noneOption);
            
            // Add filters by category
            Object.entries(FILTER_CATEGORIES).forEach(([category, filters]) => {
                const group = document.createElement('div');
                group.className = 'fx-group';
                
                const groupTitle = document.createElement('div');
                groupTitle.className = 'fx-group-title';
                groupTitle.textContent = category;
                group.appendChild(groupTitle);
                
                filters.forEach(filter => {
                    // Skip if pinned (shown in pinned section)
                    if (pinnedFilters.includes(filter)) return;
                    
                    const option = createFxOption(filter);
                    group.appendChild(option);
                });
                
                if (group.children.length > 1) { // Has title + at least one option
                    fxOptionsContainer.appendChild(group);
                }
            });
        }
        
        // Create FX option
        function createFxOption(filter) {
            const option = document.createElement('button');
            option.className = 'fx-option' + (currentFilter === filter ? ' selected' : '');
            option.value = filter;
            option.type = 'button'; // Prevent form submission
            option.setAttribute('role', 'option');
            option.setAttribute('aria-selected', currentFilter === filter ? 'true' : 'false');
            option.setAttribute('aria-label', `Apply filter: ${formatFilterName(filter)}`);
            option.setAttribute('tabindex', '0');
            
            if (filter.includes('face_mask')) {
                const optionText = document.createElement('span');
                optionText.className = 'fx-option-text';
                optionText.textContent = formatFilterName(filter);
                
                const optionImage = document.createElement('img');
                optionImage.className = 'fx-option-image';
                const parts = filter.split('_');
                const optionName = parts[parts.length - 1];
                if (filter.startsWith('dropout_')) {
                    // Use mask_<name>.png pattern for dropout face masks
                    optionImage.src = `assets/dropout/face_mask/mask_${optionName}.png`;
                }
                optionImage.alt = formatFilterName(filter);
                optionImage.setAttribute('aria-hidden', 'true'); // Decorative image
                optionImage.onerror = function() {
                    this.style.display = 'none';
                };
                
                option.appendChild(optionImage);
                option.appendChild(optionText);
            } else {
                const optionText = document.createElement('span');
                optionText.className = 'fx-option-text';
                optionText.textContent = formatFilterName(filter);
                option.appendChild(optionText);
            }
            
            if (filter) {
                const pinIcon = document.createElement('button');
                pinIcon.className = 'fx-option-pin';
                pinIcon.type = 'button';
                pinIcon.setAttribute('aria-label', pinnedFilters.includes(filter) ? 'Unpin filter' : 'Pin filter');
                pinIcon.innerHTML = pinnedFilters.includes(filter) ? 'üìå' : 'üìç';
                pinIcon.title = pinnedFilters.includes(filter) ? 'Unpin' : 'Pin';
                pinIcon.setAttribute('tabindex', '0');
                const handlePinClick = (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    if (pinnedFilters.includes(filter)) {
                        unpinFilter(filter);
                    } else {
                        if (!pinnedFilters.includes(filter)) {
                            pinnedFilters.unshift(filter);
                            savePinnedFilters();
                            updatePinnedFxDisplay();
                            loadFilters();
                        }
                    }
                };
                
                pinIcon.onclick = handlePinClick;
                // Also handle touch events for mobile
                pinIcon.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    handlePinClick(e);
                }, { passive: false });
                
                // Keyboard support for pin button
                pinIcon.onkeydown = (e) => {
                    if (e.key === 'Enter' || e.key === ' ') {
                        e.preventDefault();
                        e.stopPropagation();
                        handlePinClick(e);
                    }
                };
                option.appendChild(pinIcon);
            }
            
            // Handle both click and touch events for better mobile/desktop support
            const handleOptionClick = (e) => {
                e.preventDefault();
                e.stopPropagation();
                selectFilter(filter);
                closeFxSearchModal();
            };
            
            option.onclick = handleOptionClick;
            
            // Longpress detection for mobile to open search modal
            let touchStartTime = 0;
            let longPressTimer = null;
            let longPressDetected = false;
            const LONG_PRESS_DURATION = 500; // 500ms for longpress
            
            option.addEventListener('touchstart', (e) => {
                touchStartTime = Date.now();
                longPressDetected = false;
                longPressTimer = setTimeout(() => {
                    // Longpress detected - open search modal instead
                    longPressDetected = true;
                    openFxSearchModal();
                    // Focus the search input
                    setTimeout(() => {
                        if (fxSearchInput) {
                            fxSearchInput.focus();
                        }
                    }, 100);
                }, LONG_PRESS_DURATION);
            }, { passive: true });
            
            // Also handle touch events explicitly for mobile
            option.addEventListener('touchend', (e) => {
                // Clear the longpress timer
                if (longPressTimer) {
                    clearTimeout(longPressTimer);
                    longPressTimer = null;
                }
                
                // Only handle as normal click if it wasn't a longpress
                if (!longPressDetected) {
                    e.preventDefault();
                    e.stopPropagation();
                    handleOptionClick(e);
                } else {
                    // Reset the flag for next interaction
                    longPressDetected = false;
                }
            }, { passive: false });
            
            option.addEventListener('touchcancel', () => {
                // Clear timer if touch is cancelled
                if (longPressTimer) {
                    clearTimeout(longPressTimer);
                    longPressTimer = null;
                }
                longPressDetected = false;
            }, { passive: true });
            
            // Keyboard support
            option.onkeydown = (e) => {
                if (e.key === 'Enter' || e.key === ' ') {
                    e.preventDefault();
                    handleOptionClick(e);
                } else if (e.key === 'ArrowDown') {
                    e.preventDefault();
                    const next = option.nextElementSibling?.querySelector('.fx-option') || 
                                 option.closest('.fx-group')?.nextElementSibling?.querySelector('.fx-option');
                    if (next) next.focus();
                } else if (e.key === 'ArrowUp') {
                    e.preventDefault();
                    const prev = option.previousElementSibling || 
                                option.closest('.fx-group')?.previousElementSibling?.querySelectorAll('.fx-option');
                    if (prev && prev.length > 0) prev[prev.length - 1].focus();
                }
            };
            
            return option;
        }
        
        // Update clear button visibility
        function updateClearButtonVisibility() {
            if (fxSearchClear && fxSearchInput) {
                if (fxSearchInput.value.trim()) {
                    fxSearchClear.classList.add('visible');
                } else {
                    fxSearchClear.classList.remove('visible');
                }
            }
        }
        
        // Store element that had focus before modal opened (for focus trap)
        let previousActiveElement = null;
        
        // Open FX search modal
        function openFxSearchModal() {
            console.log('openFxSearchModal called', { fxSearchModal, fxSearchInput });
            if (fxSearchModal) {
                // Store current focus for restoration
                previousActiveElement = document.activeElement;
                
                // Update ARIA attributes
                fxSearchModal.setAttribute('aria-hidden', 'false');
                fxSearchModal.classList.add('active');
                // Force display style to ensure it shows
                fxSearchModal.style.display = 'flex';
                
                // Prevent body scroll when modal is open
                document.body.style.overflow = 'hidden';
                
                console.log('Modal class added, active:', fxSearchModal.classList.contains('active'));
                console.log('Modal style display:', fxSearchModal.style.display);
                
                // Load filters if not already loaded
                if (fxOptionsContainer && fxOptionsContainer.children.length === 0) {
                    loadFilters();
                }
                
                // Focus search input after modal opens (accessibility best practice)
                setTimeout(() => {
                    if (fxSearchInput) {
                        fxSearchInput.focus();
                        console.log('Search input focused');
                        // Update clear button visibility
                        if (fxSearchClear) {
                            updateClearButtonVisibility();
                        }
                        // Update aria-expanded
                        fxSearchInput.setAttribute('aria-expanded', 'true');
                    }
                }, 100);
            } else {
                console.error('fxSearchModal element not found!');
            }
        }
        
        // Close FX search modal
        function closeFxSearchModal() {
            if (fxSearchModal) {
                // Update ARIA attributes
                fxSearchModal.setAttribute('aria-hidden', 'true');
                fxSearchModal.classList.remove('active');
                fxSearchModal.style.display = 'none';
                
                // Restore body scroll
                document.body.style.overflow = '';
                
                // Clear search
                if (fxSearchInput) {
                    fxSearchInput.value = '';
                    filterFxOptions('');
                    fxSearchInput.setAttribute('aria-expanded', 'false');
                }
                
                // Restore focus to previous element (accessibility)
                if (previousActiveElement && typeof previousActiveElement.focus === 'function') {
                    try {
                        previousActiveElement.focus();
                    } catch (e) {
                        // Fallback if element is no longer focusable
                        console.warn('Could not restore focus to previous element');
                    }
                }
                previousActiveElement = null;
            }
        }
        
        // Update face mask zoom display
        function updateFaceMaskZoomDisplay() {
            const display = document.getElementById('faceMaskZoomDisplay');
            if (display) {
                const percentage = Math.round(faceMaskScale * 100);
                display.textContent = `${percentage}%`;
            }
        }
        
        // Adjust face mask size with keyboard controls
        function adjustFaceMaskSize(delta) {
            faceMaskScale = Math.max(0.5, Math.min(2.0, faceMaskScale + delta));
            try {
                localStorage.setItem('wesworld-fx-face-mask-scale', faceMaskScale.toString());
                console.log('Face mask scale adjusted to:', faceMaskScale.toFixed(2));
                updateFaceMaskZoomDisplay();
            } catch (error) {
                console.error('Error saving face mask scale to localStorage:', error);
            }
        }
        
        // Reset face mask size to default
        function resetFaceMaskSize() {
            faceMaskScale = 1.0;
            try {
                localStorage.setItem('wesworld-fx-face-mask-scale', '1.0');
                console.log('Face mask scale reset to default');
                updateFaceMaskZoomDisplay();
            } catch (error) {
                console.error('Error saving face mask scale to localStorage:', error);
            }
        }
        
        // Discover face mask files dynamically
        // This function attempts to discover available face mask PNG files
        // Expected naming convention: mask_<mask name>.png (e.g., mask_sam.png)
        // Since browser WASM cannot directly access the file system, we use JavaScript to discover files
        let directoryListingAttempted = false;
        async function discoverFaceMasks() {
            // If masks already discovered, don't rediscover
            if (discoveredFaceMasks.length > 0) {
                return discoveredFaceMasks;
            }
            
            console.log('Discovering face mask files (looking for mask_*.png pattern)...');
            discoveredFaceMasks = [];
            const basePath = 'assets/dropout/face_mask/';
            
            // First, try to discover from a directory listing if available (for server environments)
            // This is the most reliable method and doesn't require hardcoded names
            // Only try once to avoid duplicate 404 errors
            if (window.location.protocol !== 'file:' && !directoryListingAttempted) {
                directoryListingAttempted = true;
                try {
                    // Try to fetch directory listing (some servers support this)
                    // Note: Most servers don't support directory listings, so 404 is expected
                    const response = await fetch(basePath).catch(() => null);
                    
                    if (response && response.ok && response.status !== 404) {
                        const text = await response.text();
                        // Parse HTML directory listing for .png files matching mask_*.png pattern
                        const parser = new DOMParser();
                        const doc = parser.parseFromString(text, 'text/html');
                        const links = doc.querySelectorAll('a[href$=".png"]');
                        links.forEach(link => {
                            const fileName = link.getAttribute('href');
                            // Look for files matching mask_<name>.png pattern
                            if (fileName && fileName.startsWith('mask_') && fileName.endsWith('.png')) {
                                const maskName = fileName.replace('mask_', '').replace('.png', '');
                                if (maskName && !discoveredFaceMasks.includes(maskName)) {
                                    discoveredFaceMasks.push(maskName);
                                    console.log('Discovered face mask from directory listing:', maskName);
                                }
                            }
                        });
                    }
                    // Silently ignore 404s - they're expected when directory listing isn't supported
                } catch (error) {
                    // Directory listing not available (404 is expected on most servers)
                    // Silently continue to fallback method - don't log errors
                }
            }
            
            // Fallback: For file:// protocol or when directory listing fails,
            // try to discover by attempting to load files matching mask_*.png pattern
            // We'll try a reasonable range of potential mask names
            if (discoveredFaceMasks.length === 0) {
                console.log('Using fallback discovery method (trying mask_*.png pattern)...');
                
                // Common potential mask names to try (can be extended)
                // These are just common names - the system will discover any mask_*.png file
                const potentialNames = [
                    'sam'
                ];
                
                // Error suppression is handled globally - 404s during discovery are expected
                const discoveryPromises = potentialNames.map(async (maskName) => {
                    const assetPath = `${basePath}mask_${maskName}.png`;
                    
                    return new Promise((resolve) => {
                        const img = new Image();
                        
                        // For file:// protocol, don't set crossOrigin
                        if (window.location.protocol !== 'file:') {
                            img.crossOrigin = 'anonymous';
                        }
                        
                        img.onload = () => {
                            console.log('Discovered face mask:', maskName);
                            if (!discoveredFaceMasks.includes(maskName)) {
                                discoveredFaceMasks.push(maskName);
                            }
                            // Preload the image
                            faceMaskImages[assetPath] = img;
                            resolve({ name: maskName, found: true });
                        };
                        
                        img.onerror = () => {
                            // Mask not found, continue silently (404s are expected during discovery)
                            resolve({ name: maskName, found: false });
                        };
                        
                        img.src = assetPath;
                    });
                });
                
                await Promise.all(discoveryPromises);
            }
            
            console.log('Face mask discovery complete. Found:', discoveredFaceMasks);
            
            // Add discovered masks to filter categories
            if (discoveredFaceMasks.length > 0 && FILTER_CATEGORIES['DROPOUT']) {
                // Remove any existing face mask entries
                FILTER_CATEGORIES['DROPOUT'] = FILTER_CATEGORIES['DROPOUT'].filter(
                    f => !f.includes('face_mask')
                );
                
                // Add discovered masks
                discoveredFaceMasks.forEach(maskName => {
                    FILTER_CATEGORIES['DROPOUT'].push(`dropout_face_mask_${maskName}`);
                });
                
                // Rebuild allFilters array
                allFilters = [];
                Object.values(FILTER_CATEGORIES).forEach(categoryFilters => {
                    allFilters.push(...categoryFilters);
                });
                
                console.log('Updated filter categories with discovered masks');
            }
            
            return discoveredFaceMasks;
        }
        
        // Preload face mask images
        async function preloadFaceMasks() {
            // Masks should already be discovered, but ensure they are
            if (discoveredFaceMasks.length === 0) {
                await discoverFaceMasks();
            }
            
            console.log('Preloading face mask images...');
            
            // Preload all discovered masks (using mask_<name>.png pattern)
            for (const maskName of discoveredFaceMasks) {
                const assetPath = `assets/dropout/face_mask/mask_${maskName}.png`;
                if (!faceMaskImages[assetPath]) {
                    try {
                        const img = new Image();
                        
                        // For file:// protocol, don't set crossOrigin
                        if (window.location.protocol !== 'file:') {
                            img.crossOrigin = 'anonymous';
                        }
                        
                        await new Promise((resolve) => {
                            img.onload = () => {
                                console.log('Preloaded face mask:', assetPath);
                                faceMaskImages[assetPath] = img;
                                resolve();
                            };
                            img.onerror = (err) => {
                                // For file:// protocol, this is expected - images will load on-demand
                                if (window.location.protocol === 'file:') {
                                    console.log('Face mask will load on-demand (file:// protocol):', assetPath);
                                } else {
                                    console.warn('Failed to preload face mask:', assetPath);
                                }
                                resolve(); // Don't reject, just continue - will try to load on-demand
                            };
                            img.src = assetPath;
                        });
                    } catch (error) {
                        // Silently handle errors - will try to load on-demand
                        if (window.location.protocol !== 'file:') {
                            console.warn('Error preloading face mask:', assetPath, error);
                        }
                    }
                }
            }
            console.log('Face mask preloading complete');
        }
        
        // Track if we've already warned about tainted canvas (to avoid spam)
        let taintedCanvasWarned = false;
        
        // Apply face mask to canvas with eye alignment
        function applyFaceMask(ctx, faceRect, faceLandmarks, filterName) {
            // Extract mask name from filter (e.g., dropout_face_mask_<name> -> <name>)
            const parts = filterName.split('_');
            const maskName = parts[parts.length - 1];
            
            // Determine asset path (using mask_<name>.png pattern for dropout masks)
            let assetPath = '';
            if (filterName.startsWith('dropout_')) {
                assetPath = `assets/dropout/face_mask/mask_${maskName}.png`;
            } else if (filterName.startsWith('assets_')) {
                assetPath = `assets/face_mask/${maskName}.png`;
            }
            
            if (!assetPath) {
                return;
            }
            
            // Get cached image (should be preloaded)
            let img = faceMaskImages[assetPath];
            
            // If image not loaded yet, try to load it synchronously (for file:// protocol)
            if (!img || !img.complete || !img.naturalWidth || !img.naturalHeight) {
                // Try to load the image if we're on file:// protocol
                if (window.location.protocol === 'file:') {
                    try {
                        const newImg = new Image();
                        newImg.src = assetPath;
                        if (newImg.complete && newImg.naturalWidth > 0) {
                            img = newImg;
                            faceMaskImages[assetPath] = newImg;
                        } else {
                            // Image not ready, skip this frame
                            return;
                        }
                    } catch (e) {
                        return;
                    }
                } else {
                    // Image not ready yet, skip this frame
                    return;
                }
            }
            
            // Save context state
            ctx.save();
            
            // Calculate eye positions from MediaPipe landmarks
            // MediaPipe Face Landmarker provides 468 landmarks
            // Left eye landmarks: 33, 7, 163, 144, 145, 153, 154, 155, 133, 173, 157, 158, 159, 160, 161, 246
            // Right eye landmarks: 362, 382, 381, 380, 374, 373, 390, 249, 263, 466, 388, 387, 386, 385, 384, 398
            let leftEyeX = 0, leftEyeY = 0, rightEyeX = 0, rightEyeY = 0;
            let leftEyeCount = 0, rightEyeCount = 0;
            
            if (faceLandmarks && faceLandmarks.length >= 468) {
                // Left eye key points
                const leftEyeIndices = [33, 7, 163, 144, 145, 153, 154, 155, 133, 173, 157, 158, 159, 160, 161, 246];
                // Right eye key points
                const rightEyeIndices = [362, 382, 381, 380, 374, 373, 390, 249, 263, 466, 388, 387, 386, 385, 384, 398];
                
                for (const idx of leftEyeIndices) {
                    if (faceLandmarks[idx]) {
                        leftEyeX += faceLandmarks[idx].x * canvasOutput.width;
                        leftEyeY += faceLandmarks[idx].y * canvasOutput.height;
                        leftEyeCount++;
                    }
                }
                
                for (const idx of rightEyeIndices) {
                    if (faceLandmarks[idx]) {
                        rightEyeX += faceLandmarks[idx].x * canvasOutput.width;
                        rightEyeY += faceLandmarks[idx].y * canvasOutput.height;
                        rightEyeCount++;
                    }
                }
                
                if (leftEyeCount > 0 && rightEyeCount > 0) {
                    leftEyeX /= leftEyeCount;
                    leftEyeY /= leftEyeCount;
                    rightEyeX /= rightEyeCount;
                    rightEyeY /= rightEyeCount;
                } else {
                    // Fallback to bounding box center if eye detection fails
                    leftEyeX = faceRect.x + faceRect.width * 0.35;
                    leftEyeY = faceRect.y + faceRect.height * 0.4;
                    rightEyeX = faceRect.x + faceRect.width * 0.65;
                    rightEyeY = faceRect.y + faceRect.height * 0.4;
                }
            } else {
                // Fallback to bounding box if no landmarks
                leftEyeX = faceRect.x + faceRect.width * 0.35;
                leftEyeY = faceRect.y + faceRect.height * 0.4;
                rightEyeX = faceRect.x + faceRect.width * 0.65;
                rightEyeY = faceRect.y + faceRect.height * 0.4;
            }
            
            // Calculate eye center and eye distance
            const eyeCenterX = (leftEyeX + rightEyeX) / 2;
            const eyeCenterY = (leftEyeY + rightEyeY) / 2;
            const eyeDistance = Math.sqrt(
                Math.pow(rightEyeX - leftEyeX, 2) + 
                Math.pow(rightEyeY - leftEyeY, 2)
            );
            
            // Calculate rotation angle from eye positions (in radians)
            // atan2 gives angle from horizontal, converting to degrees for rotation
            const rotationAngle = Math.atan2(rightEyeY - leftEyeY, rightEyeX - leftEyeX) * (180 / Math.PI);
            
            // Get additional facial landmarks for dynamic sizing
            let noseX = 0, noseY = 0, chinX = 0, chinY = 0, foreheadX = 0, foreheadY = 0;
            let hasLandmarks = false;
            
            if (faceLandmarks && faceLandmarks.length >= 468) {
                // MediaPipe landmark indices:
                // Nose tip: 1, 2
                // Chin: 175, 199
                // Forehead center: 10
                const noseTip = faceLandmarks[1] || faceLandmarks[2];
                const chin = faceLandmarks[175] || faceLandmarks[199];
                const forehead = faceLandmarks[10];
                
                if (noseTip && chin && forehead) {
                    noseX = noseTip.x * canvasOutput.width;
                    noseY = noseTip.y * canvasOutput.height;
                    chinX = chin.x * canvasOutput.width;
                    chinY = chin.y * canvasOutput.height;
                    foreheadX = forehead.x * canvasOutput.width;
                    foreheadY = forehead.y * canvasOutput.height;
                    hasLandmarks = true;
                }
            }
            
            // Dynamic mask sizing based on face measurements (matching Python implementation)
            const maskAspectRatio = img.naturalWidth / img.naturalHeight;
            let drawW, drawH;
            
            if (hasLandmarks && eyeDistance > 0) {
                // Use landmarks for precise dynamic sizing
                // Calculate face width from eye distance (most stable measurement)
                const faceWidth = eyeDistance * 4.5; // Increased for better coverage
                
                // Calculate face height from nose to chin and forehead to nose
                const noseToChin = Math.sqrt(
                    Math.pow(chinX - noseX, 2) + 
                    Math.pow(chinY - noseY, 2)
                );
                const foreheadToNose = Math.sqrt(
                    Math.pow(noseX - foreheadX, 2) + 
                    Math.pow(noseY - foreheadY, 2)
                );
                const totalFaceHeight = noseToChin + foreheadToNose;
                
                // Make mask taller to ensure full face coverage
                const maskHeight = totalFaceHeight * 1.35; // 35% larger for better coverage
                
                // Calculate width from height to maintain aspect ratio
                const maskWidthFromHeight = maskHeight * maskAspectRatio;
                
                // Use the larger of eye-based width or height-based width
                drawW = Math.max(faceWidth, maskWidthFromHeight);
                drawH = drawW / maskAspectRatio;
                
                // Recalculate height if aspect ratio makes it too different
                if (Math.abs(drawH - maskHeight) > maskHeight * 0.2) {
                    drawH = maskHeight;
                    drawW = drawH * maskAspectRatio;
                }
            } else {
                // Fallback to bounding box method with dynamic scaling
                // Scale based on face size - larger faces get proportionally larger masks
                const baseFaceSize = 200; // Base face size for reference
                const currentFaceSize = Math.max(faceRect.width, faceRect.height);
                const sizeRatio = currentFaceSize / baseFaceSize;
                
                // Dynamic scale factor: 1.4x for small faces, 1.8x for large faces
                const dynamicScale = 1.4 + (sizeRatio * 0.4);
                
                drawW = faceRect.width * dynamicScale;
                drawH = faceRect.height * dynamicScale;
                
                // Maintain mask aspect ratio
                if (maskAspectRatio > (drawW / drawH)) {
                    drawH = drawW / maskAspectRatio;
                } else {
                    drawW = drawH * maskAspectRatio;
                }
            }
            
            // Apply user-adjustable scale factor
            drawW *= faceMaskScale;
            drawH *= faceMaskScale;
            
            // Position mask: center horizontally on eye center
            const drawX = eyeCenterX - drawW / 2;
            
            // Position vertically so eyes align - place eye center at ~35% from top of mask
            // Adjust upward by 40 pixels to better align eyes (matching Python implementation)
            const drawY = eyeCenterY - drawH * 0.35 - 40;
            
            // Professional compositing: Advanced blending with edge feathering and color matching
            // Optimized with canvas caching and OffscreenCanvas support
            try {
                // Use cached canvas or create new one (reduces allocations)
                const maskW = Math.ceil(drawW);
                const maskH = Math.ceil(drawH);
                
                // Calculate rotated mask dimensions to ensure full coverage
                const absAngle = Math.abs(rotationAngle);
                const angleRad = absAngle * Math.PI / 180;
                const rotatedW = Math.ceil(maskW * Math.abs(Math.cos(angleRad)) + maskH * Math.abs(Math.sin(angleRad)));
                const rotatedH = Math.ceil(maskW * Math.abs(Math.sin(angleRad)) + maskH * Math.abs(Math.cos(angleRad)));
                
                let maskCanvas, maskCtx;
                // Use larger canvas to accommodate rotation
                const canvasW = Math.max(maskW, rotatedW);
                const canvasH = Math.max(maskH, rotatedH);
                
                if (maskProcessingCanvas && maskProcessingCanvas.width >= canvasW && maskProcessingCanvas.height >= canvasH) {
                    // Reuse cached canvas (faster, no allocation)
                    maskCanvas = maskProcessingCanvas;
                    maskCtx = maskProcessingCtx;
                } else {
                    // Create or resize canvas
                    if (!maskProcessingCanvas) {
                        maskProcessingCanvas = document.createElement('canvas');
                        maskProcessingCtx = maskProcessingCanvas.getContext('2d', { willReadFrequently: true });
                    }
                    maskProcessingCanvas.width = canvasW;
                    maskProcessingCanvas.height = canvasH;
                    maskCanvas = maskProcessingCanvas;
                    maskCtx = maskProcessingCtx;
                }
                
                // Clear canvas and apply rotation
                maskCtx.clearRect(0, 0, canvasW, canvasH);
                maskCtx.save();
                
                // Translate to center of mask, rotate, then translate back
                const maskCenterX = canvasW / 2;
                const maskCenterY = canvasH / 2;
                maskCtx.translate(maskCenterX, maskCenterY);
                maskCtx.rotate(rotationAngle * Math.PI / 180);
                maskCtx.translate(-maskCenterX, -maskCenterY);
                
                // Draw mask centered on canvas
                const maskDrawX = (canvasW - maskW) / 2;
                const maskDrawY = (canvasH - maskH) / 2;
                maskCtx.drawImage(img, maskDrawX, maskDrawY, maskW, maskH);
                maskCtx.restore();
                
                // Extract alpha channel from rotated mask
                // Wrap in try-catch to handle tainted canvas (cross-origin images)
                let maskImageData;
                try {
                    maskImageData = maskCtx.getImageData(0, 0, canvasW, canvasH);
                } catch (e) {
                    // Canvas is tainted (cross-origin image), fallback to simple draw
                    throw new Error('Canvas tainted by cross-origin data');
                }
                
                // Get the region of interest from the main canvas (the face area)
                // Use rotated dimensions to ensure we capture the full rotated mask
                const roiW = Math.min(Math.ceil(rotatedW), canvasOutput.width);
                const roiH = Math.min(Math.ceil(rotatedH), canvasOutput.height);
                // Center ROI on eye center
                const roiX = Math.max(0, Math.min(Math.floor(eyeCenterX - roiW / 2), canvasOutput.width - roiW));
                const roiY = Math.max(0, Math.min(Math.floor(eyeCenterY - roiH / 2), canvasOutput.height - roiH));
                
                let roiImageData;
                try {
                    roiImageData = ctx.getImageData(roiX, roiY, roiW, roiH);
                } catch (e) {
                    // Canvas might be tainted, fallback to simple draw with rotation
                    ctx.globalCompositeOperation = 'source-over';
                    ctx.imageSmoothingEnabled = true;
                    ctx.imageSmoothingQuality = 'high';
                    
                    // Apply rotation transformation
                    ctx.translate(eyeCenterX, eyeCenterY);
                    ctx.rotate(rotationAngle * Math.PI / 180);
                    ctx.translate(-eyeCenterX, -eyeCenterY);
                    
                    // Draw mask centered on eye center
                    ctx.drawImage(img, eyeCenterX - drawW / 2, eyeCenterY - drawH / 2, drawW, drawH);
                    ctx.restore();
                    return;
                }
                
                // Create output image data
                const outputData = new ImageData(roiW, roiH);
                
                // Professional compositing parameters (pre-calculated for performance)
                // Use actual canvas dimensions for center calculation
                const maskCanvasCenterX = canvasW * 0.5;
                const maskCanvasCenterY = canvasH * 0.5;
                const invCenterX = 1.0 / maskCanvasCenterX;
                const invCenterY = 1.0 / maskCanvasCenterY;
                const colorBlend = 0.92;
                const colorBlendInv = 1.0 - colorBlend;
                const colorBlendOrig = colorBlendInv * 0.15;
                const edgeThreshold = 0.9;
                const edgeRange = 0.1;
                const edgeFeatherThreshold = 0.15;
                const edgeFeatherStrength = 0.4;
                
                // Pre-calculate edge detection weights (sampleRadius = 3)
                const sampleRadius = 3;
                const sampleSize = (sampleRadius * 2 + 1) * (sampleRadius * 2 + 1);
                const edgeWeights = [];
                for (let sy = -sampleRadius; sy <= sampleRadius; sy++) {
                    for (let sx = -sampleRadius; sx <= sampleRadius; sx++) {
                        const dist = Math.sqrt(sx * sx + sy * sy);
                        edgeWeights.push(dist === 0 ? 1 : 1 / (1 + dist));
                    }
                }
                
                // Optimized pixel processing with cached calculations
                const origData = roiImageData.data;
                const maskData = maskImageData.data;
                const outData = outputData.data;
                const maskWidth = canvasW;
                const maskHeight = canvasH;
                
                // Calculate mapping from ROI coordinates to mask canvas coordinates
                // Both ROI and mask canvas are centered on eye center
                // ROI pixel (x, y) maps to mask canvas pixel:
                // maskX = centerX + (x - roiW/2)
                // maskY = centerY + (y - roiH/2)
                
                // Process each pixel with optimized blending
                for (let y = 0; y < roiH; y++) {
                    const yOffset = y * roiW;
                    // Map ROI coordinates to mask canvas coordinates
                    const maskY = Math.max(0, Math.min(Math.floor(maskCanvasCenterY + (y - roiH / 2)), maskHeight - 1));
                    const maskYOffset = maskY * maskWidth;
                    const distY = (maskY - maskCanvasCenterY) * invCenterY;
                    const distYSq = distY * distY;
                    
                    for (let x = 0; x < roiW; x++) {
                        const outIdx = (yOffset + x) * 4;
                        // Map ROI coordinates to mask canvas coordinates
                        const maskX = Math.max(0, Math.min(Math.floor(maskCanvasCenterX + (x - roiW / 2)), maskWidth - 1));
                        const maskIdx = (maskYOffset + maskX) * 4;
                        
                        // Get pixels (cached array access)
                        const origR = origData[outIdx];
                        const origG = origData[outIdx + 1];
                        const origB = origData[outIdx + 2];
                        
                        const maskR = maskData[maskIdx];
                        const maskG = maskData[maskIdx + 1];
                        const maskB = maskData[maskIdx + 2];
                        let maskAlpha = maskData[maskIdx + 3] * 0.003921568627451; // / 255.0
                        
                        // Fast edge feathering: distance from center (avoid sqrt when possible)
                        const distX = (maskX - maskCanvasCenterX) * invCenterX;
                        const distFromCenter = Math.sqrt(distX * distX + distYSq);
                        
                        // Feather outer edges (beyond 90% of radius) - optimized
                        if (distFromCenter > edgeThreshold) {
                            const edgeFactor = Math.max(0, 1 - ((distFromCenter - edgeThreshold) / edgeRange));
                            maskAlpha *= edgeFactor * Math.sqrt(edgeFactor); // pow(edgeFactor, 1.5) optimized
                        }
                        
                        // Optimized edge detection: only process if alpha is in transition zone
                        if (maskAlpha > 0.01 && maskAlpha < 0.99) {
                            let edgeStrength = 0;
                            let sampleCount = 0;
                            let weightIdx = 0;
                            
                            // Fast weighted sampling with pre-calculated weights
                            for (let sy = -sampleRadius; sy <= sampleRadius; sy++) {
                                const syIdx = Math.max(0, Math.min(maskHeight - 1, maskY + sy));
                                const syOffset = syIdx * maskWidth;
                                
                                    for (let sx = -sampleRadius; sx <= sampleRadius; sx++) {
                                        const sxIdx = Math.max(0, Math.min(maskWidth - 1, maskX + sx));
                                    const sIdx = (syOffset + sxIdx) * 4;
                                    const sAlpha = maskData[sIdx + 3] * 0.003921568627451;
                                    const weight = edgeWeights[weightIdx++];
                                    
                                    edgeStrength += Math.abs(maskAlpha - sAlpha) * weight;
                                    sampleCount += weight;
                                }
                            }
                            
                            // Soften transition edges
                            if (sampleCount > 0) {
                                edgeStrength /= sampleCount;
                                if (edgeStrength > edgeFeatherThreshold) {
                                    const edgeFeather = Math.min(1, (edgeStrength - edgeFeatherThreshold) * 2);
                                    maskAlpha *= (1 - edgeFeather * edgeFeatherStrength);
                                }
                            }
                        }
                        
                        // Optimized color matching and compositing (pre-multiplied constants)
                        const matchedR = maskR * colorBlend + origR * colorBlendOrig;
                        const matchedG = maskG * colorBlend + origG * colorBlendOrig;
                        const matchedB = maskB * colorBlend + origB * colorBlendOrig;
                        
                        // Fast premultiplied alpha compositing
                        const invAlpha = 1 - maskAlpha;
                        outData[outIdx] = Math.round(matchedR * maskAlpha + origR * invAlpha);
                        outData[outIdx + 1] = Math.round(matchedG * maskAlpha + origG * invAlpha);
                        outData[outIdx + 2] = Math.round(matchedB * maskAlpha + origB * invAlpha);
                        outData[outIdx + 3] = 255;
                    }
                }
                
                // Draw the professionally composited result back to main canvas
                // If using OffscreenCanvas, transfer the data
                if (offscreenCanvas && offscreenCtx) {
                    offscreenCtx.putImageData(outputData, 0, 0);
                    const offscreenImageData = offscreenCtx.getImageData(0, 0, roiW, roiH);
                    ctx.putImageData(offscreenImageData, roiX, roiY);
                } else {
                    ctx.putImageData(outputData, roiX, roiY);
                }
                
            } catch (error) {
                // Fallback to simple draw if advanced compositing fails
                // Only warn once for tainted canvas issues to avoid spam
                const isTaintedCanvas = error.message && (
                    error.message.includes('tainted') || 
                    error.message.includes('cross-origin') ||
                    error.toString().includes('tainted') ||
                    error.toString().includes('cross-origin')
                );
                
                if (isTaintedCanvas && taintedCanvasWarned) {
                    // Silently fallback - already warned
                } else {
                    if (isTaintedCanvas) {
                        taintedCanvasWarned = true;
                        console.warn('Advanced compositing unavailable (cross-origin image). Using simple blend mode.');
                    } else {
                        console.warn('Advanced compositing failed, using simple blend:', error);
                    }
                }
                ctx.globalCompositeOperation = 'source-over';
                ctx.imageSmoothingEnabled = true;
                ctx.imageSmoothingQuality = 'high';
                
                // Apply rotation transformation
                ctx.translate(eyeCenterX, eyeCenterY);
                ctx.rotate(rotationAngle * Math.PI / 180);
                ctx.translate(-eyeCenterX, -eyeCenterY);
                
                // Draw mask centered on eye center
                ctx.drawImage(img, eyeCenterX - drawW / 2, eyeCenterY - drawH / 2, drawW, drawH);
            }
            
            // Restore context state
            ctx.restore();
        }
        
        // Clear filter function
        function clearFilter() {
            selectFilter('');
            closeFxSearchModal();
        }
        
        // Select filter
        // Clean up old URL parameters (v and b) that are no longer used
        function cleanOldURLParams() {
            if (window.location.protocol === 'file:') {
                return;
            }
            
            const url = new URL(window.location.href);
            let needsUpdate = false;
            
            // Remove old version and build parameters
            if (url.searchParams.has('v')) {
                url.searchParams.delete('v');
                needsUpdate = true;
            }
            if (url.searchParams.has('b')) {
                url.searchParams.delete('b');
                needsUpdate = true;
            }
            
            // Update URL if we removed any parameters
            if (needsUpdate) {
                window.history.replaceState({}, '', url.toString());
            }
        }
        
        // Update URL with current FX
        function updateURLWithFX(filterValue) {
            // Skip URL updates for file:// protocol
            if (window.location.protocol === 'file:') {
                return;
            }
            
            const url = new URL(window.location.href);
            
            // Remove old version and build parameters
            url.searchParams.delete('v');
            url.searchParams.delete('b');
            
            if (filterValue && filterValue !== '') {
                url.searchParams.set('fx', filterValue);
            } else {
                url.searchParams.delete('fx');
            }
            
            // Update URL without reloading page
            window.history.pushState({}, '', url);
        }
        
        function selectFilter(filterValue, skipURLUpdate = false) {
            currentFilter = filterValue || '';
            
            // Save to localStorage (works even with file:// protocol)
            try {
                localStorage.setItem('wesworld-fx-last', currentFilter);
            } catch (error) {
                console.error('Error saving last filter to localStorage:', error);
            }
            
            if (currentFilter === '') {
                fxSelectedText.textContent = 'None (Original)';
                fxCurrentPin.style.display = 'none';
                if (clearFilterButton) {
                    clearFilterButton.style.display = 'none';
                }
                // Update title
                document.title = 'WesWorld FX';
            } else {
                fxSelectedText.textContent = formatFilterName(currentFilter);
                updateCurrentPinIcon();
                if (clearFilterButton) {
                    clearFilterButton.style.display = 'flex';
                }
                // Update title with filter name
                document.title = 'WesWorld FX - ' + formatFilterName(currentFilter);
            }
            
            // Update selected state
            if (fxOptionsContainer) {
                const allOptions = fxOptionsContainer.querySelectorAll('.fx-option');
                allOptions.forEach(opt => {
                    opt.classList.remove('selected');
                    if (opt.value === currentFilter) {
                        opt.classList.add('selected');
                    }
                });
            }
            
            // Update URL unless we're in the middle of a roulette
            if (!skipURLUpdate) {
                updateURLWithFX(currentFilter);
            }
        }
        
        // Cycle to next filter
        function cycleNextFilter() {
            // If we have pinned filters, cycle through those first
            if (pinnedFilters.length > 0) {
                if (currentFilter === '') {
                    // Start with first pinned filter
                    selectFilter(pinnedFilters[0]);
                } else {
                    const currentIndex = pinnedFilters.indexOf(currentFilter);
                    if (currentIndex >= 0) {
                        // Cycle within pinned filters
                        const nextIndex = (currentIndex + 1) % pinnedFilters.length;
                        selectFilter(pinnedFilters[nextIndex]);
                    } else {
                        // Current filter not in pinned, go to first pinned
                        selectFilter(pinnedFilters[0]);
                    }
                }
            } else {
                // Cycle through all filters
                const filters = ['', ...allFilters];
                const currentIndex = filters.indexOf(currentFilter);
                const nextIndex = (currentIndex + 1) % filters.length;
                selectFilter(filters[nextIndex]);
            }
        }
        
        // Cycle to previous filter
        function cyclePrevFilter() {
            // If we have pinned filters, cycle through those first
            if (pinnedFilters.length > 0) {
                if (currentFilter === '') {
                    // Start with last pinned filter
                    selectFilter(pinnedFilters[pinnedFilters.length - 1]);
                } else {
                    const currentIndex = pinnedFilters.indexOf(currentFilter);
                    if (currentIndex >= 0) {
                        // Cycle within pinned filters
                        const prevIndex = (currentIndex - 1 + pinnedFilters.length) % pinnedFilters.length;
                        selectFilter(pinnedFilters[prevIndex]);
                    } else {
                        // Current filter not in pinned, go to last pinned
                        selectFilter(pinnedFilters[pinnedFilters.length - 1]);
                    }
                }
            } else {
                // Cycle through all filters
                const filters = ['', ...allFilters];
                const currentIndex = filters.indexOf(currentFilter);
                const prevIndex = (currentIndex - 1 + filters.length) % filters.length;
                selectFilter(filters[prevIndex]);
            }
        }
        
        // Filter FX options based on search query
        function filterFxOptions(searchQuery) {
            const searchLower = searchQuery.toLowerCase().trim();
            const optionsContainer = document.getElementById('fxOptionsContainer');
            const pinnedContainer = document.getElementById('pinnedFxContainer');
            
            if (!searchLower) {
                if (optionsContainer) {
                    const allOptions = optionsContainer.querySelectorAll('.fx-option');
                    const allGroups = optionsContainer.querySelectorAll('.fx-group');
                    allOptions.forEach(option => option.style.display = '');
                    allGroups.forEach(group => group.style.display = '');
                }
                if (pinnedContainer) {
                    const pinnedItems = pinnedContainer.querySelectorAll('.pinned-fx-item');
                    pinnedItems.forEach(item => item.style.display = '');
                }
                return;
            }
            
            function matchesFilter(filterValue, displayText) {
                // Case-insensitive search that matches anywhere in the string
                const filterName = formatFilterName(filterValue).toLowerCase();
                const text = displayText.toLowerCase();
                const filterValueLower = filterValue.toLowerCase();
                
                // Extract face mask name for better matching (e.g., "sam" from "dropout_face_mask_sam")
                let faceMaskName = '';
                if (filterValue.includes('face_mask')) {
                    const parts = filterValue.split('_');
                    // Get the last part which is the mask name
                    faceMaskName = parts[parts.length - 1].toLowerCase();
                }
                
                // Check if search query appears anywhere in any of these strings
                return text.includes(searchLower) || 
                       filterName.includes(searchLower) || 
                       filterValueLower.includes(searchLower) ||
                       (faceMaskName && faceMaskName.includes(searchLower)) ||
                       (faceMaskName && `mask_${faceMaskName}`.includes(searchLower));
            }
            
            if (pinnedContainer) {
                const pinnedItems = pinnedContainer.querySelectorAll('.pinned-fx-item');
                pinnedItems.forEach(item => {
                    const filterName = item.dataset.filterName || '';
                    // Get text from .pinned-fx-item-text if it exists, otherwise use textContent
                    // This ensures we get clean text without the remove button (√ó)
                    const textElement = item.querySelector('.pinned-fx-item-text');
                    let text = '';
                    if (textElement) {
                        text = textElement.textContent || '';
                    } else {
                        // Fallback: use textContent but remove the √ó remove button
                        text = item.textContent || '';
                        text = text.replace(/√ó/g, '').trim();
                    }
                    item.style.display = matchesFilter(filterName, text) ? '' : 'none';
                });
            }
            
            if (optionsContainer) {
                const allOptions = optionsContainer.querySelectorAll('.fx-option');
                const allGroups = optionsContainer.querySelectorAll('.fx-group');
                
                allOptions.forEach(option => {
                    const filterValue = option.value || '';
                    // Get text from .fx-option-text if it exists, otherwise use textContent
                    // This ensures we get clean text without pin icons or other elements
                    const textElement = option.querySelector('.fx-option-text');
                    let optionText = '';
                    if (textElement) {
                        optionText = textElement.textContent || '';
                    } else {
                        // For options without .fx-option-text, get textContent but remove pin icon
                        optionText = option.textContent || '';
                        // Remove emoji pin icons (üìç and üìå) and √ó characters
                        optionText = optionText.replace(/üìç|üìå|√ó/g, '').trim();
                    }
                    option.style.display = matchesFilter(filterValue, optionText) ? '' : 'none';
                });
                
                // Hide groups that have no visible options
                allGroups.forEach(group => {
                    const visibleOptions = group.querySelectorAll('.fx-option[style=""]');
                    group.style.display = visibleOptions.length > 0 ? '' : 'none';
                });
            }
        }
        
        // Start random cycle (roulette) - cycles through filters like a slot machine
        function startRandomCycle() {
            if (isRandomCycling) {
                console.log('Roulette already running');
                return;
            }
            isRandomCycling = true;
            const filters = pinnedFilters.length > 0 ? pinnedFilters : allFilters;
            if (filters.length === 0) {
                console.log('No filters available for roulette');
                isRandomCycling = false;
                return;
            }
            console.log('Starting roulette with', filters.length, 'filters');
            let cycles = 0;
            const maxCycles = 10;
            randomCycleInterval = setInterval(() => {
                const randomFilter = filters[Math.floor(Math.random() * filters.length)];
                // Skip URL updates during roulette
                selectFilter(randomFilter, true);
                cycles++;
                if (cycles >= maxCycles) {
                    clearInterval(randomCycleInterval);
                    randomCycleInterval = null;
                    const finalFilter = filters[Math.floor(Math.random() * filters.length)];
                    // Update URL only after roulette ends
                    selectFilter(finalFilter, false);
                    isRandomCycling = false;
                    console.log('Roulette finished on:', finalFilter);
                }
            }, 100);
        }
        
        // Load test image
        function loadTestImage(imageFile) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        testImage = img;
                        clearTestImageButton.style.display = 'block';
                        console.log('Test image loaded:', img.width, 'x', img.height);
                        // Stop camera if running
                        if (localStream) {
                            stopCamera();
                        }
                        // Start processing the test image
                        processVideoFrame();
                        resolve();
                    };
                    img.onerror = reject;
                    img.src = e.target.result;
                };
                reader.onerror = reject;
                reader.readAsDataURL(imageFile);
            });
        }
        
        // Clear test image
        function clearTestImage() {
            testImage = null;
            clearTestImageButton.style.display = 'none';
            // Clear canvas
            if (ctx && canvasOutput) {
                ctx.clearRect(0, 0, canvasOutput.width, canvasOutput.height);
            }
        }
        
        // Process video frame or test image (optimized with frame rate limiting)
        async function processVideoFrame() {
            // Frame rate limiting for consistent 60fps performance
            const now = performance.now();
            if (now - lastFrameTime < frameInterval) {
                if (localStream || testImage) {
                    animationFrameId = requestAnimationFrame(processVideoFrame);
                }
                return;
            }
            lastFrameTime = now;
            
            // Check if we have everything we need
            const hasVideo = localStream && videoInput && videoInput.readyState >= 2;
            const hasTestImage = testImage && testImage.complete;
            
            if (isProcessing || !canvasOutput || !ctx || (!hasVideo && !hasTestImage)) {
                if (hasVideo || hasTestImage) {
                    animationFrameId = requestAnimationFrame(processVideoFrame);
                }
                return;
            }
            
            // Check if video is ready (only if using video)
            if (hasVideo && (videoInput.readyState < 2 || videoInput.videoWidth === 0 || videoInput.videoHeight === 0)) {
                animationFrameId = requestAnimationFrame(processVideoFrame);
                return;
            }
            
            isProcessing = true;
            
            try {
                // Set canvas size to match video
                if (canvasOutput.width !== videoInput.videoWidth || 
                    canvasOutput.height !== videoInput.videoHeight) {
                    canvasOutput.width = videoInput.videoWidth;
                    canvasOutput.height = videoInput.videoHeight;
                }
                
                // Draw video frame to canvas FIRST (always show the video)
                ctx.drawImage(videoInput, 0, 0, canvasOutput.width, canvasOutput.height);
                
                // Only process if we have a filter
                if (currentFilter) {
                    // Detect faces using MediaPipe (for face masks) - do this first
                    let faceRect = null;
                    let faceLandmarks = null;
                    if (faceLandmarker && (currentFilter.includes('face_mask'))) {
                        try {
                            // Use test image if available, otherwise use video
                            const source = testImage || videoInput;
                            const results = faceLandmarker.detectForVideo(source, performance.now());
                            
                            if (results.faceLandmarks && results.faceLandmarks.length > 0) {
                                faceLandmarks = results.faceLandmarks[0];
                                
                                // Calculate bounding box from landmarks
                                // Use key facial landmarks for better accuracy
                                // MediaPipe provides 468 landmarks, we'll use key points
                                let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                                
                                for (const landmark of faceLandmarks) {
                                    const x = landmark.x * canvasOutput.width;
                                    const y = landmark.y * canvasOutput.height;
                                    minX = Math.min(minX, x);
                                    minY = Math.min(minY, y);
                                    maxX = Math.max(maxX, x);
                                    maxY = Math.max(maxY, y);
                                }
                                
                                // Add padding for better mask coverage
                                const padding = 20;
                                const width = maxX - minX;
                                const height = maxY - minY;
                                
                                faceRect = {
                                    x: Math.max(0, minX - padding),
                                    y: Math.max(0, minY - padding),
                                    width: Math.min(canvasOutput.width - minX + padding, width + padding * 2),
                                    height: Math.min(canvasOutput.height - minY + padding, height + padding * 2),
                                    confidence: 1.0,
                                    landmarks: faceLandmarks
                                };
                            }
                        } catch (error) {
                            console.warn('Face detection error:', error);
                        }
                    }
                    
                    // For face masks, we don't need to read image data - just draw the mask
                    if (currentFilter.includes('face_mask')) {
                        // Apply face masks directly (no image data needed)
                        if (faceRect && faceLandmarks) {
                            applyFaceMask(ctx, faceRect, faceLandmarks, currentFilter);
                        }
                    } else {
                        // For other filters, try to get image data (may fail due to CORS)
                        let imageData = null;
                        try {
                            imageData = ctx.getImageData(0, 0, canvasOutput.width, canvasOutput.height);
                        } catch (error) {
                            // Canvas is tainted (CORS issue) - can't apply pixel-based filters
                            // This is expected for file:// protocol or cross-origin video
                            console.warn('Cannot read canvas data (CORS/tainted canvas). Some filters may not work.');
                            // Continue without applying filter - at least show the video
                        }
                        
                        if (imageData) {
                            // Apply filter
                            if (currentFilter && wasmModule) {
                                // Use WASM filter processing
                                wasmModule.processFrame(canvasOutput, canvasOutput, currentFilter, faceRect, frameCount);
                            } else if (currentFilter) {
                                // Fallback to JavaScript filters
                                applyJSFilter(imageData, currentFilter, faceRect);
                                ctx.putImageData(imageData, 0, 0);
                            }
                        }
                    }
                }
                
                frameCount++;
            } catch (error) {
                console.error('Error processing frame:', error);
            } finally {
                isProcessing = false;
            }
            
            // Continue processing
            if (localStream && videoInput && !videoInput.paused) {
                animationFrameId = requestAnimationFrame(processVideoFrame);
            }
        }
        
        // Theme definitions
        const THEMES = {
            wesworld: {
                name: "WesWorld",
                colors: {
                    background: "#000000",
                    surface: "#1a1a1a",
                    surfaceHover: "#2a2a2a",
                    text: "#ffffff",
                    textSecondary: "#cccccc",
                    accent: "#5250ef",
                    accentHover: "#6260ff",
                    border: "#333333",
                    borderHover: "#5250ef",
                    button: "#5250ef",
                    buttonHover: "#6260ff",
                    statusConnected: "#4caf50",
                    statusError: "#f44336",
                    groupTitle: "#5250ef",
                    selectedText: "#ffffff"
                }
            },
            dropout: {
                name: "Dropout",
                colors: {
                    background: "#0a0a0a",
                    surface: "#1a1a1a",
                    surfaceHover: "#2a2a2a",
                    text: "#ffffff",
                    textSecondary: "#e0e0e0",
                    accent: "#feea3b",
                    accentHover: "#fff04a",
                    border: "#333333",
                    borderHover: "#feea3b",
                    button: "#feea3b",
                    buttonHover: "#fff04a",
                    statusConnected: "#4caf50",
                    statusError: "#ff4444",
                    groupTitle: "#feea3b",
                    selectedText: "#000000"
                }
            }
        };
        
        // Load and apply theme
        function loadThemes() {
            // Populate theme dropdown
            themeSelect.innerHTML = '';
            Object.keys(THEMES).forEach(themeKey => {
                const option = document.createElement('option');
                option.value = themeKey;
                option.textContent = THEMES[themeKey].name;
                themeSelect.appendChild(option);
            });
            
            // Load saved theme or use default (wesworld)
            const savedTheme = localStorage.getItem('wesworld-fx-theme') || 'wesworld';
            if (THEMES[savedTheme]) {
                themeSelect.value = savedTheme;
                applyTheme(THEMES[savedTheme]);
            } else {
                applyTheme(THEMES.wesworld);
            }
        }
        
        // Apply theme to page
        function applyTheme(theme) {
            if (theme && theme.colors) {
                const root = document.documentElement;
                const colorMap = {
                    background: 'background-color',
                    surface: 'surface-color',
                    surfaceHover: 'surface-hover-color',
                    text: 'text-color',
                    textSecondary: 'text-secondary-color',
                    accent: 'accent-color',
                    accentHover: 'accent-hover-color',
                    border: 'border-color',
                    borderHover: 'border-hover-color',
                    button: 'button-color',
                    buttonHover: 'button-hover-color',
                    statusConnected: 'status-connected-color',
                    statusError: 'status-error-color',
                    groupTitle: 'group-title-color',
                    selectedText: 'selected-text-color'
                };
                
                Object.entries(theme.colors).forEach(([key, value]) => {
                    const cssVar = colorMap[key] || key.replace(/([A-Z])/g, '-$1').toLowerCase();
                    root.style.setProperty(`--${cssVar}`, value);
                });
            }
        }
        
        // JavaScript filter implementations (complete set)
        const FilterImplementations = {
            applyBlackWhite(data) {
                for (let i = 0; i < data.length; i += 4) {
                    const gray = data[i] * 0.299 + data[i + 1] * 0.587 + data[i + 2] * 0.114;
                    data[i] = gray; data[i + 1] = gray; data[i + 2] = gray;
                }
            },
            applySepia(data) {
                for (let i = 0; i < data.length; i += 4) {
                    const r = data[i], g = data[i + 1], b = data[i + 2];
                    data[i] = Math.min(255, (r * 0.393) + (g * 0.769) + (b * 0.189));
                    data[i + 1] = Math.min(255, (r * 0.349) + (g * 0.686) + (b * 0.168));
                    data[i + 2] = Math.min(255, (r * 0.272) + (g * 0.534) + (b * 0.131));
                }
            },
            applyNegative(data) {
                for (let i = 0; i < data.length; i += 4) {
                    data[i] = 255 - data[i]; data[i + 1] = 255 - data[i + 1]; data[i + 2] = 255 - data[i + 2];
                }
            },
            applyVintage(data) {
                for (let i = 0; i < data.length; i += 4) {
                    data[i] = Math.min(255, data[i] * 0.9 + 20);
                    data[i + 1] = Math.min(255, data[i + 1] * 0.85 + 15);
                    data[i + 2] = Math.min(255, data[i + 2] * 0.8 + 10);
                }
            },
            applyNeonGlow(data) {
                for (let i = 0; i < data.length; i += 4) {
                    const brightness = (data[i] + data[i + 1] + data[i + 2]) / 3;
                    data[i] = Math.min(255, brightness * 1.5);
                    data[i + 1] = Math.min(255, brightness * 1.2);
                    data[i + 2] = Math.min(255, brightness * 2);
                }
            },
            applyRedTint(data) {
                for (let i = 0; i < data.length; i += 4) data[i] = Math.min(255, data[i] * 1.5);
            },
            applyBlueTint(data) {
                for (let i = 0; i < data.length; i += 4) data[i + 2] = Math.min(255, data[i + 2] * 1.5);
            },
            applyGreenTint(data) {
                for (let i = 0; i < data.length; i += 4) data[i + 1] = Math.min(255, data[i + 1] * 1.5);
            },
            applyPosterize(data) {
                const levels = 4;
                for (let i = 0; i < data.length; i += 4) {
                    data[i] = Math.floor(data[i] / (256 / levels)) * (256 / levels);
                    data[i + 1] = Math.floor(data[i + 1] / (256 / levels)) * (256 / levels);
                    data[i + 2] = Math.floor(data[i + 2] / (256 / levels)) * (256 / levels);
                }
            },
            applyThermal(data) {
                for (let i = 0; i < data.length; i += 4) {
                    const gray = (data[i] + data[i + 1] + data[i + 2]) / 3;
                    if (gray < 85) {
                        data[i] = 0; data[i + 1] = 0; data[i + 2] = gray * 3;
                    } else if (gray < 170) {
                        data[i] = (gray - 85) * 3; data[i + 1] = 255; data[i + 2] = 255;
                    } else {
                        data[i] = 255; data[i + 1] = 255 - (gray - 170) * 3; data[i + 2] = 0;
                    }
                }
            },
            applyPixelate(data, width, height) {
                const pixelSize = 10;
                for (let y = 0; y < height; y += pixelSize) {
                    for (let x = 0; x < width; x += pixelSize) {
                        let r = 0, g = 0, b = 0, count = 0;
                        for (let dy = 0; dy < pixelSize && y + dy < height; dy++) {
                            for (let dx = 0; dx < pixelSize && x + dx < width; dx++) {
                                const idx = ((y + dy) * width + (x + dx)) * 4;
                                r += data[idx]; g += data[idx + 1]; b += data[idx + 2]; count++;
                            }
                        }
                        r = Math.floor(r / count); g = Math.floor(g / count); b = Math.floor(b / count);
                        for (let dy = 0; dy < pixelSize && y + dy < height; dy++) {
                            for (let dx = 0; dx < pixelSize && x + dx < width; dx++) {
                                const idx = ((y + dy) * width + (x + dx)) * 4;
                                data[idx] = r; data[idx + 1] = g; data[idx + 2] = b;
                            }
                        }
                    }
                }
            },
            applyBulge(data, width, height) {
                const centerX = width / 2, centerY = height / 2;
                const radius = Math.min(width, height) / 2, strength = 0.5;
                const temp = new Uint8ClampedArray(data);
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const dx = x - centerX, dy = y - centerY;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist < radius) {
                            const angle = Math.atan2(dy, dx);
                            const r = dist / radius;
                            const newR = r * (1 - strength * (1 - r));
                            const newX = Math.round(centerX + Math.cos(angle) * newR * radius);
                            const newY = Math.round(centerY + Math.sin(angle) * newR * radius);
                            if (newX >= 0 && newX < width && newY >= 0 && newY < height) {
                                const srcIdx = (y * width + x) * 4;
                                const dstIdx = (newY * width + newX) * 4;
                                data[srcIdx] = temp[dstIdx];
                                data[srcIdx + 1] = temp[dstIdx + 1];
                                data[srcIdx + 2] = temp[dstIdx + 2];
                                data[srcIdx + 3] = temp[dstIdx + 3];
                            }
                        }
                    }
                }
            },
            applySwirl(data, width, height) {
                const centerX = width / 2, centerY = height / 2;
                const radius = Math.min(width, height) / 2, strength = 2.0;
                const temp = new Uint8ClampedArray(data);
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const dx = x - centerX, dy = y - centerY;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist < radius) {
                            const angle = Math.atan2(dy, dx);
                            const maxAngle = strength * (1 - dist / radius);
                            const newAngle = angle + maxAngle;
                            const newX = Math.round(centerX + dist * Math.cos(newAngle));
                            const newY = Math.round(centerY + dist * Math.sin(newAngle));
                            if (newX >= 0 && newX < width && newY >= 0 && newY < height) {
                                const srcIdx = (y * width + x) * 4;
                                const dstIdx = (newY * width + newX) * 4;
                                data[srcIdx] = temp[dstIdx];
                                data[srcIdx + 1] = temp[dstIdx + 1];
                                data[srcIdx + 2] = temp[dstIdx + 2];
                                data[srcIdx + 3] = temp[dstIdx + 3];
                            }
                        }
                    }
                }
            },
            applyStretch(data, width, height) {
                const centerX = width / 2, centerY = height / 2;
                const stretchX = 1.5, stretchY = 0.7;
                const temp = new Uint8ClampedArray(data);
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const dx = (x - centerX) / stretchX;
                        const dy = (y - centerY) / stretchY;
                        const newX = Math.round(centerX + dx);
                        const newY = Math.round(centerY + dy);
                        if (newX >= 0 && newX < width && newY >= 0 && newY < height) {
                            const srcIdx = (y * width + x) * 4;
                            const dstIdx = (newY * width + newX) * 4;
                            data[srcIdx] = temp[dstIdx];
                            data[srcIdx + 1] = temp[dstIdx + 1];
                            data[srcIdx + 2] = temp[dstIdx + 2];
                            data[srcIdx + 3] = temp[dstIdx + 3];
                        }
                    }
                }
            },
            applyFisheye(data, width, height) {
                const centerX = width / 2, centerY = height / 2;
                const radius = Math.min(width, height) / 2, strength = 0.8;
                const temp = new Uint8ClampedArray(data);
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const dx = x - centerX, dy = y - centerY;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        const normalizedDist = Math.min(dist / radius, 1);
                        const newDist = normalizedDist * (1 - strength * normalizedDist * normalizedDist) * radius;
                        const angle = Math.atan2(dy, dx);
                        const newX = Math.round(centerX + newDist * Math.cos(angle));
                        const newY = Math.round(centerY + newDist * Math.sin(angle));
                        if (newX >= 0 && newX < width && newY >= 0 && newY < height) {
                            const srcIdx = (y * width + x) * 4;
                            const dstIdx = (newY * width + newX) * 4;
                            data[srcIdx] = temp[dstIdx];
                            data[srcIdx + 1] = temp[dstIdx + 1];
                            data[srcIdx + 2] = temp[dstIdx + 2];
                            data[srcIdx + 3] = temp[dstIdx + 3];
                        }
                    }
                }
            },
            applyPinch(data, width, height) {
                const centerX = width / 2, centerY = height / 2;
                const radius = Math.min(width, height) / 2, strength = 0.6;
                const temp = new Uint8ClampedArray(data);
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const dx = x - centerX, dy = y - centerY;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        const normalizedDist = Math.min(dist / radius, 1);
                        const newDist = normalizedDist * (1 + strength * (1 - normalizedDist)) * radius;
                        const angle = Math.atan2(dy, dx);
                        const newX = Math.round(centerX + newDist * Math.cos(angle));
                        const newY = Math.round(centerY + newDist * Math.sin(angle));
                        if (newX >= 0 && newX < width && newY >= 0 && newY < height) {
                            const srcIdx = (y * width + x) * 4;
                            const dstIdx = (newY * width + newX) * 4;
                            data[srcIdx] = temp[dstIdx];
                            data[srcIdx + 1] = temp[dstIdx + 1];
                            data[srcIdx + 2] = temp[dstIdx + 2];
                            data[srcIdx + 3] = temp[dstIdx + 3];
                        }
                    }
                }
            },
            applyWave(data, width, height) {
                const centerY = height / 2;
                const amplitude = 30, frequency = 0.05;
                const temp = new Uint8ClampedArray(data);
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const offset = Math.sin((y - centerY) * frequency) * amplitude;
                        const newX = Math.round(x + offset);
                        if (newX >= 0 && newX < width) {
                            const srcIdx = (y * width + x) * 4;
                            const dstIdx = (y * width + newX) * 4;
                            data[srcIdx] = temp[dstIdx];
                            data[srcIdx + 1] = temp[dstIdx + 1];
                            data[srcIdx + 2] = temp[dstIdx + 2];
                            data[srcIdx + 3] = temp[dstIdx + 3];
                        }
                    }
                }
            },
            applyMirror(data, width, height) {
                const centerX = width / 2;
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < centerX; x++) {
                        const srcIdx = (y * width + x) * 4;
                        const dstIdx = (y * width + (width - x - 1)) * 4;
                        data[dstIdx] = data[srcIdx];
                        data[dstIdx + 1] = data[srcIdx + 1];
                        data[dstIdx + 2] = data[srcIdx + 2];
                        data[dstIdx + 3] = data[srcIdx + 3];
                    }
                }
            },
            applyFlipHorizontal(data, width, height) {
                const temp = new Uint8ClampedArray(data);
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const srcIdx = (y * width + x) * 4;
                        const dstIdx = (y * width + (width - x - 1)) * 4;
                        data[srcIdx] = temp[dstIdx];
                        data[srcIdx + 1] = temp[dstIdx + 1];
                        data[srcIdx + 2] = temp[dstIdx + 2];
                        data[srcIdx + 3] = temp[dstIdx + 3];
                    }
                }
            },
            applyFlipVertical(data, width, height) {
                const temp = new Uint8ClampedArray(data);
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const srcIdx = (y * width + x) * 4;
                        const dstIdx = ((height - y - 1) * width + x) * 4;
                        data[srcIdx] = temp[dstIdx];
                        data[srcIdx + 1] = temp[dstIdx + 1];
                        data[srcIdx + 2] = temp[dstIdx + 2];
                        data[srcIdx + 3] = temp[dstIdx + 3];
                    }
                }
            },
            applyRotate90(data, width, height) {
                const temp = new Uint8ClampedArray(data);
                const newWidth = height, newHeight = width;
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const srcIdx = (y * width + x) * 4;
                        const newX = height - y - 1;
                        const newY = x;
                        const dstIdx = (newY * newWidth + newX) * 4;
                        if (dstIdx < data.length) {
                            data[dstIdx] = temp[srcIdx];
                            data[dstIdx + 1] = temp[srcIdx + 1];
                            data[dstIdx + 2] = temp[srcIdx + 2];
                            data[dstIdx + 3] = temp[srcIdx + 3];
                        }
                    }
                }
            },
            applyBlur(data, width, height) {
                const radius = 5;
                const temp = new Uint8ClampedArray(data);
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        let r = 0, g = 0, b = 0, count = 0;
                        for (let dy = -radius; dy <= radius; dy++) {
                            for (let dx = -radius; dx <= radius; dx++) {
                                const nx = x + dx, ny = y + dy;
                                if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                                    const idx = (ny * width + nx) * 4;
                                    r += temp[idx]; g += temp[idx + 1]; b += temp[idx + 2]; count++;
                                }
                            }
                        }
                        const idx = (y * width + x) * 4;
                        data[idx] = r / count; data[idx + 1] = g / count; data[idx + 2] = b / count;
                    }
                }
            },
            applySharpen(data, width, height) {
                const kernel = [[0, -1, 0], [-1, 5, -1], [0, -1, 0]];
                const temp = new Uint8ClampedArray(data);
                for (let y = 1; y < height - 1; y++) {
                    for (let x = 1; x < width - 1; x++) {
                        let r = 0, g = 0, b = 0;
                        for (let ky = -1; ky <= 1; ky++) {
                            for (let kx = -1; kx <= 1; kx++) {
                                const idx = ((y + ky) * width + (x + kx)) * 4;
                                const weight = kernel[ky + 1][kx + 1];
                                r += temp[idx] * weight; g += temp[idx + 1] * weight; b += temp[idx + 2] * weight;
                            }
                        }
                        const idx = (y * width + x) * 4;
                        data[idx] = Math.max(0, Math.min(255, r));
                        data[idx + 1] = Math.max(0, Math.min(255, g));
                        data[idx + 2] = Math.max(0, Math.min(255, b));
                    }
                }
            },
            applyEmboss(data, width, height) {
                const kernel = [[-2, -1, 0], [-1, 1, 1], [0, 1, 2]];
                const temp = new Uint8ClampedArray(data);
                for (let y = 1; y < height - 1; y++) {
                    for (let x = 1; x < width - 1; x++) {
                        let r = 0, g = 0, b = 0;
                        for (let ky = -1; ky <= 1; ky++) {
                            for (let kx = -1; kx <= 1; kx++) {
                                const idx = ((y + ky) * width + (x + kx)) * 4;
                                const weight = kernel[ky + 1][kx + 1];
                                r += temp[idx] * weight; g += temp[idx + 1] * weight; b += temp[idx + 2] * weight;
                            }
                        }
                        const idx = (y * width + x) * 4;
                        const gray = (r + g + b) / 3;
                        data[idx] = Math.max(0, Math.min(255, gray + 128));
                        data[idx + 1] = Math.max(0, Math.min(255, gray + 128));
                        data[idx + 2] = Math.max(0, Math.min(255, gray + 128));
                    }
                }
            },
            applySketch(data, width, height) {
                this.applyBlur(data, width, height);
                for (let i = 0; i < data.length; i += 4) {
                    const gray = (data[i] + data[i + 1] + data[i + 2]) / 3;
                    const inverted = 255 - gray;
                    data[i] = data[i + 1] = data[i + 2] = Math.min(255, inverted);
                }
            },
            applyCartoon(data, width, height) {
                this.applyBlur(data, width, height);
                this.applyPosterize(data);
            },
            applyRainbow(data, width, height) {
                for (let y = 0; y < height; y++) {
                    const hue = (y / height) * 360;
                    for (let x = 0; x < width; x++) {
                        const idx = (y * width + x) * 4;
                        const gray = (data[idx] + data[idx + 1] + data[idx + 2]) / 3;
                        const rgb = this.hslToRgb(hue / 360, 1, gray / 255);
                        data[idx] = rgb[0]; data[idx + 1] = rgb[1]; data[idx + 2] = rgb[2];
                    }
                }
            },
            applyRainbowShift(data) {
                for (let i = 0; i < data.length; i += 4) {
                    const gray = (data[i] + data[i + 1] + data[i + 2]) / 3;
                    const hue = (gray / 255 + 0.5) % 1;
                    const rgb = this.hslToRgb(hue, 1, 0.5);
                    data[i] = rgb[0]; data[i + 1] = rgb[1]; data[i + 2] = rgb[2];
                }
            },
            applyIce(data) {
                for (let i = 0; i < data.length; i += 4) {
                    const gray = (data[i] + data[i + 1] + data[i + 2]) / 3;
                    data[i] = Math.min(255, gray * 0.8);
                    data[i + 1] = Math.min(255, gray * 1.2);
                    data[i + 2] = Math.min(255, gray * 1.5);
                }
            },
            applyOcean(data) {
                for (let i = 0; i < data.length; i += 4) {
                    const gray = (data[i] + data[i + 1] + data[i + 2]) / 3;
                    data[i] = Math.min(255, gray * 0.5);
                    data[i + 1] = Math.min(255, gray * 0.8);
                    data[i + 2] = Math.min(255, gray * 1.2);
                }
            },
            applyPlasma(data) {
                for (let i = 0; i < data.length; i += 4) {
                    const gray = (data[i] + data[i + 1] + data[i + 2]) / 3;
                    const hue = (gray / 255) * 0.7;
                    const rgb = this.hslToRgb(hue, 1, 0.5);
                    data[i] = rgb[0]; data[i + 1] = rgb[1]; data[i + 2] = rgb[2];
                }
            },
            applyJet(data) {
                for (let i = 0; i < data.length; i += 4) {
                    const gray = (data[i] + data[i + 1] + data[i + 2]) / 3;
                    const normalized = gray / 255;
                    if (normalized < 0.25) {
                        data[i] = 0;
                        data[i + 1] = 0;
                        data[i + 2] = Math.min(255, normalized * 4 * 255);
                    } else if (normalized < 0.5) {
                        data[i] = 0;
                        data[i + 1] = Math.min(255, (normalized - 0.25) * 4 * 255);
                        data[i + 2] = 255;
                    } else if (normalized < 0.75) {
                        data[i] = Math.min(255, (normalized - 0.5) * 4 * 255);
                        data[i + 1] = 255;
                        data[i + 2] = Math.min(255, 255 - (normalized - 0.5) * 4 * 255);
                    } else {
                        data[i] = 255;
                        data[i + 1] = Math.min(255, 255 - (normalized - 0.75) * 4 * 255);
                        data[i + 2] = 0;
                    }
                }
            },
            applyTurbo(data) {
                for (let i = 0; i < data.length; i += 4) {
                    const gray = (data[i] + data[i + 1] + data[i + 2]) / 3;
                    const normalized = gray / 255;
                    const hue = normalized * 0.8;
                    const rgb = this.hslToRgb(hue, 1, 0.5);
                    data[i] = rgb[0]; data[i + 1] = rgb[1]; data[i + 2] = rgb[2];
                }
            },
            applyInferno(data) {
                for (let i = 0; i < data.length; i += 4) {
                    const gray = (data[i] + data[i + 1] + data[i + 2]) / 3;
                    const normalized = gray / 255;
                    if (normalized < 0.5) {
                        data[i] = Math.min(255, normalized * 2 * 255);
                        data[i + 1] = 0;
                        data[i + 2] = 0;
                    } else {
                        data[i] = 255;
                        data[i + 1] = Math.min(255, (normalized - 0.5) * 2 * 255);
                        data[i + 2] = Math.min(255, (normalized - 0.5) * 2 * 128);
                    }
                }
            },
            applyMagma(data) {
                for (let i = 0; i < data.length; i += 4) {
                    const gray = (data[i] + data[i + 1] + data[i + 2]) / 3;
                    const normalized = gray / 255;
                    data[i] = Math.min(255, normalized * 255);
                    data[i + 1] = Math.min(255, normalized * normalized * 128);
                    data[i + 2] = Math.min(255, normalized * normalized * normalized * 255);
                }
            },
            applyViridis(data) {
                for (let i = 0; i < data.length; i += 4) {
                    const gray = (data[i] + data[i + 1] + data[i + 2]) / 3;
                    const normalized = gray / 255;
                    const hue = normalized * 0.6;
                    const rgb = this.hslToRgb(hue, 1, normalized * 0.5 + 0.3);
                    data[i] = rgb[0]; data[i + 1] = rgb[1]; data[i + 2] = rgb[2];
                }
            },
            applyCool(data) {
                for (let i = 0; i < data.length; i += 4) {
                    const gray = (data[i] + data[i + 1] + data[i + 2]) / 3;
                    data[i] = Math.min(255, gray * 0.5);
                    data[i + 1] = Math.min(255, gray);
                    data[i + 2] = Math.min(255, gray * 1.5);
                }
            },
            applyHot(data) {
                for (let i = 0; i < data.length; i += 4) {
                    const gray = (data[i] + data[i + 1] + data[i + 2]) / 3;
                    const normalized = gray / 255;
                    if (normalized < 0.33) {
                        data[i] = Math.min(255, normalized * 3 * 255);
                        data[i + 1] = 0;
                        data[i + 2] = 0;
                    } else if (normalized < 0.66) {
                        data[i] = 255;
                        data[i + 1] = Math.min(255, (normalized - 0.33) * 3 * 255);
                        data[i + 2] = 0;
                    } else {
                        data[i] = 255;
                        data[i + 1] = 255;
                        data[i + 2] = Math.min(255, (normalized - 0.66) * 3 * 255);
                    }
                }
            },
            applySpring(data) {
                for (let i = 0; i < data.length; i += 4) {
                    const gray = (data[i] + data[i + 1] + data[i + 2]) / 3;
                    data[i] = 255;
                    data[i + 1] = Math.min(255, gray);
                    data[i + 2] = Math.min(255, gray * 0.5);
                }
            },
            applySummer(data) {
                for (let i = 0; i < data.length; i += 4) {
                    const gray = (data[i] + data[i + 1] + data[i + 2]) / 3;
                    data[i] = Math.min(255, gray);
                    data[i + 1] = Math.min(255, gray * 1.2);
                    data[i + 2] = Math.min(255, gray * 0.3);
                }
            },
            applyAutumn(data) {
                for (let i = 0; i < data.length; i += 4) {
                    const gray = (data[i] + data[i + 1] + data[i + 2]) / 3;
                    data[i] = 255;
                    data[i + 1] = Math.min(255, gray);
                    data[i + 2] = 0;
                }
            },
            applyWinter(data) {
                for (let i = 0; i < data.length; i += 4) {
                    const gray = (data[i] + data[i + 1] + data[i + 2]) / 3;
                    data[i] = 0;
                    data[i + 1] = Math.min(255, gray * 0.5);
                    data[i + 2] = Math.min(255, gray);
                }
            },
            applyVHS(data, width, height) {
                // Add noise
                for (let i = 0; i < data.length; i += 4) {
                    const noise = Math.random() * 30;
                    data[i] = Math.min(255, data[i] + noise);
                    data[i + 1] = Math.min(255, data[i + 1] + noise);
                    data[i + 2] = Math.min(255, data[i + 2] + noise);
                }
                // Add scanlines
                for (let y = 0; y < height; y += 3) {
                    for (let x = 0; x < width; x++) {
                        const idx = (y * width + x) * 4;
                        data[idx] = Math.min(255, data[idx] * 0.8);
                        data[idx + 1] = Math.min(255, data[idx + 1] * 1.2);
                        data[idx + 2] = Math.min(255, data[idx + 2] * 0.8);
                    }
                }
            },
            applyRetro(data, width, height) {
                this.applySepia(data);
                this.applyVHS(data, width, height);
            },
            applyCyberpunk(data, width, height) {
                // Shift hue to cyan/magenta
                for (let i = 0; i < data.length; i += 4) {
                    const gray = (data[i] + data[i + 1] + data[i + 2]) / 3;
                    const hue = (gray / 255 + 0.5) % 1;
                    const rgb = this.hslToRgb(hue, 1, 0.6);
                    data[i] = rgb[0]; data[i + 1] = rgb[1]; data[i + 2] = rgb[2];
                }
                // Increase contrast
                for (let i = 0; i < data.length; i += 4) {
                    data[i] = Math.min(255, (data[i] - 128) * 1.5 + 128);
                    data[i + 1] = Math.min(255, (data[i + 1] - 128) * 1.5 + 128);
                    data[i + 2] = Math.min(255, (data[i + 2] - 128) * 1.5 + 128);
                }
            },
            hslToRgb(h, s, l) {
                let r, g, b;
                if (s === 0) {
                    r = g = b = l;
                } else {
                    const hue2rgb = (p, q, t) => {
                        if (t < 0) t += 1; if (t > 1) t -= 1;
                        if (t < 1/6) return p + (q - p) * 6 * t;
                        if (t < 1/2) return q;
                        if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                        return p;
                    };
                    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                    const p = 2 * l - q;
                    r = hue2rgb(p, q, h + 1/3);
                    g = hue2rgb(p, q, h);
                    b = hue2rgb(p, q, h - 1/3);
                }
                return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
            },
            applyAnime(data, width, height) {
                this.applyBlur(data, width, height);
                // Increase saturation
                for (let i = 0; i < data.length; i += 4) {
                    const gray = (data[i] + data[i + 1] + data[i + 2]) / 3;
                    data[i] = Math.min(255, gray + (data[i] - gray) * 1.5);
                    data[i + 1] = Math.min(255, gray + (data[i + 1] - gray) * 1.5);
                    data[i + 2] = Math.min(255, gray + (data[i + 2] - gray) * 1.5);
                }
            },
            applyGlow(data, width, height) {
                const temp = new Uint8ClampedArray(data);
                this.applyBlur(data, width, height);
                // Blend original with blurred
                for (let i = 0; i < data.length; i += 4) {
                    data[i] = Math.min(255, temp[i] * 1.2 + data[i] * 0.3);
                    data[i + 1] = Math.min(255, temp[i + 1] * 1.2 + data[i + 1] * 0.3);
                    data[i + 2] = Math.min(255, temp[i + 2] * 1.2 + data[i + 2] * 0.3);
                }
            },
            applySolarize(data) {
                for (let i = 0; i < data.length; i += 4) {
                    const threshold = 128;
                    data[i] = data[i] > threshold ? 255 - data[i] : data[i];
                    data[i + 1] = data[i + 1] > threshold ? 255 - data[i + 1] : data[i + 1];
                    data[i + 2] = data[i + 2] > threshold ? 255 - data[i + 2] : data[i + 2];
                }
            },
            applyEdgeDetect(data, width, height) {
                const kernelX = [[-1, 0, 1], [-2, 0, 2], [-1, 0, 1]];
                const kernelY = [[-1, -2, -1], [0, 0, 0], [1, 2, 1]];
                const temp = new Uint8ClampedArray(data);
                for (let y = 1; y < height - 1; y++) {
                    for (let x = 1; x < width - 1; x++) {
                        let gx = 0, gy = 0;
                        for (let ky = -1; ky <= 1; ky++) {
                            for (let kx = -1; kx <= 1; kx++) {
                                const idx = ((y + ky) * width + (x + kx)) * 4;
                                const gray = (temp[idx] + temp[idx + 1] + temp[idx + 2]) / 3;
                                gx += gray * kernelX[ky + 1][kx + 1];
                                gy += gray * kernelY[ky + 1][kx + 1];
                            }
                        }
                        const magnitude = Math.sqrt(gx * gx + gy * gy);
                        const idx = (y * width + x) * 4;
                        const val = Math.min(255, magnitude);
                        data[idx] = val;
                        data[idx + 1] = val;
                        data[idx + 2] = val;
                    }
                }
            },
            applyHalftone(data, width, height) {
                const temp = new Uint8ClampedArray(data);
                const dotSize = 4;
                for (let y = 0; y < height; y += dotSize) {
                    for (let x = 0; x < width; x += dotSize) {
                        let gray = 0, count = 0;
                        for (let dy = 0; dy < dotSize && y + dy < height; dy++) {
                            for (let dx = 0; dx < dotSize && x + dx < width; dx++) {
                                const idx = ((y + dy) * width + (x + dx)) * 4;
                                gray += (temp[idx] + temp[idx + 1] + temp[idx + 2]) / 3;
                                count++;
                            }
                        }
                        gray = gray / count;
                        const radius = (1 - gray / 255) * (dotSize / 2);
                        for (let dy = 0; dy < dotSize && y + dy < height; dy++) {
                            for (let dx = 0; dx < dotSize && x + dx < width; dx++) {
                                const idx = ((y + dy) * width + (x + dx)) * 4;
                                const dist = Math.sqrt((dx - dotSize/2) ** 2 + (dy - dotSize/2) ** 2);
                                if (dist < radius) {
                                    data[idx] = 0;
                                    data[idx + 1] = 0;
                                    data[idx + 2] = 0;
                                } else {
                                    data[idx] = 255;
                                    data[idx + 1] = 255;
                                    data[idx + 2] = 255;
                                }
                            }
                        }
                    }
                }
            },
            applyAcidTrip(data, width, height) {
                this.applySwirl(data, width, height);
                this.applyRainbow(data, width, height);
            },
            applyTwirl(data, width, height) {
                const centerX = width / 2, centerY = height / 2;
                const radius = Math.min(width, height) / 2, strength = 3.0;
                const temp = new Uint8ClampedArray(data);
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const dx = x - centerX, dy = y - centerY;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist < radius) {
                            const angle = Math.atan2(dy, dx);
                            const maxAngle = strength * (1 - dist / radius);
                            const newAngle = angle + maxAngle;
                            const newX = Math.round(centerX + dist * Math.cos(newAngle));
                            const newY = Math.round(centerY + dist * Math.sin(newAngle));
                            if (newX >= 0 && newX < width && newY >= 0 && newY < height) {
                                const srcIdx = (y * width + x) * 4;
                                const dstIdx = (newY * width + newX) * 4;
                                data[srcIdx] = temp[dstIdx];
                                data[srcIdx + 1] = temp[dstIdx + 1];
                                data[srcIdx + 2] = temp[dstIdx + 2];
                                data[srcIdx + 3] = temp[dstIdx + 3];
                            }
                        }
                    }
                }
            },
            applyRipple(data, width, height) {
                const centerX = width / 2, centerY = height / 2;
                const frequency = 0.1, amplitude = 20;
                const temp = new Uint8ClampedArray(data);
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const dx = x - centerX, dy = y - centerY;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        const ripple = Math.sin(dist * frequency) * amplitude;
                        const angle = Math.atan2(dy, dx);
                        const newX = Math.round(x + ripple * Math.cos(angle));
                        const newY = Math.round(y + ripple * Math.sin(angle));
                        if (newX >= 0 && newX < width && newY >= 0 && newY < height) {
                            const srcIdx = (y * width + x) * 4;
                            const dstIdx = (newY * width + newX) * 4;
                            data[srcIdx] = temp[dstIdx];
                            data[srcIdx + 1] = temp[dstIdx + 1];
                            data[srcIdx + 2] = temp[dstIdx + 2];
                            data[srcIdx + 3] = temp[dstIdx + 3];
                        }
                    }
                }
            },
            applySphere(data, width, height) {
                const centerX = width / 2, centerY = height / 2;
                const radius = Math.min(width, height) / 2, strength = 0.5;
                const temp = new Uint8ClampedArray(data);
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const dx = x - centerX, dy = y - centerY;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        const normalizedDist = Math.min(dist / radius, 1);
                        const newDist = normalizedDist * (1 - strength * normalizedDist) * radius;
                        const angle = Math.atan2(dy, dx);
                        const newX = Math.round(centerX + newDist * Math.cos(angle));
                        const newY = Math.round(centerY + newDist * Math.sin(angle));
                        if (newX >= 0 && newX < width && newY >= 0 && newY < height) {
                            const srcIdx = (y * width + x) * 4;
                            const dstIdx = (newY * width + newX) * 4;
                            data[srcIdx] = temp[dstIdx];
                            data[srcIdx + 1] = temp[dstIdx + 1];
                            data[srcIdx + 2] = temp[dstIdx + 2];
                            data[srcIdx + 3] = temp[dstIdx + 3];
                        }
                    }
                }
            },
            applyTunnel(data, width, height) {
                const centerX = width / 2, centerY = height / 2;
                const maxDist = Math.min(width, height) / 2, strength = 0.8;
                const temp = new Uint8ClampedArray(data);
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const dx = x - centerX, dy = y - centerY;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        const normalizedDist = Math.min(dist / maxDist, 1);
                        const newDist = normalizedDist * (1 + strength * normalizedDist) * maxDist;
                        const angle = Math.atan2(dy, dx);
                        const newX = Math.round(centerX + newDist * Math.cos(angle));
                        const newY = Math.round(centerY + newDist * Math.sin(angle));
                        if (newX >= 0 && newX < width && newY >= 0 && newY < height) {
                            const srcIdx = (y * width + x) * 4;
                            const dstIdx = (newY * width + newX) * 4;
                            data[srcIdx] = temp[dstIdx];
                            data[srcIdx + 1] = temp[dstIdx + 1];
                            data[srcIdx + 2] = temp[dstIdx + 2];
                            data[srcIdx + 3] = temp[dstIdx + 3];
                        }
                    }
                }
            },
            applyWaterRipple(data, width, height) {
                const centerX = width / 2, centerY = height / 2;
                const frequency = 0.05, amplitude = 15;
                const temp = new Uint8ClampedArray(data);
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const dx = x - centerX, dy = y - centerY;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        const ripple = Math.sin(dist * frequency) * amplitude;
                        const angle = Math.atan2(dy, dx);
                        const newX = Math.round(x + ripple * Math.cos(angle));
                        const newY = Math.round(y + ripple * Math.sin(angle));
                        if (newX >= 0 && newX < width && newY >= 0 && newY < height) {
                            const srcIdx = (y * width + x) * 4;
                            const dstIdx = (newY * width + newX) * 4;
                            data[srcIdx] = temp[dstIdx];
                            data[srcIdx + 1] = temp[dstIdx + 1];
                            data[srcIdx + 2] = temp[dstIdx + 2];
                            data[srcIdx + 3] = temp[dstIdx + 3];
                        }
                    }
                }
            },
            applyRadialBlur(data, width, height) {
                const centerX = width / 2, centerY = height / 2;
                const maxDist = Math.min(width, height) / 2, blurStrength = 5;
                const temp = new Uint8ClampedArray(data);
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const dx = x - centerX, dy = y - centerY;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        const offset = blurStrength * (dist / maxDist);
                        const angle = Math.atan2(dy, dx);
                        const newX = Math.round(x + offset * Math.cos(angle));
                        const newY = Math.round(y + offset * Math.sin(angle));
                        if (newX >= 0 && newX < width && newY >= 0 && newY < height) {
                            const srcIdx = (y * width + x) * 4;
                            const dstIdx = (newY * width + newX) * 4;
                            data[srcIdx] = temp[dstIdx];
                            data[srcIdx + 1] = temp[dstIdx + 1];
                            data[srcIdx + 2] = temp[dstIdx + 2];
                            data[srcIdx + 3] = temp[dstIdx + 3];
                        }
                    }
                }
            },
            applyCylinder(data, width, height) {
                const centerX = width / 2;
                const strength = 0.3;
                const temp = new Uint8ClampedArray(data);
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const dx = x - centerX;
                        const newX = Math.round(centerX + dx * (1 - strength * (dx / (width / 2)) ** 2));
                        if (newX >= 0 && newX < width) {
                            const srcIdx = (y * width + x) * 4;
                            const dstIdx = (y * width + newX) * 4;
                            data[srcIdx] = temp[dstIdx];
                            data[srcIdx + 1] = temp[dstIdx + 1];
                            data[srcIdx + 2] = temp[dstIdx + 2];
                            data[srcIdx + 3] = temp[dstIdx + 3];
                        }
                    }
                }
            },
            applyBarrel(data, width, height) {
                const centerX = width / 2, centerY = height / 2;
                const radius = Math.min(width, height) / 2, strength = 0.3;
                const temp = new Uint8ClampedArray(data);
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const dx = x - centerX, dy = y - centerY;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        const normalizedDist = Math.min(dist / radius, 1);
                        const newDist = normalizedDist * (1 + strength * normalizedDist * normalizedDist) * radius;
                        const angle = Math.atan2(dy, dx);
                        const newX = Math.round(centerX + newDist * Math.cos(angle));
                        const newY = Math.round(centerY + newDist * Math.sin(angle));
                        if (newX >= 0 && newX < width && newY >= 0 && newY < height) {
                            const srcIdx = (y * width + x) * 4;
                            const dstIdx = (newY * width + newX) * 4;
                            data[srcIdx] = temp[dstIdx];
                            data[srcIdx + 1] = temp[dstIdx + 1];
                            data[srcIdx + 2] = temp[dstIdx + 2];
                            data[srcIdx + 3] = temp[dstIdx + 3];
                        }
                    }
                }
            },
            applyPincushion(data, width, height) {
                const centerX = width / 2, centerY = height / 2;
                const radius = Math.min(width, height) / 2, strength = 0.4;
                const temp = new Uint8ClampedArray(data);
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const dx = x - centerX, dy = y - centerY;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        const normalizedDist = Math.min(dist / radius, 1);
                        const newDist = normalizedDist * (1 - strength * normalizedDist) * radius;
                        const angle = Math.atan2(dy, dx);
                        const newX = Math.round(centerX + newDist * Math.cos(angle));
                        const newY = Math.round(centerY + newDist * Math.sin(angle));
                        if (newX >= 0 && newX < width && newY >= 0 && newY < height) {
                            const srcIdx = (y * width + x) * 4;
                            const dstIdx = (newY * width + newX) * 4;
                            data[srcIdx] = temp[dstIdx];
                            data[srcIdx + 1] = temp[dstIdx + 1];
                            data[srcIdx + 2] = temp[dstIdx + 2];
                            data[srcIdx + 3] = temp[dstIdx + 3];
                        }
                    }
                }
            },
            applyWhirlpool(data, width, height) {
                const centerX = width / 2, centerY = height / 2;
                const radius = Math.min(width, height) / 2, strength = 4.0;
                const temp = new Uint8ClampedArray(data);
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const dx = x - centerX, dy = y - centerY;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        const angle = Math.atan2(dy, dx);
                        const maxAngle = strength * (1 - Math.min(dist / radius, 1));
                        const newAngle = angle + maxAngle;
                        const newDist = dist * 0.9;
                        const newX = Math.round(centerX + newDist * Math.cos(newAngle));
                        const newY = Math.round(centerY + newDist * Math.sin(newAngle));
                        if (newX >= 0 && newX < width && newY >= 0 && newY < height) {
                            const srcIdx = (y * width + x) * 4;
                            const dstIdx = (newY * width + newX) * 4;
                            data[srcIdx] = temp[dstIdx];
                            data[srcIdx + 1] = temp[dstIdx + 1];
                            data[srcIdx + 2] = temp[dstIdx + 2];
                            data[srcIdx + 3] = temp[dstIdx + 3];
                        }
                    }
                }
            },
            applyRadialZoom(data, width, height) {
                const centerX = width / 2, centerY = height / 2;
                const maxDist = Math.min(width, height) / 2, zoomStrength = 0.5;
                const temp = new Uint8ClampedArray(data);
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const dx = x - centerX, dy = y - centerY;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        const zoomFactor = 1.0 + zoomStrength * (1.0 - dist / maxDist);
                        const newX = Math.round(centerX + dx / zoomFactor);
                        const newY = Math.round(centerY + dy / zoomFactor);
                        if (newX >= 0 && newX < width && newY >= 0 && newY < height) {
                            const srcIdx = (y * width + x) * 4;
                            const dstIdx = (newY * width + newX) * 4;
                            data[srcIdx] = temp[dstIdx];
                            data[srcIdx + 1] = temp[dstIdx + 1];
                            data[srcIdx + 2] = temp[dstIdx + 2];
                            data[srcIdx + 3] = temp[dstIdx + 3];
                        }
                    }
                }
            },
            applyConcave(data, width, height) {
                const centerX = width / 2, centerY = height / 2;
                const radius = Math.min(width, height) / 2, strength = 0.6;
                const temp = new Uint8ClampedArray(data);
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const dx = x - centerX, dy = y - centerY;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        const normalizedDist = Math.min(dist / radius, 1);
                        const newDist = normalizedDist * (1 - strength * normalizedDist) * radius;
                        const angle = Math.atan2(dy, dx);
                        const newX = Math.round(centerX + newDist * Math.cos(angle));
                        const newY = Math.round(centerY + newDist * Math.sin(angle));
                        if (newX >= 0 && newX < width && newY >= 0 && newY < height) {
                            const srcIdx = (y * width + x) * 4;
                            const dstIdx = (newY * width + newX) * 4;
                            data[srcIdx] = temp[dstIdx];
                            data[srcIdx + 1] = temp[dstIdx + 1];
                            data[srcIdx + 2] = temp[dstIdx + 2];
                            data[srcIdx + 3] = temp[dstIdx + 3];
                        }
                    }
                }
            },
            applyConvex(data, width, height) {
                const centerX = width / 2, centerY = height / 2;
                const radius = Math.min(width, height) / 2, strength = 0.5;
                const temp = new Uint8ClampedArray(data);
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const dx = x - centerX, dy = y - centerY;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        const normalizedDist = Math.min(dist / radius, 1);
                        const newDist = normalizedDist * (1 + strength * normalizedDist) * radius;
                        const angle = Math.atan2(dy, dx);
                        const newX = Math.round(centerX + newDist * Math.cos(angle));
                        const newY = Math.round(centerY + newDist * Math.sin(angle));
                        if (newX >= 0 && newX < width && newY >= 0 && newY < height) {
                            const srcIdx = (y * width + x) * 4;
                            const dstIdx = (newY * width + newX) * 4;
                            data[srcIdx] = temp[dstIdx];
                            data[srcIdx + 1] = temp[dstIdx + 1];
                            data[srcIdx + 2] = temp[dstIdx + 2];
                            data[srcIdx + 3] = temp[dstIdx + 3];
                        }
                    }
                }
            },
            applySpiral(data, width, height) {
                const centerX = width / 2, centerY = height / 2;
                const radius = Math.min(width, height) / 2, turns = 2.0;
                const temp = new Uint8ClampedArray(data);
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const dx = x - centerX, dy = y - centerY;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        const angle = Math.atan2(dy, dx);
                        const spiralAngle = angle + turns * Math.PI * (dist / radius);
                        const newX = Math.round(centerX + dist * Math.cos(spiralAngle));
                        const newY = Math.round(centerY + dist * Math.sin(spiralAngle));
                        if (newX >= 0 && newX < width && newY >= 0 && newY < height) {
                            const srcIdx = (y * width + x) * 4;
                            const dstIdx = (newY * width + newX) * 4;
                            data[srcIdx] = temp[dstIdx];
                            data[srcIdx + 1] = temp[dstIdx + 1];
                            data[srcIdx + 2] = temp[dstIdx + 2];
                            data[srcIdx + 3] = temp[dstIdx + 3];
                        }
                    }
                }
            },
            applyRadialStretch(data, width, height) {
                const centerX = width / 2, centerY = height / 2;
                const maxDist = Math.min(width, height) / 2;
                const temp = new Uint8ClampedArray(data);
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const dx = x - centerX, dy = y - centerY;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        const stretchFactor = 1.0 + 0.5 * (dist / maxDist);
                        const angle = Math.atan2(dy, dx);
                        const newX = Math.round(centerX + dist * stretchFactor * Math.cos(angle));
                        const newY = Math.round(centerY + dist * stretchFactor * Math.sin(angle));
                        if (newX >= 0 && newX < width && newY >= 0 && newY < height) {
                            const srcIdx = (y * width + x) * 4;
                            const dstIdx = (newY * width + newX) * 4;
                            data[srcIdx] = temp[dstIdx];
                            data[srcIdx + 1] = temp[dstIdx + 1];
                            data[srcIdx + 2] = temp[dstIdx + 2];
                            data[srcIdx + 3] = temp[dstIdx + 3];
                        }
                    }
                }
            },
            applyRadialCompress(data, width, height) {
                const centerX = width / 2, centerY = height / 2;
                const maxDist = Math.min(width, height) / 2;
                const temp = new Uint8ClampedArray(data);
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const dx = x - centerX, dy = y - centerY;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        const compressFactor = 1.0 - 0.3 * (dist / maxDist);
                        const angle = Math.atan2(dy, dx);
                        const newX = Math.round(centerX + dist * compressFactor * Math.cos(angle));
                        const newY = Math.round(centerY + dist * compressFactor * Math.sin(angle));
                        if (newX >= 0 && newX < width && newY >= 0 && newY < height) {
                            const srcIdx = (y * width + x) * 4;
                            const dstIdx = (newY * width + newX) * 4;
                            data[srcIdx] = temp[dstIdx];
                            data[srcIdx + 1] = temp[dstIdx + 1];
                            data[srcIdx + 2] = temp[dstIdx + 2];
                            data[srcIdx + 3] = temp[dstIdx + 3];
                        }
                    }
                }
            },
            applyVerticalWave(data, width, height) {
                const centerX = width / 2;
                const amplitude = 25, frequency = 0.05;
                const temp = new Uint8ClampedArray(data);
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const offset = Math.sin((x - centerX) * frequency) * amplitude;
                        const newY = Math.round(y + offset);
                        if (newY >= 0 && newY < height) {
                            const srcIdx = (y * width + x) * 4;
                            const dstIdx = (newY * width + x) * 4;
                            data[srcIdx] = temp[dstIdx];
                            data[srcIdx + 1] = temp[dstIdx + 1];
                            data[srcIdx + 2] = temp[dstIdx + 2];
                            data[srcIdx + 3] = temp[dstIdx + 3];
                        }
                    }
                }
            },
            applyHorizontalWave(data, width, height) {
                const centerY = height / 2;
                const amplitude = 25, frequency = 0.05;
                const temp = new Uint8ClampedArray(data);
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const offset = Math.sin((y - centerY) * frequency) * amplitude;
                        const newX = Math.round(x + offset);
                        if (newX >= 0 && newX < width) {
                            const srcIdx = (y * width + x) * 4;
                            const dstIdx = (y * width + newX) * 4;
                            data[srcIdx] = temp[dstIdx];
                            data[srcIdx + 1] = temp[dstIdx + 1];
                            data[srcIdx + 2] = temp[dstIdx + 2];
                            data[srcIdx + 3] = temp[dstIdx + 3];
                        }
                    }
                }
            },
            applySkewHorizontal(data, width, height) {
                const centerY = height / 2, strength = 0.3;
                const temp = new Uint8ClampedArray(data);
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const offset = (y - centerY) * strength;
                        const newX = Math.round(x + offset);
                        if (newX >= 0 && newX < width) {
                            const srcIdx = (y * width + x) * 4;
                            const dstIdx = (y * width + newX) * 4;
                            data[srcIdx] = temp[dstIdx];
                            data[srcIdx + 1] = temp[dstIdx + 1];
                            data[srcIdx + 2] = temp[dstIdx + 2];
                            data[srcIdx + 3] = temp[dstIdx + 3];
                        }
                    }
                }
            },
            applySkewVertical(data, width, height) {
                const centerX = width / 2, strength = 0.3;
                const temp = new Uint8ClampedArray(data);
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const offset = (x - centerX) * strength;
                        const newY = Math.round(y + offset);
                        if (newY >= 0 && newY < height) {
                            const srcIdx = (y * width + x) * 4;
                            const dstIdx = (newY * width + x) * 4;
                            data[srcIdx] = temp[dstIdx];
                            data[srcIdx + 1] = temp[dstIdx + 1];
                            data[srcIdx + 2] = temp[dstIdx + 2];
                            data[srcIdx + 3] = temp[dstIdx + 3];
                        }
                    }
                }
            },
            applyRotateZoom(data, width, height) {
                const centerX = width / 2, centerY = height / 2;
                const maxDist = Math.min(width, height) / 2;
                const temp = new Uint8ClampedArray(data);
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const dx = x - centerX, dy = y - centerY;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        const angle = Math.atan2(dy, dx);
                        const rotation = 2.0 * Math.PI * (dist / maxDist);
                        const zoomFactor = 1.0 + 0.3 * (dist / maxDist);
                        const newAngle = angle + rotation;
                        const newDist = dist / zoomFactor;
                        const newX = Math.round(centerX + newDist * Math.cos(newAngle));
                        const newY = Math.round(centerY + newDist * Math.sin(newAngle));
                        if (newX >= 0 && newX < width && newY >= 0 && newY < height) {
                            const srcIdx = (y * width + x) * 4;
                            const dstIdx = (newY * width + newX) * 4;
                            data[srcIdx] = temp[dstIdx];
                            data[srcIdx + 1] = temp[dstIdx + 1];
                            data[srcIdx + 2] = temp[dstIdx + 2];
                            data[srcIdx + 3] = temp[dstIdx + 3];
                        }
                    }
                }
            },
            applyRadialWave(data, width, height) {
                const centerX = width / 2, centerY = height / 2;
                const frequency = 0.1, amplitude = 15;
                const temp = new Uint8ClampedArray(data);
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const dx = x - centerX, dy = y - centerY;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        const angle = Math.atan2(dy, dx);
                        const radialWave = Math.sin(dist * frequency) * amplitude;
                        const newAngle = angle + radialWave / Math.max(dist, 1);
                        const newX = Math.round(centerX + dist * Math.cos(newAngle));
                        const newY = Math.round(centerY + dist * Math.sin(newAngle));
                        if (newX >= 0 && newX < width && newY >= 0 && newY < height) {
                            const srcIdx = (y * width + x) * 4;
                            const dstIdx = (newY * width + newX) * 4;
                            data[srcIdx] = temp[dstIdx];
                            data[srcIdx + 1] = temp[dstIdx + 1];
                            data[srcIdx + 2] = temp[dstIdx + 2];
                            data[srcIdx + 3] = temp[dstIdx + 3];
                        }
                    }
                }
            },
            applyZoomIn(data, width, height) {
                const centerX = width / 2, centerY = height / 2;
                const zoomFactor = 1.3;
                const temp = new Uint8ClampedArray(data);
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const dx = x - centerX, dy = y - centerY;
                        const newX = Math.round(centerX + dx / zoomFactor);
                        const newY = Math.round(centerY + dy / zoomFactor);
                        if (newX >= 0 && newX < width && newY >= 0 && newY < height) {
                            const srcIdx = (y * width + x) * 4;
                            const dstIdx = (newY * width + newX) * 4;
                            data[srcIdx] = temp[dstIdx];
                            data[srcIdx + 1] = temp[dstIdx + 1];
                            data[srcIdx + 2] = temp[dstIdx + 2];
                            data[srcIdx + 3] = temp[dstIdx + 3];
                        }
                    }
                }
            },
            applyZoomOut(data, width, height) {
                const centerX = width / 2, centerY = height / 2;
                const zoomFactor = 0.8;
                const temp = new Uint8ClampedArray(data);
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const dx = x - centerX, dy = y - centerY;
                        const newX = Math.round(centerX + dx / zoomFactor);
                        const newY = Math.round(centerY + dy / zoomFactor);
                        if (newX >= 0 && newX < width && newY >= 0 && newY < height) {
                            const srcIdx = (y * width + x) * 4;
                            const dstIdx = (newY * width + newX) * 4;
                            data[srcIdx] = temp[dstIdx];
                            data[srcIdx + 1] = temp[dstIdx + 1];
                            data[srcIdx + 2] = temp[dstIdx + 2];
                            data[srcIdx + 3] = temp[dstIdx + 3];
                        }
                    }
                }
            },
            applyRotate(data, width, height) {
                const centerX = width / 2, centerY = height / 2;
                const rotationAngle = Math.PI / 4;
                const cosA = Math.cos(rotationAngle);
                const sinA = Math.sin(rotationAngle);
                const temp = new Uint8ClampedArray(data);
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const dx = x - centerX, dy = y - centerY;
                        const newX = Math.round(centerX + dx * cosA - dy * sinA);
                        const newY = Math.round(centerY + dx * sinA + dy * cosA);
                        if (newX >= 0 && newX < width && newY >= 0 && newY < height) {
                            const srcIdx = (y * width + x) * 4;
                            const dstIdx = (newY * width + newX) * 4;
                            data[srcIdx] = temp[dstIdx];
                            data[srcIdx + 1] = temp[dstIdx + 1];
                            data[srcIdx + 2] = temp[dstIdx + 2];
                            data[srcIdx + 3] = temp[dstIdx + 3];
                        }
                    }
                }
            },
            applyRotate45(data, width, height) {
                this.applyRotate(data, width, height);
            },
            applyFlipBoth(data, width, height) {
                this.applyFlipHorizontal(data, width, height);
                this.applyFlipVertical(data, width, height);
            },
            applyQuadMirror(data, width, height) {
                const h = height / 2, w = width / 2;
                for (let y = 0; y < h; y++) {
                    for (let x = 0; x < w; x++) {
                        const srcIdx = (y * width + x) * 4;
                        // Top-right
                        const trIdx = (y * width + (width - x - 1)) * 4;
                        data[trIdx] = data[srcIdx];
                        data[trIdx + 1] = data[srcIdx + 1];
                        data[trIdx + 2] = data[srcIdx + 2];
                        data[trIdx + 3] = data[srcIdx + 3];
                        // Bottom-left
                        const blIdx = ((height - y - 1) * width + x) * 4;
                        data[blIdx] = data[srcIdx];
                        data[blIdx + 1] = data[srcIdx + 1];
                        data[blIdx + 2] = data[srcIdx + 2];
                        data[blIdx + 3] = data[srcIdx + 3];
                        // Bottom-right
                        const brIdx = ((height - y - 1) * width + (width - x - 1)) * 4;
                        data[brIdx] = data[srcIdx];
                        data[brIdx + 1] = data[srcIdx + 1];
                        data[brIdx + 2] = data[srcIdx + 2];
                        data[brIdx + 3] = data[srcIdx + 3];
                    }
                }
            },
            applyTile(data, width, height) {
                const smallW = width / 4, smallH = height / 4;
                const temp = new Uint8ClampedArray(data);
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const srcX = x % smallW;
                        const srcY = y % smallH;
                        const srcIdx = (Math.floor(srcY) * width + Math.floor(srcX)) * 4;
                        const dstIdx = (y * width + x) * 4;
                        data[dstIdx] = temp[srcIdx];
                        data[dstIdx + 1] = temp[srcIdx + 1];
                        data[dstIdx + 2] = temp[srcIdx + 2];
                        data[dstIdx + 3] = temp[srcIdx + 3];
                    }
                }
            },
            applyRadialTile(data, width, height) {
                const smallW = width / 3, smallH = height / 3;
                const temp = new Uint8ClampedArray(data);
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const srcX = (x % smallW) + Math.floor(x / smallW) * smallW;
                        const srcY = (y % smallH) + Math.floor(y / smallH) * smallH;
                        const srcIdx = (Math.floor(srcY) * width + Math.floor(srcX)) * 4;
                        const dstIdx = (y * width + x) * 4;
                        if (srcIdx < data.length && dstIdx < data.length) {
                            data[dstIdx] = temp[srcIdx];
                            data[dstIdx + 1] = temp[srcIdx + 1];
                            data[dstIdx + 2] = temp[srcIdx + 2];
                            data[dstIdx + 3] = temp[srcIdx + 3];
                        }
                    }
                }
            },
            applyZoomBlur(data, width, height) {
                const centerX = width / 2, centerY = height / 2;
                const maxDist = Math.min(width, height) / 2;
                const temp = new Uint8ClampedArray(data);
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const dx = x - centerX, dy = y - centerY;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        const zoomFactor = 1.0 + (dist / maxDist) * 0.3;
                        const newX = Math.round(centerX + dx / zoomFactor);
                        const newY = Math.round(centerY + dy / zoomFactor);
                        if (newX >= 0 && newX < width && newY >= 0 && newY < height) {
                            const srcIdx = (y * width + x) * 4;
                            const dstIdx = (newY * width + newX) * 4;
                            data[srcIdx] = temp[dstIdx];
                            data[srcIdx + 1] = temp[dstIdx + 1];
                            data[srcIdx + 2] = temp[dstIdx + 2];
                            data[srcIdx + 3] = temp[dstIdx + 3];
                        }
                    }
                }
            },
            applyMelt(data, width, height) {
                const strength = 30;
                const temp = new Uint8ClampedArray(data);
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const offset = Math.sin(x * 0.05) * strength;
                        const newY = Math.round(y + offset);
                        if (newY >= 0 && newY < height) {
                            const srcIdx = (y * width + x) * 4;
                            const dstIdx = (newY * width + x) * 4;
                            data[srcIdx] = temp[dstIdx];
                            data[srcIdx + 1] = temp[dstIdx + 1];
                            data[srcIdx + 2] = temp[dstIdx + 2];
                            data[srcIdx + 3] = temp[dstIdx + 3];
                        }
                    }
                }
            },
            applyKaleidoscope(data, width, height) {
                const h = height / 2, w = width / 2;
                const temp = new Uint8ClampedArray(data);
                // Copy top-left quadrant to all quadrants
                for (let y = 0; y < h; y++) {
                    for (let x = 0; x < w; x++) {
                        const srcIdx = (y * width + x) * 4;
                        // Top-right (flipped horizontally)
                        const trIdx = (y * width + (width - x - 1)) * 4;
                        data[trIdx] = temp[srcIdx];
                        data[trIdx + 1] = temp[srcIdx + 1];
                        data[trIdx + 2] = temp[srcIdx + 2];
                        data[trIdx + 3] = temp[srcIdx + 3];
                        // Bottom-left (flipped vertically)
                        const blIdx = ((height - y - 1) * width + x) * 4;
                        data[blIdx] = temp[srcIdx];
                        data[blIdx + 1] = temp[srcIdx + 1];
                        data[blIdx + 2] = temp[srcIdx + 2];
                        data[blIdx + 3] = temp[srcIdx + 3];
                        // Bottom-right (flipped both)
                        const brIdx = ((height - y - 1) * width + (width - x - 1)) * 4;
                        data[brIdx] = temp[srcIdx];
                        data[brIdx + 1] = temp[srcIdx + 1];
                        data[brIdx + 2] = temp[srcIdx + 2];
                        data[brIdx + 3] = temp[srcIdx + 3];
                    }
                }
            },
            applyGlitch(data, width, height) {
                for (let y = 0; y < height; y += 20) {
                    const offset = Math.random() * 20 - 10;
                    for (let x = 0; x < width; x++) {
                        const newX = Math.round(x + offset);
                        if (newX >= 0 && newX < width && y + 10 < height) {
                            const srcIdx = ((y + 10) * width + x) * 4;
                            const dstIdx = (y * width + newX) * 4;
                            if (dstIdx < data.length && srcIdx < data.length) {
                                data[dstIdx] = data[srcIdx];
                                data[dstIdx + 1] = data[srcIdx + 1];
                                data[dstIdx + 2] = data[srcIdx + 2];
                            }
                        }
                    }
                }
            },
            applyDoubleVision(data, width, height) {
                const temp = new Uint8ClampedArray(data);
                const offset = 10;
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const idx = (y * width + x) * 4;
                        const shiftedX = x + offset;
                        if (shiftedX < width) {
                            const shiftedIdx = (y * width + shiftedX) * 4;
                            data[idx] = Math.min(255, (temp[idx] + temp[shiftedIdx]) / 2);
                            data[idx + 1] = Math.min(255, (temp[idx + 1] + temp[shiftedIdx + 1]) / 2);
                            data[idx + 2] = Math.min(255, (temp[idx + 2] + temp[shiftedIdx + 2]) / 2);
                        }
                    }
                }
            },
            applyFastZoomIn(data, width, height, frameCount) {
                const centerX = width / 2, centerY = height / 2;
                const fps = 30;
                const animationSpeed = 2.0;
                const zoomFactor = 1.0 + (frameCount / fps * animationSpeed) % 2.0;
                const temp = new Uint8ClampedArray(data);
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const dx = x - centerX, dy = y - centerY;
                        const newX = Math.round(centerX + dx / zoomFactor);
                        const newY = Math.round(centerY + dy / zoomFactor);
                        if (newX >= 0 && newX < width && newY >= 0 && newY < height) {
                            const srcIdx = (y * width + x) * 4;
                            const dstIdx = (newY * width + newX) * 4;
                            data[srcIdx] = temp[dstIdx];
                            data[srcIdx + 1] = temp[dstIdx + 1];
                            data[srcIdx + 2] = temp[dstIdx + 2];
                            data[srcIdx + 3] = temp[dstIdx + 3];
                        }
                    }
                }
            },
            applyFastZoomOut(data, width, height, frameCount) {
                const centerX = width / 2, centerY = height / 2;
                const fps = 30;
                const animationSpeed = 2.0;
                let zoomFactor = 1.5 - (frameCount / fps * animationSpeed) % 1.0;
                zoomFactor = Math.max(0.5, zoomFactor);
                const temp = new Uint8ClampedArray(data);
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const dx = x - centerX, dy = y - centerY;
                        const newX = Math.round(centerX + dx / zoomFactor);
                        const newY = Math.round(centerY + dy / zoomFactor);
                        if (newX >= 0 && newX < width && newY >= 0 && newY < height) {
                            const srcIdx = (y * width + x) * 4;
                            const dstIdx = (newY * width + newX) * 4;
                            data[srcIdx] = temp[dstIdx];
                            data[srcIdx + 1] = temp[dstIdx + 1];
                            data[srcIdx + 2] = temp[dstIdx + 2];
                            data[srcIdx + 3] = temp[dstIdx + 3];
                        }
                    }
                }
            },
            applyShake(data, width, height, frameCount) {
                const fps = 30;
                const animationSpeed = 20.0;
                const shakeAmount = 15;
                const offsetX = Math.sin(frameCount / fps * animationSpeed * 2 * Math.PI) * shakeAmount;
                const offsetY = Math.cos(frameCount / fps * animationSpeed * 2 * Math.PI) * shakeAmount;
                const temp = new Uint8ClampedArray(data);
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const newX = Math.round(x + offsetX);
                        const newY = Math.round(y + offsetY);
                        if (newX >= 0 && newX < width && newY >= 0 && newY < height) {
                            const srcIdx = (y * width + x) * 4;
                            const dstIdx = (newY * width + newX) * 4;
                            data[srcIdx] = temp[dstIdx];
                            data[srcIdx + 1] = temp[dstIdx + 1];
                            data[srcIdx + 2] = temp[dstIdx + 2];
                            data[srcIdx + 3] = temp[dstIdx + 3];
                        }
                    }
                }
            },
            applyPulse(data, width, height, frameCount) {
                const centerX = width / 2, centerY = height / 2;
                const fps = 30;
                const animationSpeed = 3.0;
                const animationCycle = (frameCount / fps * animationSpeed * 2 * Math.PI) % (2 * Math.PI);
                const zoomFactor = 1.0 + 0.15 * Math.sin(animationCycle);
                const temp = new Uint8ClampedArray(data);
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const dx = x - centerX, dy = y - centerY;
                        const newX = Math.round(centerX + dx / zoomFactor);
                        const newY = Math.round(centerY + dy / zoomFactor);
                        if (newX >= 0 && newX < width && newY >= 0 && newY < height) {
                            const srcIdx = (y * width + x) * 4;
                            const dstIdx = (newY * width + newX) * 4;
                            data[srcIdx] = temp[dstIdx];
                            data[srcIdx + 1] = temp[dstIdx + 1];
                            data[srcIdx + 2] = temp[dstIdx + 2];
                            data[srcIdx + 3] = temp[dstIdx + 3];
                        }
                    }
                }
            },
            applySpiralZoom(data, width, height, frameCount) {
                const centerX = width / 2, centerY = height / 2;
                const fps = 30;
                const animationSpeed = 2.0;
                const animationCycle = (frameCount / fps * animationSpeed * 2 * Math.PI) % (2 * Math.PI);
                const maxDist = Math.sqrt(centerX * centerX + centerY * centerY);
                const temp = new Uint8ClampedArray(data);
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const dx = x - centerX, dy = y - centerY;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        const angle = Math.atan2(dy, dx);
                        const zoomFactor = 1.0 + 0.3 * Math.sin(dist / maxDist * 4 * Math.PI + animationCycle);
                        const newAngle = angle + animationCycle * 0.5;
                        const newDist = dist / zoomFactor;
                        const newX = Math.round(centerX + newDist * Math.cos(newAngle));
                        const newY = Math.round(centerY + newDist * Math.sin(newAngle));
                        if (newX >= 0 && newX < width && newY >= 0 && newY < height) {
                            const srcIdx = (y * width + x) * 4;
                            const dstIdx = (newY * width + newX) * 4;
                            data[srcIdx] = temp[dstIdx];
                            data[srcIdx + 1] = temp[dstIdx + 1];
                            data[srcIdx + 2] = temp[dstIdx + 2];
                            data[srcIdx + 3] = temp[dstIdx + 3];
                        }
                    }
                }
            },
            applyExtremeCloseup(data, width, height, frameCount) {
                const centerX = width / 2, centerY = height / 2;
                const fps = 30;
                const animationSpeed = 1.5;
                const animationCycle = (frameCount / fps * animationSpeed * 2 * Math.PI) % (2 * Math.PI);
                let zoomFactor = 1.0 + 2.5 * (0.5 + 0.5 * Math.sin(animationCycle));
                zoomFactor = Math.max(1.0, Math.min(zoomFactor, 4.0));
                const temp = new Uint8ClampedArray(data);
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const dx = x - centerX, dy = y - centerY;
                        const newX = Math.round(centerX + dx / zoomFactor);
                        const newY = Math.round(centerY + dy / zoomFactor);
                        if (newX >= 0 && newX < width && newY >= 0 && newY < height) {
                            const srcIdx = (y * width + x) * 4;
                            const dstIdx = (newY * width + newX) * 4;
                            data[srcIdx] = temp[dstIdx];
                            data[srcIdx + 1] = temp[dstIdx + 1];
                            data[srcIdx + 2] = temp[dstIdx + 2];
                            data[srcIdx + 3] = temp[dstIdx + 3];
                        }
                    }
                }
            },
            applyPuzzle(data, width, height) {
                // Simplified puzzle effect - just shuffle blocks
                const cols = 10, rows = 8;
                const pieceW = width / cols, pieceH = height / rows;
                const temp = new Uint8ClampedArray(data);
                const pieces = [];
                for (let row = 0; row < rows; row++) {
                    for (let col = 0; col < cols; col++) {
                        pieces.push({row, col, targetRow: (row + 2) % rows, targetCol: (col + 3) % cols});
                    }
                }
                for (const piece of pieces) {
                    for (let y = 0; y < pieceH && piece.row * pieceH + y < height; y++) {
                        for (let x = 0; x < pieceW && piece.col * pieceW + x < width; x++) {
                            const srcY = piece.row * pieceH + y;
                            const srcX = piece.col * pieceW + x;
                            const dstY = piece.targetRow * pieceH + y;
                            const dstX = piece.targetCol * pieceW + x;
                            if (dstY < height && dstX < width) {
                                const srcIdx = (srcY * width + srcX) * 4;
                                const dstIdx = (dstY * width + dstX) * 4;
                                data[dstIdx] = temp[srcIdx];
                                data[dstIdx + 1] = temp[srcIdx + 1];
                                data[dstIdx + 2] = temp[srcIdx + 2];
                                data[dstIdx + 3] = temp[srcIdx + 3];
                            }
                        }
                    }
                }
            }
        };
        
        // JavaScript filter fallback
        function applyJSFilter(imageData, filterType, faceRect) {
            const data = imageData.data;
            const width = imageData.width;
            const height = imageData.height;
            
            // Map filter names to implementations
            const filterMap = {
                'black_white': () => FilterImplementations.applyBlackWhite(data),
                'sepia': () => FilterImplementations.applySepia(data),
                'negative': () => FilterImplementations.applyNegative(data),
                'vintage': () => FilterImplementations.applyVintage(data),
                'neon_glow': () => FilterImplementations.applyNeonGlow(data),
                'red_tint': () => FilterImplementations.applyRedTint(data),
                'blue_tint': () => FilterImplementations.applyBlueTint(data),
                'green_tint': () => FilterImplementations.applyGreenTint(data),
                'posterize': () => FilterImplementations.applyPosterize(data),
                'thermal': () => FilterImplementations.applyThermal(data),
                'pixelate': () => FilterImplementations.applyPixelate(data, width, height),
                'bulge': () => FilterImplementations.applyBulge(data, width, height),
                'swirl': () => FilterImplementations.applySwirl(data, width, height),
                'stretch': () => FilterImplementations.applyStretch(data, width, height),
                'fisheye': () => FilterImplementations.applyFisheye(data, width, height),
                'pinch': () => FilterImplementations.applyPinch(data, width, height),
                'wave': () => FilterImplementations.applyWave(data, width, height),
                'mirror': () => FilterImplementations.applyMirror(data, width, height),
                'flip_horizontal': () => FilterImplementations.applyFlipHorizontal(data, width, height),
                'flip_vertical': () => FilterImplementations.applyFlipVertical(data, width, height),
                'flip_both': () => FilterImplementations.applyFlipBoth(data, width, height),
                'rotate': () => FilterImplementations.applyRotate(data, width, height),
                'rotate_45': () => FilterImplementations.applyRotate45(data, width, height),
                'rotate_90': () => FilterImplementations.applyRotate90(data, width, height),
                'blur': () => FilterImplementations.applyBlur(data, width, height),
                'sharpen': () => FilterImplementations.applySharpen(data, width, height),
                'emboss': () => FilterImplementations.applyEmboss(data, width, height),
                'sketch': () => FilterImplementations.applySketch(data, width, height),
                'cartoon': () => FilterImplementations.applyCartoon(data, width, height),
                'rainbow': () => FilterImplementations.applyRainbow(data, width, height),
                'rainbow_shift': () => FilterImplementations.applyRainbowShift(data),
                'ice': () => FilterImplementations.applyIce(data),
                'ocean': () => FilterImplementations.applyOcean(data),
                'plasma': () => FilterImplementations.applyPlasma(data),
                'jet': () => FilterImplementations.applyJet(data),
                'turbo': () => FilterImplementations.applyTurbo(data),
                'inferno': () => FilterImplementations.applyInferno(data),
                'magma': () => FilterImplementations.applyMagma(data),
                'viridis': () => FilterImplementations.applyViridis(data),
                'cool': () => FilterImplementations.applyCool(data),
                'hot': () => FilterImplementations.applyHot(data),
                'spring': () => FilterImplementations.applySpring(data),
                'summer': () => FilterImplementations.applySummer(data),
                'autumn': () => FilterImplementations.applyAutumn(data),
                'winter': () => FilterImplementations.applyWinter(data),
                'vhs': () => FilterImplementations.applyVHS(data, width, height),
                'retro': () => FilterImplementations.applyRetro(data, width, height),
                'cyberpunk': () => FilterImplementations.applyCyberpunk(data, width, height),
                'anime': () => FilterImplementations.applyAnime(data, width, height),
                'glow': () => FilterImplementations.applyGlow(data, width, height),
                'solarize': () => FilterImplementations.applySolarize(data),
                'edge_detect': () => FilterImplementations.applyEdgeDetect(data, width, height),
                'halftone': () => FilterImplementations.applyHalftone(data, width, height),
                'acid_trip': () => FilterImplementations.applyAcidTrip(data, width, height),
                'twirl': () => FilterImplementations.applyTwirl(data, width, height),
                'ripple': () => FilterImplementations.applyRipple(data, width, height),
                'sphere': () => FilterImplementations.applySphere(data, width, height),
                'tunnel': () => FilterImplementations.applyTunnel(data, width, height),
                'water_ripple': () => FilterImplementations.applyWaterRipple(data, width, height),
                'radial_blur': () => FilterImplementations.applyRadialBlur(data, width, height),
                'cylinder': () => FilterImplementations.applyCylinder(data, width, height),
                'barrel': () => FilterImplementations.applyBarrel(data, width, height),
                'pincushion': () => FilterImplementations.applyPincushion(data, width, height),
                'whirlpool': () => FilterImplementations.applyWhirlpool(data, width, height),
                'radial_zoom': () => FilterImplementations.applyRadialZoom(data, width, height),
                'concave': () => FilterImplementations.applyConcave(data, width, height),
                'convex': () => FilterImplementations.applyConvex(data, width, height),
                'spiral': () => FilterImplementations.applySpiral(data, width, height),
                'radial_stretch': () => FilterImplementations.applyRadialStretch(data, width, height),
                'radial_compress': () => FilterImplementations.applyRadialCompress(data, width, height),
                'vertical_wave': () => FilterImplementations.applyVerticalWave(data, width, height),
                'horizontal_wave': () => FilterImplementations.applyHorizontalWave(data, width, height),
                'skew_horizontal': () => FilterImplementations.applySkewHorizontal(data, width, height),
                'skew_vertical': () => FilterImplementations.applySkewVertical(data, width, height),
                'rotate_zoom': () => FilterImplementations.applyRotateZoom(data, width, height),
                'radial_wave': () => FilterImplementations.applyRadialWave(data, width, height),
                'zoom_in': () => FilterImplementations.applyZoomIn(data, width, height),
                'zoom_out': () => FilterImplementations.applyZoomOut(data, width, height),
                'fast_zoom_in': () => FilterImplementations.applyFastZoomIn(data, width, height, frameCount),
                'fast_zoom_out': () => FilterImplementations.applyFastZoomOut(data, width, height, frameCount),
                'shake': () => FilterImplementations.applyShake(data, width, height, frameCount),
                'pulse': () => FilterImplementations.applyPulse(data, width, height, frameCount),
                'spiral_zoom': () => FilterImplementations.applySpiralZoom(data, width, height, frameCount),
                'extreme_closeup': () => FilterImplementations.applyExtremeCloseup(data, width, height, frameCount),
                'puzzle': () => FilterImplementations.applyPuzzle(data, width, height),
                'quad_mirror': () => FilterImplementations.applyQuadMirror(data, width, height),
                'tile': () => FilterImplementations.applyTile(data, width, height),
                'radial_tile': () => FilterImplementations.applyRadialTile(data, width, height),
                'zoom_blur': () => FilterImplementations.applyZoomBlur(data, width, height),
                'melt': () => FilterImplementations.applyMelt(data, width, height),
                'kaleidoscope': () => FilterImplementations.applyKaleidoscope(data, width, height),
                'glitch': () => FilterImplementations.applyGlitch(data, width, height),
                'double_vision': () => FilterImplementations.applyDoubleVision(data, width, height)
            };
            
            const filterFunc = filterMap[filterType];
            if (filterFunc) {
                try {
                    filterFunc();
                } catch (error) {
                    console.error(`Error applying filter "${filterType}":`, error);
                }
            } else {
                console.warn(`Filter "${filterType}" not yet implemented in JS fallback`);
            }
        }
        
        // Start camera
        async function startCamera() {
            try {
                const deviceId = cameraSelect.value;
                
                // Load saved facing mode preference
                const savedFacingMode = localStorage.getItem('wesworld-fx-camera-facing');
                if (savedFacingMode && (savedFacingMode === 'user' || savedFacingMode === 'environment')) {
                    currentFacingMode = savedFacingMode;
                }
                
                const constraints = {
                    video: {
                        deviceId: deviceId ? { exact: deviceId } : undefined,
                        width: { ideal: 1280 },
                        height: { ideal: 720 }
                    }
                };
                
                // Use facingMode on mobile if no specific device is selected
                if (isMobileDevice() && !deviceId) {
                    constraints.video.facingMode = currentFacingMode;
                }
                
                localStream = await navigator.mediaDevices.getUserMedia(constraints);
                
                // Ensure video element has required attributes for mobile Safari
                videoInput.setAttribute('autoplay', '');
                videoInput.setAttribute('playsinline', '');
                videoInput.setAttribute('muted', '');
                
                // Stop any existing stream tracks before setting new one
                if (videoInput.srcObject) {
                    const oldStream = videoInput.srcObject;
                    oldStream.getTracks().forEach(track => track.stop());
                }
                
                videoInput.srcObject = localStream;
                
                // Force play immediately on mobile Safari
                let playAttempts = 0;
                const maxPlayAttempts = 5;
                const tryPlay = async () => {
                    try {
                        await videoInput.play();
                        console.log('Video play successful');
                    } catch (playError) {
                        playAttempts++;
                        if (playAttempts < maxPlayAttempts) {
                            console.warn(`Video play() attempt ${playAttempts} failed, retrying:`, playError);
                            setTimeout(tryPlay, 100 * playAttempts);
                        } else {
                            console.warn('Video play() failed after max attempts:', playError);
                        }
                    }
                };
                await tryPlay();
                
                if (deviceId) {
                    localStorage.setItem('wesworld-fx-camera', deviceId);
                }
                localStorage.setItem('wesworld-fx-camera-active', 'true');
                // Remember that user has started camera - enable auto-start on future page loads
                localStorage.setItem('wesworld-fx-camera-auto-start', 'true');
                
                // Multiple event handlers for better Safari mobile compatibility
                let isInitialized = false;
                const initializeVideo = () => {
                    if (isInitialized) return;
                    
                    if (videoInput.readyState >= 2 && videoInput.videoWidth > 0 && videoInput.videoHeight > 0) {
                        isInitialized = true;
                        
                        canvasOutput.width = videoInput.videoWidth;
                        canvasOutput.height = videoInput.videoHeight;
                        
                        // Ensure video is playing
                        if (videoInput.paused) {
                            videoInput.play().catch(err => console.warn('Play failed in initializeVideo:', err));
                        }
                        
                        // Start processing loop
                        if (!animationFrameId) {
                            processVideoFrame();
                        }
                        
                        updateStatus('Camera active', 'connected');
                        if (cameraStatusText) {
                            cameraStatusText.textContent = 'Camera: Active';
                            cameraStatusText.parentElement.className = 'camera-status connected';
                        }
                        startButton.style.display = 'none';
                        stopButton.style.display = 'block';
                        
                        // Collapse settings when camera is active
                        const settingsSection = document.querySelector('.settings-section');
                        const settingsToggle = document.getElementById('settingsToggle');
                        if (settingsSection && settingsToggle) {
                            settingsSection.classList.remove('expanded');
                            settingsToggle.classList.remove('expanded');
                        }
                    }
                };
                
                // Handle loadedmetadata
                videoInput.onloadedmetadata = () => {
                    console.log('Video metadata loaded');
                    initializeVideo();
                };
                
                // Handle loadeddata (fires earlier than loadedmetadata on some browsers)
                videoInput.addEventListener('loadeddata', () => {
                    console.log('Video data loaded');
                    initializeVideo();
                }, { once: true });
                
                // Handle canplay
                videoInput.addEventListener('canplay', () => {
                    console.log('Video can play');
                    initializeVideo();
                }, { once: true });
                
                // Handle playing event
                videoInput.addEventListener('playing', () => {
                    console.log('Video is playing');
                    initializeVideo();
                }, { once: true });
                
                // Fallback: check periodically if not initialized (for Safari mobile)
                let checkCount = 0;
                const maxChecks = 50; // 5 seconds max
                const checkInterval = setInterval(() => {
                    checkCount++;
                    if (isInitialized) {
                        clearInterval(checkInterval);
                    } else if (checkCount >= maxChecks) {
                        clearInterval(checkInterval);
                        // Force initialization even if dimensions aren't ready
                        if (!isInitialized && videoInput.readyState >= 1) {
                            console.warn('Forcing video initialization after timeout');
                            canvasOutput.width = videoInput.videoWidth || 640;
                            canvasOutput.height = videoInput.videoHeight || 480;
                            isInitialized = true;
                            if (!animationFrameId) {
                                processVideoFrame();
                            }
                            updateStatus('Camera active', 'connected');
                            if (cameraStatusText) {
                                cameraStatusText.textContent = 'Camera: Active';
                                cameraStatusText.parentElement.className = 'camera-status connected';
                            }
                            startButton.style.display = 'none';
                            stopButton.style.display = 'block';
                        }
                    } else {
                        initializeVideo();
                    }
                }, 100);
                
            } catch (error) {
                console.error('Error starting camera:', error);
                updateStatus('Camera error: ' + error.message, 'error');
                localStorage.setItem('wesworld-fx-camera-active', 'false');
            }
        }
        
        // Stop camera
        function stopCamera() {
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
                localStream = null;
            }
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
            videoInput.srcObject = null;
            ctx.clearRect(0, 0, canvasOutput.width, canvasOutput.height);
            startButton.style.display = 'block';
            stopButton.style.display = 'none';
            updateStatus('Camera stopped', '');
            if (cameraStatusText) {
                cameraStatusText.textContent = 'Camera: Stopped';
                cameraStatusText.parentElement.className = 'camera-status stopped';
            }
            localStorage.setItem('wesworld-fx-camera-active', 'false');
            
            // Expand settings and show start button when camera is stopped
            const settingsSection = document.querySelector('.settings-section');
            const settingsToggle = document.getElementById('settingsToggle');
            if (settingsSection && settingsToggle) {
                settingsSection.classList.add('expanded');
                settingsToggle.classList.add('expanded');
            }
            startButton.style.display = 'block';
            stopButton.style.display = 'none';
        }
        
        // Toggle UI
        function toggleUI() {
            controlsVisible = !controlsVisible;
            if (controlsVisible) {
                controls.classList.add('visible');
                controls.classList.remove('hidden');
            } else {
                controls.classList.add('hidden');
                controls.classList.remove('visible');
            }
        }
        
        // Tutorial functions
        function showTutorial() {
            const tutorialModal = document.getElementById('tutorialModal');
            if (tutorialModal) {
                tutorialModal.setAttribute('aria-hidden', 'false');
                tutorialModal.style.display = 'flex';
                // Focus the close button for accessibility
                const closeButton = document.getElementById('tutorialClose');
                if (closeButton) {
                    setTimeout(() => closeButton.focus(), 100);
                }
            }
        }
        
        function hideTutorial() {
            const tutorialModal = document.getElementById('tutorialModal');
            if (tutorialModal) {
                tutorialModal.setAttribute('aria-hidden', 'true');
                tutorialModal.style.display = 'none';
            }
        }
        
        function checkAndShowTutorial() {
            // Check if tutorial has been shown before
            const tutorialShown = localStorage.getItem('wesworld-fx-tutorial-shown');
            const dontShowAgain = localStorage.getItem('wesworld-fx-tutorial-dont-show');
            
            if (!tutorialShown && !dontShowAgain) {
                // Show tutorial on first load
                setTimeout(() => {
                    showTutorial();
                    localStorage.setItem('wesworld-fx-tutorial-shown', 'true');
                    
                    // On mobile, also open the search menu
                    if (isMobileDevice() && fxSearchModal) {
                        setTimeout(() => {
                            openFxSearchModal();
                        }, 500);
                    }
                }, 1000); // Wait a bit for page to load
            } else if (isMobileDevice() && !tutorialShown && !dontShowAgain) {
                // On mobile, open menu even if tutorial was skipped
                setTimeout(() => {
                    if (fxSearchModal) {
                        openFxSearchModal();
                    }
                }, 500);
            }
        }
        
        // Setup event listeners
        function setupEventListeners() {
            console.log('Setting up event listeners', { fxSearchTrigger, fxSearchModal, fxSearchInput });
            
            // Tutorial modal event listeners
            const tutorialModal = document.getElementById('tutorialModal');
            const tutorialClose = document.getElementById('tutorialClose');
            const tutorialGotIt = document.getElementById('tutorialGotIt');
            const tutorialDontShow = document.getElementById('tutorialDontShowAgain');
            
            if (tutorialClose) {
                tutorialClose.addEventListener('click', () => {
                    if (tutorialDontShow && tutorialDontShow.checked) {
                        localStorage.setItem('wesworld-fx-tutorial-dont-show', 'true');
                    }
                    hideTutorial();
                });
            }
            
            if (tutorialGotIt) {
                tutorialGotIt.addEventListener('click', () => {
                    if (tutorialDontShow && tutorialDontShow.checked) {
                        localStorage.setItem('wesworld-fx-tutorial-dont-show', 'true');
                    }
                    hideTutorial();
                });
            }
            
            // Close tutorial on Escape key
            if (tutorialModal) {
                tutorialModal.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape' && tutorialModal.getAttribute('aria-hidden') === 'false') {
                        if (tutorialDontShow && tutorialDontShow.checked) {
                            localStorage.setItem('wesworld-fx-tutorial-dont-show', 'true');
                        }
                        hideTutorial();
                    }
                });
                
                // Close tutorial when clicking outside
                tutorialModal.addEventListener('click', (e) => {
                    if (e.target === tutorialModal) {
                        if (tutorialDontShow && tutorialDontShow.checked) {
                            localStorage.setItem('wesworld-fx-tutorial-dont-show', 'true');
                        }
                        hideTutorial();
                    }
                });
            }
            
            // Hide menu button
            const hideMenuButton = document.getElementById('hideMenuButton');
            if (hideMenuButton) {
                hideMenuButton.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    toggleUI();
                });
                // Also handle touch for better mobile support
                hideMenuButton.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    toggleUI();
                }, { passive: false });
            }
            
            // Settings toggle
            const settingsToggle = document.getElementById('settingsToggle');
            if (settingsToggle) {
                settingsToggle.addEventListener('click', () => {
                    // Prevent hiding menu until camera is started and active
                    const cameraStatusText = document.getElementById('cameraStatusText');
                    const isCameraActive = cameraStatusText && cameraStatusText.textContent === 'Camera: Active';
                    
                    if (!isCameraActive) {
                        // Camera not active - keep menu expanded, don't allow hiding
                        return;
                    }
                    
                    // Camera is active - allow toggle
                    const settingsSection = settingsToggle.closest('.settings-section');
                    settingsSection.classList.toggle('expanded');
                    settingsToggle.classList.toggle('expanded');
                });
            }
            
            // Help section toggle
            const helpToggle = document.getElementById('helpToggle');
            if (helpToggle) {
                helpToggle.addEventListener('click', () => {
                    const helpSection = helpToggle.closest('.help-section');
                    helpSection.classList.toggle('expanded');
                    helpToggle.classList.toggle('expanded');
                });
            }
            
            // Corner tap areas for mobile - open menu when tapped
            function setupCornerTapAreas() {
                const cornerTopLeft = document.getElementById('cornerTopLeft');
                const cornerTopRight = document.getElementById('cornerTopRight');
                const cornerBottomLeft = document.getElementById('cornerBottomLeft');
                const cornerBottomRight = document.getElementById('cornerBottomRight');
                
                const handleCornerTap = () => {
                    // Open/expand the settings menu
                    const settingsSection = document.querySelector('.settings-section');
                    const settingsToggle = document.getElementById('settingsToggle');
                    if (settingsSection && settingsToggle) {
                        settingsSection.classList.add('expanded');
                        settingsToggle.classList.add('expanded');
                    }
                    // Also show controls if hidden
                    const controlsEl = document.getElementById('controls');
                    if (controlsEl && controlsEl.classList.contains('hidden')) {
                        controlsEl.classList.remove('hidden');
                        controlsEl.classList.add('visible');
                        controlsVisible = true;
                    }
                };
                
                // Add event listeners for both click and touch
                [cornerTopLeft, cornerTopRight, cornerBottomLeft, cornerBottomRight].forEach(corner => {
                    if (corner) {
                        corner.addEventListener('click', handleCornerTap);
                        corner.addEventListener('touchend', (e) => {
                            e.preventDefault();
                            handleCornerTap();
                        });
                    }
                });
                
                // Show/hide corner tap areas based on device type
                const updateCornerTapVisibility = () => {
                    const shouldShow = shouldShowCornerTaps();
                    [cornerTopLeft, cornerTopRight, cornerBottomLeft, cornerBottomRight].forEach(corner => {
                        if (corner) {
                            corner.style.display = shouldShow ? 'block' : 'none';
                        }
                    });
                };
                
                // Initial check
                updateCornerTapVisibility();
                
                // Update on window resize
                window.addEventListener('resize', updateCornerTapVisibility);
            }
            
            // Setup corner tap areas
            setupCornerTapAreas();
            
            if (startButton) {
                startButton.addEventListener('click', startCamera);
            }
            if (stopButton) {
                stopButton.addEventListener('click', stopCamera);
            }
            
            // Auto-stop and start camera when selection changes
            if (cameraSelect) {
                cameraSelect.addEventListener('change', async (e) => {
                    const newDeviceId = e.target.value;
                    // Only restart if camera was already active
                    if (localStream) {
                        console.log('Camera selection changed, restarting with new camera...');
                        // Stop current camera
                        stopCamera();
                        // Wait a moment for cleanup, then start new camera
                        setTimeout(() => {
                            if (newDeviceId) {
                                startCamera().catch(error => {
                                    console.error('Error starting new camera:', error);
                                    updateStatus('Camera error: ' + error.message, 'error');
                                });
                            }
                        }, 100);
                    }
                });
            }
            
            // Face mask zoom reset button
            const resetFaceMaskZoomButton = document.getElementById('resetFaceMaskZoomButton');
            if (resetFaceMaskZoomButton) {
                resetFaceMaskZoomButton.addEventListener('click', () => {
                    resetFaceMaskSize();
                });
            }
            
            // Test image handlers
            if (testImageInput) {
                testImageInput.addEventListener('change', (e) => {
                    const file = e.target.files[0];
                    if (file) {
                        loadTestImage(file).catch(err => {
                            console.error('Error loading test image:', err);
                        });
                    }
                });
            }
            
            if (clearTestImageButton) {
                clearTestImageButton.addEventListener('click', () => {
                    clearTestImage();
                });
            }
            
            // FX current pin handler
            if (fxCurrentPin) {
                fxCurrentPin.addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (pinnedFilters.includes(currentFilter)) {
                        unpinFilter(currentFilter);
                    } else {
                        pinCurrentFilter();
                    }
                });
            }
            
            // Clear filter button
            if (clearFilterButton) {
                clearFilterButton.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    clearFilter();
                });
            }
            
            // Start roulette button
            const startRouletteButton = document.getElementById('startRouletteButton');
            if (startRouletteButton) {
                startRouletteButton.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    startRandomCycle();
                });
            }
            
            // Spotlight-style search trigger - toggle on click/tap
            if (fxSearchTrigger) {
                console.log('Setting up fxSearchTrigger click handler');
                // Handle both click and touch for better mobile support - toggle behavior
                const handleSearchToggle = (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    console.log('fxSearchTrigger clicked/touched');
                    // Toggle: open if closed, close if open
                    if (fxSearchModal && fxSearchModal.classList.contains('active')) {
                        closeFxSearchModal();
                    } else {
                        openFxSearchModal();
                    }
                };
                
                fxSearchTrigger.addEventListener('click', handleSearchToggle);
                // Also handle touch for better mobile support
                fxSearchTrigger.addEventListener('touchend', handleSearchToggle, { passive: false });
            } else {
                console.error('fxSearchTrigger element not found!');
            }
            
            // Clear search input button
            if (fxSearchClear) {
                fxSearchClear.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    if (fxSearchInput) {
                        fxSearchInput.value = '';
                        fxSearchInput.focus();
                        filterFxOptions('');
                        updateClearButtonVisibility();
                    }
                });
            }
            
            // Close modal when clicking/tapping outside (works for both mouse and touch)
            if (fxSearchModal) {
                // Handle both click and touch events for better mobile support
                const handleModalClose = (e) => {
                    // Close if clicking on the backdrop (modal itself, not the content)
                    // Check if click is directly on modal or outside content area
                    const clickedContent = e.target.closest('.fx-search-modal-content');
                    if (e.target === fxSearchModal || !clickedContent) {
                        e.preventDefault();
                        e.stopPropagation();
                        closeFxSearchModal();
                    }
                };
                
                // Use mousedown for better responsiveness
                fxSearchModal.addEventListener('mousedown', (e) => {
                    if (e.target === fxSearchModal) {
                        handleModalClose(e);
                    }
                });
                
                // Also handle click as fallback
                fxSearchModal.addEventListener('click', handleModalClose);
                
                // Touch events for mobile
                fxSearchModal.addEventListener('touchstart', (e) => {
                    if (e.target === fxSearchModal) {
                        // Store the touch target
                        fxSearchModal._touchTarget = e.target;
                    }
                }, { passive: true });
                
                fxSearchModal.addEventListener('touchend', (e) => {
                    // Only close if touch started and ended on the backdrop
                    if (fxSearchModal._touchTarget === fxSearchModal && 
                        (e.target === fxSearchModal || !e.target.closest('.fx-search-modal-content'))) {
                        e.preventDefault();
                        e.stopPropagation();
                        closeFxSearchModal();
                    }
                    fxSearchModal._touchTarget = null;
                }, { passive: false });
            }
            
            // Toggle UI when clicking/tapping on video (same as pressing 'h')
            // Also hide menu when tapping outside if camera is active
            if (videoContainer && canvasOutput) {
                const handleVideoToggle = (e) => {
                    // Don't toggle if clicking on controls or other UI elements
                    const clickedElement = e.target;
                    const isClickOnUI = clickedElement.closest('#controls') || 
                                       clickedElement.closest('.fx-search-modal') ||
                                       clickedElement.closest('#tutorialModal') ||
                                       clickedElement === fxSearchTrigger ||
                                       clickedElement.closest('button') ||
                                       clickedElement.closest('input') ||
                                       clickedElement.closest('select') ||
                                       clickedElement.closest('.corner-tap-area');
                    
                    // Only toggle if clicking directly on video container or canvas
                    const isClickOnVideo = clickedElement === videoContainer || 
                                         clickedElement === canvasOutput ||
                                         clickedElement === videoInput;
                    
                    if (isClickOnVideo && !isClickOnUI) {
                        // Check if camera is active
                        const cameraStatusText = document.getElementById('cameraStatusText');
                        const isCameraActive = cameraStatusText && cameraStatusText.textContent === 'Camera: Active';
                        
                        if (isCameraActive) {
                            // Hide/collapse the settings menu when camera is active
                            const settingsSection = document.querySelector('.settings-section');
                            const settingsToggle = document.getElementById('settingsToggle');
                            if (settingsSection && settingsToggle) {
                                settingsSection.classList.remove('expanded');
                                settingsToggle.classList.remove('expanded');
                            }
                        } else {
                            // If camera is not active, toggle UI visibility (same as pressing 'h')
                            toggleUI();
                        }
                    }
                };
                
                // Handle both click and touch events on container
                videoContainer.addEventListener('click', handleVideoToggle);
                videoContainer.addEventListener('touchend', (e) => {
                    // Prevent default to avoid double-firing with click
                    e.preventDefault();
                    handleVideoToggle(e);
                }, { passive: false });
                
                // Also handle directly on canvas for better mobile support
                canvasOutput.addEventListener('click', handleVideoToggle);
                canvasOutput.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    handleVideoToggle(e);
                }, { passive: false });
            }
            
            // Search input in modal
            if (fxSearchInput) {
                fxSearchInput.addEventListener('input', (e) => {
                    const searchValue = e.target.value;
                    filterFxOptions(searchValue);
                    updateClearButtonVisibility();
                    // Update aria-expanded based on results
                    const hasResults = fxOptionsContainer && 
                        fxOptionsContainer.querySelector('.fx-option:not([style*="display: none"])');
                    fxSearchInput.setAttribute('aria-expanded', hasResults ? 'true' : 'false');
                });
                
                fxSearchInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape') {
                        e.preventDefault();
                        closeFxSearchModal();
                    } else if (e.key === 'Enter') {
                        e.preventDefault();
                        const optionsContainer = document.getElementById('fxOptionsContainer');
                        if (optionsContainer) {
                            const firstVisible = optionsContainer.querySelector('.fx-option:not([style*="display: none"])');
                            if (firstVisible && firstVisible.value !== undefined) {
                                selectFilter(firstVisible.value);
                                closeFxSearchModal();
                            }
                        }
                    } else if (e.key === 'ArrowDown') {
                        // Allow arrow keys to navigate results
                        e.preventDefault();
                        const optionsContainer = document.getElementById('fxOptionsContainer');
                        if (optionsContainer) {
                            const firstVisible = optionsContainer.querySelector('.fx-option:not([style*="display: none"])');
                            if (firstVisible) {
                                firstVisible.focus();
                            }
                        }
                    }
                });
            }
            
            // Clear button handler
            if (fxSearchClear) {
                fxSearchClear.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    if (fxSearchInput) {
                        fxSearchInput.value = '';
                        fxSearchInput.focus();
                        filterFxOptions('');
                        updateClearButtonVisibility();
                        fxSearchInput.setAttribute('aria-expanded', 'false');
                    }
                });
            }
            
            // Keyboard shortcut to open search (Cmd/Ctrl + K) - handled in main keyboard shortcuts below
            
            // Theme change handler
            if (themeSelect) {
                themeSelect.addEventListener('change', (e) => {
                    const themeKey = e.target.value;
                    if (THEMES[themeKey]) {
                        applyTheme(THEMES[themeKey]);
                        localStorage.setItem('wesworld-fx-theme', themeKey);
                        console.log('Theme changed to:', themeKey);
                    }
                });
            }
            
            // Close dropdown when clicking outside (legacy support)
            document.addEventListener('click', (e) => {
                // Only handle if not clicking on modal or trigger
                if (fxSearchModal && fxSearchModal.contains(e.target)) return;
                if (fxSearchTrigger && fxSearchTrigger.contains(e.target)) return;
                
                // Legacy dropdown handling (if still exists)
                if (fxDropdownMenu && fxDropdownButton && !fxDropdownButton.contains(e.target) && !fxDropdownMenu.contains(e.target)) {
                    fxDropdownMenu.classList.remove('open');
                }
            });
            
            // Keyboard shortcuts
            document.addEventListener('keydown', (e) => {
                // Don't handle shortcuts if user is typing in an input field
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT' || e.target.isContentEditable) {
                    return;
                }
                
                switch(e.key) {
                    case 'h':
                    case 'H':
                        toggleUI();
                        break;
                    case 'ArrowUp':
                    case 'ArrowLeft':
                        e.preventDefault();
                        cyclePrevFilter();
                        break;
                    case 'ArrowDown':
                    case 'ArrowRight':
                        e.preventDefault();
                        cycleNextFilter();
                        break;
                    case ' ':
                        e.preventDefault();
                        startRandomCycle();
                        break;
                    case 'c':
                    case 'C':
                        e.preventDefault();
                        clearFilter();
                        break;
                    case 'Escape':
                        // Clear filter on Escape (if not in search modal)
                        if (!fxSearchModal || !fxSearchModal.classList.contains('active')) {
                            e.preventDefault();
                            clearFilter();
                        }
                        break;
                    case '-':
                    case '_':
                        // Decrease face mask size when in face mask mode
                        if (currentFilter && currentFilter.includes('face_mask')) {
                            e.preventDefault();
                            adjustFaceMaskSize(-0.1);
                        }
                        break;
                    case '+':
                    case '=':
                        // Increase face mask size when in face mask mode
                        if (currentFilter && currentFilter.includes('face_mask')) {
                            e.preventDefault();
                            adjustFaceMaskSize(0.1);
                        }
                        break;
                    case 'f':
                    case 'F':
                        e.preventDefault();
                        openFxSearchModal();
                        break;
                    case 't':
                    case 'T':
                        e.preventDefault();
                        showTutorial();
                        break;
                }
                
                // Keyboard shortcut to open search (Cmd/Ctrl + K)
                if ((e.metaKey || e.ctrlKey) && e.key === 'k') {
                    e.preventDefault();
                    console.log('Cmd/Ctrl+K pressed in main handler');
                    openFxSearchModal();
                }
            });
            
            // Handle visibility change - reload camera on mobile after permission dialog closes
            let wasHidden = false;
            const reloadCameraIfNeeded = () => {
                if (localStream && videoInput) {
                    // Check if video is not playing or has no video dimensions
                    if (videoInput.paused || videoInput.videoWidth === 0 || videoInput.videoHeight === 0) {
                        console.log('Reloading camera after page visibility change');
                        // Reload the camera stream
                        const deviceId = cameraSelect.value;
                        const constraints = {
                            video: {
                                deviceId: deviceId ? { exact: deviceId } : undefined,
                                width: { ideal: 1280 },
                                height: { ideal: 720 }
                            }
                        };
                        
                        // Use facingMode on mobile if no specific device is selected
                        if (isMobileDevice() && !deviceId) {
                            constraints.video.facingMode = currentFacingMode;
                        }
                        
                        // Stop old stream
                        if (localStream) {
                            localStream.getTracks().forEach(track => track.stop());
                        }
                        
                        // Get new stream and restart
                        navigator.mediaDevices.getUserMedia(constraints)
                            .then(stream => {
                                localStream = stream;
                                videoInput.srcObject = stream;
                                return videoInput.play();
                            })
                            .then(() => {
                                console.log('Camera reloaded successfully after visibility change');
                                // Force a refresh of the video processing
                                if (!animationFrameId && videoInput.readyState >= 2) {
                                    processVideoFrame();
                                }
                            })
                            .catch(error => {
                                console.error('Error reloading camera after visibility change:', error);
                            });
                    }
                }
            };
            
            document.addEventListener('visibilitychange', () => {
                if (document.visibilityState === 'visible') {
                    // Page became visible again - check if we need to reload camera
                    if (wasHidden) {
                        // Small delay to ensure page is fully visible
                        setTimeout(reloadCameraIfNeeded, 100);
                    }
                    wasHidden = false;
                } else if (document.visibilityState === 'hidden') {
                    wasHidden = true;
                }
            });
            
            // Also handle pageshow event for mobile Safari (backup)
            window.addEventListener('pageshow', (e) => {
                // Check if this is a back/forward navigation or page restoration
                if (e.persisted || (document.visibilityState === 'visible' && localStream)) {
                    setTimeout(reloadCameraIfNeeded, 100);
                }
            });
        }
        
        // Initialize everything
        async function init() {
            try {
                updateStatus('Loading...', 'loading');
                
                // Initialize WASM
                await initWasm();
                
                updateStatus('Loading face detection...', 'loading');
                
                // Initialize MediaPipe
                const faceDetected = await initFaceDetection();
                
                if (!faceDetected) {
                    updateStatus('Face detection failed - filters may not work', 'error');
                }
                
                // Setup UI
                loadThemes(); // Load themes first (sets default to wesworld)
                await loadCameras();
                loadPinnedFilters();
                
                // Discover face masks first (this updates FILTER_CATEGORIES)
                await discoverFaceMasks();
                
                // Now load filters (which will include discovered face masks)
                loadFilters();
                setupEventListeners();
                
                // Update version and build display
                updateVersionDisplay();
                startTimeUpdateInterval();
                
                // Load face mask scale from localStorage
                try {
                    const savedScale = localStorage.getItem('wesworld-fx-face-mask-scale');
                    if (savedScale) {
                        faceMaskScale = parseFloat(savedScale);
                        // Clamp to valid range
                        faceMaskScale = Math.max(0.5, Math.min(2.0, faceMaskScale));
                        console.log('Loaded face mask scale from localStorage:', faceMaskScale);
                    }
                    updateFaceMaskZoomDisplay();
                } catch (error) {
                    console.error('Error loading face mask scale from localStorage:', error);
                }
                
                // Load FX from URL if present, otherwise load from localStorage (after filters are loaded)
                setTimeout(() => {
                    const urlParams = new URLSearchParams(window.location.search);
                    const fxParam = urlParams.get('fx');
                    
                    if (fxParam && allFilters.includes(fxParam)) {
                        // URL parameter takes priority
                        selectFilter(fxParam, false);
                    } else {
                        // Try to load from localStorage (works with file:// protocol)
                        try {
                            const savedFilter = localStorage.getItem('wesworld-fx-last');
                            if (savedFilter && allFilters.includes(savedFilter)) {
                                selectFilter(savedFilter, false);
                            }
                        } catch (error) {
                            console.error('Error loading last filter from localStorage:', error);
                        }
                    }
                }, 100);
                
                // Preload face masks
                await preloadFaceMasks();
                
                // Debug: Check if modal elements exist
                console.log('Modal elements check:', {
                    fxSearchTrigger: !!fxSearchTrigger,
                    fxSearchModal: !!fxSearchModal,
                    fxSearchInput: !!fxSearchInput,
                    fxSearchClear: !!fxSearchClear
                });
                
                // Test modal opening
                if (fxSearchModal) {
                    console.log('Modal element found, testing visibility');
                    // Temporarily show modal to test
                    setTimeout(() => {
                        console.log('Modal classes:', fxSearchModal.className);
                        console.log('Modal computed style:', window.getComputedStyle(fxSearchModal).display);
                    }, 1000);
                }
                
                loadingIndicator.classList.add('hidden');
                
                // Check and show tutorial on first load
                checkAndShowTutorial();
                
                // Auto-start camera automatically
                const savedCameraId = localStorage.getItem('wesworld-fx-camera');
                
                // Make sure camera select has the saved camera selected, or use first available
                if (savedCameraId && cameraSelect.value !== savedCameraId) {
                    const cameraExists = Array.from(cameraSelect.options).some(opt => opt.value === savedCameraId);
                    if (cameraExists) {
                        cameraSelect.value = savedCameraId;
                    }
                }
                
                // If no camera is selected, select the first available camera
                if (!cameraSelect.value && cameraSelect.options.length > 0) {
                    cameraSelect.value = cameraSelect.options[0].value;
                }
                
                // Check if user has previously started camera (remembered preference)
                const shouldAutoStart = localStorage.getItem('wesworld-fx-camera-auto-start') === 'true';
                
                // Start camera automatically if user has previously started it and we have a selection
                if (shouldAutoStart && cameraSelect.value) {
                    updateStatus('Starting camera...', 'loading');
                    // Wait a bit for UI to be ready, then start camera
                    setTimeout(() => {
                        startCamera().catch(error => {
                            console.warn('Auto-start camera failed:', error);
                            updateStatus('Camera auto-start failed - Click "Start Camera" to begin', 'error');
                            // If auto-start fails, clear the active flag but keep auto-start preference
                            localStorage.setItem('wesworld-fx-camera-active', 'false');
                            // Expand settings and show start button if camera failed to start
                            const settingsSection = document.querySelector('.settings-section');
                            const settingsToggle = document.getElementById('settingsToggle');
                            if (settingsSection && settingsToggle) {
                                settingsSection.classList.add('expanded');
                                settingsToggle.classList.add('expanded');
                            }
                            startButton.style.display = 'block';
                            stopButton.style.display = 'none';
                        });
                    }, 300);
                } else {
                    updateStatus('No camera available - Check camera permissions', 'error');
                    // Expand settings and show start button if no camera available
                    const settingsSection = document.querySelector('.settings-section');
                    const settingsToggle = document.getElementById('settingsToggle');
                    if (settingsSection && settingsToggle) {
                        settingsSection.classList.add('expanded');
                        settingsToggle.classList.add('expanded');
                    }
                    startButton.style.display = 'block';
                    stopButton.style.display = 'none';
                }
                
                // Auto-hide UI after 3 seconds
                setTimeout(() => {
                    if (controlsVisible) {
                        toggleUI();
                    }
                }, 3000);
                
            } catch (error) {
                console.error('Initialization error:', error);
                loadingIndicator.classList.add('hidden');
                updateStatus('Initialization failed: ' + error.message, 'error');
            }
        }
        
        // Load theme immediately when DOM is ready (before showing controls)
        function loadThemeEarly() {
            if (themeSelect && THEMES) {
                // Populate theme dropdown
                themeSelect.innerHTML = '';
                Object.keys(THEMES).forEach(themeKey => {
                    const option = document.createElement('option');
                    option.value = themeKey;
                    option.textContent = THEMES[themeKey].name;
                    themeSelect.appendChild(option);
                });
                
                // Load saved theme or use default (wesworld)
                const savedTheme = localStorage.getItem('wesworld-fx-theme') || 'wesworld';
                if (THEMES[savedTheme]) {
                    themeSelect.value = savedTheme;
                    applyTheme(THEMES[savedTheme]);
                } else {
                    applyTheme(THEMES.wesworld);
                }
                
                // Show controls after theme is loaded
                if (controls) {
                    controls.classList.remove('hidden');
                    controls.classList.add('visible');
                }
            }
        }
        
        // Clean up old URL parameters on page load
        cleanOldURLParams();
        
        // Load theme as soon as DOM elements are available
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', async () => {
                await loadBuildInfo();
                loadThemeEarly();
                updateVersionDisplay();
                startTimeUpdateInterval();
                init();
            });
        } else {
            (async () => {
                await loadBuildInfo();
                loadThemeEarly();
                updateVersionDisplay();
                startTimeUpdateInterval();
                init();
            })();
        }
    </script>
</body>
</html>


