<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="description" content="WesWorld FX - High-performance face filters using WebAssembly. Works on desktop, mobile, and all modern browsers.">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="WesWorld FX">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>WesWorld FX</title>
    
    <!-- Mobile swipe gestures enabled -->
    <!-- Favicon and App Icons -->
    <link rel="icon" type="image/x-icon" href="assets/icons/favicon.ico">
    <link rel="icon" type="image/png" sizes="32x32" href="assets/icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="assets/icons/favicon-16x16.png">
    <link rel="apple-touch-icon" href="assets/icons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="192x192" href="assets/icons/android-chrome-192x192.png">
    <link rel="icon" type="image/png" sizes="512x512" href="assets/icons/android-chrome-512x512.png">
    <link rel="mask-icon" href="assets/icons/safari-pinned-tab.svg" color="#000000">
    <meta name="msapplication-TileImage" content="assets/icons/mstile-150x150.png">
    <meta name="theme-color" content="#000000">
    
    <!-- Preconnect for performance -->
    <link rel="preconnect" href="https://cdn.jsdelivr.net">
    <link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }
        
        body {
            background: #000;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            touch-action: none;
            -webkit-user-select: none;
            user-select: none;
        }
        
        #videoContainer {
            width: 100vw;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            background: #000;
            cursor: pointer;
            -webkit-tap-highlight-color: transparent;
        }
        
        #currentFxOverlay {
            position: fixed;
            top: 10px;
            left: 10px;
            z-index: 999;
            background: var(--surface-color, rgba(26, 26, 26, 0.9));
            color: var(--text-color, white);
            padding: 8px 16px;
            border-radius: 6px;
            border: 1px solid var(--border-color, #333);
            font-size: 13px;
            font-weight: 500;
            pointer-events: none;
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            display: none;
            max-width: calc(100vw - 20px);
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        #currentFxOverlay.active {
            display: block;
        }
        
        #currentFxOverlay .fx-label {
            color: var(--text-secondary-color, #cccccc);
            font-size: 11px;
            text-transform: uppercase;
            margin-right: 6px;
        }
        
        #currentFxOverlay .fx-name {
            color: var(--accent-color, #5250ef);
            font-weight: 600;
        }
        
        #videoInput {
            display: none;
        }
        
        #canvasOutput {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
            display: block;
            background: #000;
            width: 100%;
            height: 100%;
            image-rendering: -webkit-optimize-contrast;
            image-rendering: crisp-edges;
            pointer-events: auto;
            -webkit-tap-highlight-color: transparent;
        }
        
        /* Controls panel */
        #controls {
            position: fixed;
            top: 10px;
            left: 10px;
            z-index: 1000;
            background: var(--surface-color, rgba(26, 26, 26, 0.95));
            color: var(--text-color, white);
            padding: 12px;
            border-radius: 8px;
            border: 1px solid var(--border-color, #333);
            font-size: 14px;
            min-width: 180px;
            max-width: 220px;
            transition: opacity 0.3s, transform 0.3s;
            -webkit-backdrop-filter: blur(10px);
            backdrop-filter: blur(10px);
            max-height: calc(100vh - 20px);
            overflow-y: auto;
        }
        
        @media (max-width: 768px) {
            #controls {
                min-width: 200px;
                max-width: 90vw;
                font-size: 16px;
                padding: 16px;
            }
        }
        
        #controls.visible {
            opacity: 1;
            transform: translateX(0);
        }
        
        #controls.hidden {
            opacity: 0;
            transform: translateX(-100%);
            pointer-events: none;
        }
        
        /* Hide menu button */
        #hideMenuButton {
            width: 100%;
            padding: 10px 12px;
            margin-bottom: 12px;
            background: var(--surface-hover-color, #2a2a2a);
            color: var(--text-color, white);
            border: 1px solid var(--border-color, #333);
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            transition: background-color 0.2s, transform 0.1s, border-color 0.2s;
            -webkit-tap-highlight-color: transparent;
            user-select: none;
        }
        
        #hideMenuButton:hover {
            background: var(--surface-hover-color, #333);
            border-color: var(--border-color, #444);
        }
        
        #hideMenuButton:active {
            transform: scale(0.98);
            background: var(--surface-hover-color, #2d2d2d);
        }
        
        #hideMenuButton:focus {
            outline: 2px solid rgba(82, 80, 239, 0.5);
            outline-offset: 2px;
        }
        
        @media (max-width: 768px) {
            #hideMenuButton {
                padding: 14px 16px;
                font-size: 16px;
                min-height: 48px; /* Larger touch target for mobile */
                margin-bottom: 16px;
            }
        }
        
        /* Status widget removed - camera status shown in settings section */
        #status {
            display: none !important;
        }
        
        #loadingIndicator {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 2000;
            background: rgba(26, 26, 26, 0.95);
            color: white;
            padding: 20px 30px;
            border-radius: 8px;
            text-align: center;
            border: 1px solid var(--border-color, #333);
        }
        
        #loadingIndicator.hidden {
            display: none;
        }
        
        .spinner {
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-top: 3px solid var(--accent-color, #5250ef);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 10px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* Screen reader only - accessible but visually hidden */
        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border-width: 0;
        }
        
        .settings-section,
        .fx-section,
        .help-section {
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid var(--border-color, #333);
        }
        
        .settings-section:last-child,
        .fx-section:last-child,
        .help-section:last-child {
            border-bottom: none;
        }
        
        .section-title {
            font-size: 14px;
            font-weight: bold;
            color: var(--group-title-color, #5250ef);
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            cursor: pointer;
            user-select: none;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .section-title::before {
            content: 'â–¶';
            font-size: 10px;
            transition: transform 0.2s;
        }
        
        .section-title.expanded::before {
            transform: rotate(90deg);
        }
        
        .settings-section-content,
        .fx-section-content,
        .help-section-content {
            display: none;
        }
        
        .settings-section.expanded .settings-section-content,
        .fx-section.expanded .fx-section-content,
        .help-section.expanded .help-section-content {
            display: block;
        }
        
        .help-section-content {
            font-size: 12px;
            line-height: 1.6;
        }
        
        .help-category {
            margin-bottom: 16px;
        }
        
        .help-category-title {
            font-weight: bold;
            color: var(--accent-color, #5250ef);
            margin-bottom: 8px;
            font-size: 13px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .help-command {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 6px;
            padding: 4px 8px;
            border-radius: 4px;
            transition: background-color 0.2s;
        }
        
        .help-command[data-action] {
            cursor: pointer;
        }
        
        .help-command[data-action]:hover {
            background-color: var(--surface-hover-color, rgba(255, 255, 255, 0.05));
        }
        
        .help-command[data-action]:active {
            background-color: var(--surface-hover-color, rgba(255, 255, 255, 0.1));
        }
        
        .help-command.disabled {
            cursor: not-allowed;
            opacity: 0.5;
            /* Don't block pointer events - allow clicks to still work for debugging */
            pointer-events: auto;
        }
        
        .help-command.disabled:hover {
            background-color: transparent;
        }
        
        .help-command-desc {
            flex: 1;
            color: var(--text-secondary-color, #cccccc);
            margin-right: 12px;
        }
        
        .help-command-key {
            font-family: 'Monaco', 'Menlo', 'Courier New', monospace;
            background: var(--surface-hover-color, #2a2a2a);
            border: 1px solid var(--border-color, #333);
            border-radius: 4px;
            padding: 2px 6px;
            font-size: 11px;
            color: var(--text-color, white);
            white-space: nowrap;
            min-width: fit-content;
        }
        
        .help-command-key.combo {
            padding: 2px 4px;
        }
        
        .help-command-key kbd {
            display: inline-block;
            padding: 1px 4px;
            margin: 0 2px;
            background: var(--surface-color, #1a1a1a);
            border: 1px solid var(--border-color, #333);
            border-radius: 3px;
        }
        
        /* Legacy dropdown removed - using modal search instead */
        
        .camera-status {
            padding: 8px 12px;
            background: var(--surface-hover-color, #2a2a2a);
            border-radius: 4px;
            margin-bottom: 10px;
            font-size: 13px;
        }
        
        .camera-status.connected {
            color: var(--status-connected-color, #4caf50);
        }
        
        .camera-status.stopped {
            color: var(--text-secondary-color, #cccccc);
        }
        
        .camera-status.error {
            color: var(--status-error-color, #f44336);
        }
        
        .current-fx-display {
            padding: 12px;
            background: var(--surface-color, #1a1a1a);
            border: none;
            border-radius: 4px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 14px;
            min-height: 20px;
        }
        
        .current-fx-actions {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .clear-filter-button {
            padding: 4px 8px;
            background: transparent;
            border: 1px solid var(--border-color, #333);
            border-radius: 4px;
            color: var(--text-color, white);
            cursor: pointer;
            font-size: 14px;
            line-height: 1;
            transition: all 0.2s;
            min-width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .clear-filter-button:hover {
            background: var(--status-error-color, #f44336);
            border-color: var(--status-error-color, #f44336);
            color: white;
        }
        
        label {
            display: block;
            margin-bottom: 10px;
            font-size: 12px;
            color: var(--text-secondary-color, #cccccc);
        }
        
        select, input {
            width: 100%;
            padding: 8px;
            background: var(--surface-color, #1a1a1a);
            color: var(--text-color, white);
            border: 1px solid var(--border-color, #333);
            border-radius: 4px;
            font-size: 12px;
            margin-top: 4px;
        }
        
        select:focus, input:focus {
            outline: none;
            border-color: var(--accent-color, #5250ef);
        }
        
        button {
            width: 100%;
            padding: 10px;
            background: transparent;
            border: 2px solid var(--button-color, #4a9eff);
            color: var(--button-color, #4a9eff);
            cursor: pointer;
            transition: all 0.2s;
            border-radius: 4px;
            font-size: 14px;
            margin-bottom: 10px;
            touch-action: manipulation;
        }
        
        button:hover, button:active {
            background: var(--button-color, #4a9eff);
            color: var(--selected-text-color, #ffffff);
        }
        
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        button#startButton,
        button#stopButton {
            background: var(--button-color, #4a9eff);
            color: var(--selected-text-color, #ffffff);
        }
        
        button#startButton:hover,
        button#stopButton:hover {
            background: var(--button-hover-color, #5aaeff);
        }
        
        @media (max-width: 768px) {
            select, input, button {
                font-size: 16px;
                padding: 12px;
            }
            button {
                min-height: 44px;
            }
        }
        
        .all-fx-container {
            width: 100%;
        }
        
        /* FX options container in modal */
        .fx-dropdown-menu {
            position: relative;
            width: 100%;
            max-height: 400px;
            overflow-y: auto;
            display: none; /* Hidden by default, shown when search input focused */
        }
        
        /* Show FX list when search input is focused */
        .fx-search-modal.active .fx-search-input:focus ~ .fx-search-results .fx-dropdown-menu,
        .fx-search-modal.active .fx-search-input:not(:placeholder-shown) ~ .fx-search-results .fx-dropdown-menu {
            display: block;
        }
        
        .all-fx-container .pinned-fx-container {
            margin-bottom: 8px;
        }
        
        /* Spotlight-style search trigger */
        .fx-search-trigger {
            width: 100%;
            padding: 12px;
            background: var(--surface-color, #1a1a1a);
            color: var(--text-secondary-color, #cccccc);
            border: 1px solid var(--border-color, #333);
            border-radius: 8px;
            font-size: 14px;
            cursor: pointer;
            text-align: left;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: all 0.2s;
            margin-top: 4px;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
            user-select: none;
        }
        
        .fx-search-trigger:hover,
        .fx-search-trigger:active {
            background: var(--surface-hover-color, #2a2a2a);
            border-color: var(--accent-color, #5250ef);
        }
        
        .fx-search-trigger span {
            font-size: 16px;
        }
        
        @media (max-width: 768px) {
            .fx-search-trigger {
                padding: 16px;
                font-size: 16px;
                min-height: 48px;
            }
        }
        
        /* Spotlight-style search modal - Full screen */
        .fx-search-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            z-index: 10000;
            align-items: flex-start;
            justify-content: center;
            padding: 0;
            animation: fadeIn 0.2s ease-out;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            touch-action: pan-y;
            /* Ensure it's above everything */
            isolation: isolate;
        }
        
        .fx-search-modal.active,
        .fx-search-modal[aria-hidden="false"] {
            display: flex;
        }
        
        .fx-search-modal[aria-hidden="true"] {
            display: none;
        }
        
        @keyframes fadeIn {
            from {
                opacity: 0;
            }
            to {
                opacity: 1;
            }
        }
        
        .fx-search-modal-content {
            width: 100%;
            max-width: 600px;
            background: var(--surface-color, #1e1e1e);
            border-radius: 0;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.6);
            overflow: hidden;
            animation: slideDown 0.2s ease-out;
            max-height: 85vh;
            display: flex;
            flex-direction: column;
            margin: 0;
            position: relative;
            pointer-events: auto;
            /* Better contrast and readability */
            color: var(--text-color, #ffffff);
            border: 1px solid var(--border-color, #333);
        }
        
        /* Prevent clicks inside content from closing modal */
        .fx-search-modal-content * {
            pointer-events: auto;
        }
        
        /* Mobile-first responsive design */
        @media (max-width: 768px) {
            .fx-search-modal {
                padding: 0;
                align-items: stretch;
                /* Safe area insets for notched devices */
                padding-top: env(safe-area-inset-top);
                padding-bottom: env(safe-area-inset-bottom);
                padding-left: env(safe-area-inset-left);
                padding-right: env(safe-area-inset-right);
            }
            
            .fx-search-modal-content {
                width: 100%;
                max-width: 100%;
                border-radius: 0;
                max-height: 100vh;
                min-height: 100vh;
                /* Account for safe areas */
                max-height: calc(100vh - env(safe-area-inset-top) - env(safe-area-inset-bottom));
                min-height: calc(100vh - env(safe-area-inset-top) - env(safe-area-inset-bottom));
            }
        }
        
        /* Tablet and desktop */
        @media (min-width: 769px) {
            .fx-search-modal {
                padding-top: 8vh;
                padding-bottom: 8vh;
                padding-left: 2vw;
                padding-right: 2vw;
            }
            
            .fx-search-modal-content {
                border-radius: 8px;
                max-height: 75vh;
                box-shadow: 0 12px 48px rgba(0, 0, 0, 0.7);
                /* Better spacing on larger screens */
                margin: 0 auto;
            }
        }
        
        /* Large desktop */
        @media (min-width: 1200px) {
            .fx-search-modal-content {
                max-width: 550px;
            }
        }
        
        @keyframes slideDown {
            from {
                transform: translateY(-20px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }
        
        .fx-search-header {
            padding: 16px;
            border-bottom: 1px solid var(--border-color, #333);
            display: flex;
            flex-direction: column;
            align-items: stretch;
            position: relative;
            flex-shrink: 0;
            background: var(--surface-color, #1e1e1e);
            /* Better spacing and touch targets */
            gap: 8px;
        }
        
        @media (max-width: 768px) {
            .fx-search-header {
                padding: 14px 16px;
                /* Safe area padding for notched devices */
                padding-left: max(16px, env(safe-area-inset-left));
                padding-right: max(16px, env(safe-area-inset-right));
                padding-top: max(14px, env(safe-area-inset-top));
            }
        }
        
        .fx-search-input-wrapper {
            position: relative;
            display: flex;
            align-items: center;
            width: 100%;
        }
        
        .fx-search-icon {
            position: absolute;
            left: 14px;
            top: 50%;
            transform: translateY(-50%);
            color: var(--text-secondary-color, #888);
            pointer-events: none;
            z-index: 1;
            transition: color 0.2s;
        }
        
        .fx-search-header .fx-search-input:focus ~ .fx-search-icon,
        .fx-search-header .fx-search-input:not(:placeholder-shown) ~ .fx-search-icon {
            color: var(--accent-color, #ffd700);
        }
        
        .fx-search-header .fx-search-input {
            width: 100%;
            padding: 12px 40px 12px 42px;
            background: var(--surface-hover-color, #2a2a2a);
            border: 1px solid var(--border-color, #444);
            border-radius: 8px;
            font-size: 15px;
            color: var(--text-color, #ffffff) !important;
            min-width: 0;
            -webkit-appearance: none;
            appearance: none;
            /* Better focus visibility */
            transition: border-color 0.2s, box-shadow 0.2s, background-color 0.2s;
            font-weight: 400;
        }
        
        .fx-search-header .fx-search-input:focus {
            outline: none;
            border-color: var(--accent-color, #ffd700);
            /* Subtle glow using accent color - border is main indicator */
            box-shadow: 0 0 0 2px var(--accent-color, rgba(255, 215, 0, 0.2));
            background: var(--surface-hover-color, #2f2f2f);
        }
        
        .fx-search-header .fx-search-input:hover:not(:focus) {
            border-color: var(--border-hover-color, #555);
            background: var(--surface-hover-color, #2d2d2d);
        }
        
        @media (max-width: 768px) {
            .fx-search-header .fx-search-input {
                padding: 14px 48px 14px 48px;
                font-size: 16px;
                min-height: 48px; /* Larger touch target for mobile */
                border-width: 1px;
                border-radius: 10px;
            }
            
            .fx-search-icon {
                left: 16px;
                width: 20px;
                height: 20px;
            }
        }
        
        .fx-search-clear {
            position: absolute;
            right: 0px;
            top: 7px;
            width: 40px;
            background: none;
            border: none;
            color: var(--text-secondary-color, #666666);
            cursor: pointer;
            font-size: 20px;
            line-height: 1;
            padding: 8px;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s, color 0.2s, background-color 0.2s, transform 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 36px;
            border-radius: 50%;
            z-index: 2;
            -webkit-tap-highlight-color: transparent;
        }
        
        .fx-search-clear.visible {
            opacity: 1;
            pointer-events: all;
        }
        
        .fx-search-clear:hover,
        .fx-search-clear:focus {
            color: var(--text-color, #ffffff);
            background-color: rgba(255, 255, 255, 0.15);
            outline: 2px solid var(--accent-color, rgba(255, 215, 0, 0.3));
            outline-offset: 2px;
            transform: scale(1.1);
        }
        
        .fx-search-clear:active {
            background-color: rgba(255, 255, 255, 0.25);
            transform: scale(0.95);
        }
        
        @media (max-width: 768px) {
            .fx-search-clear {
                right: 0px;
                width: 44px;
                min-height: 44px;
                font-size: 22px;
            }
        }
        
        .fx-search-header .fx-search-input::placeholder {
            color: var(--text-secondary-color, #999) !important;
            opacity: 1;
        }
        
        .fx-search-header .fx-search-input:focus::placeholder {
            color: var(--text-secondary-color, #777) !important;
        }
        
        .fx-search-header .fx-search-input:-webkit-autofill,
        .fx-search-header .fx-search-input:-webkit-autofill:hover,
        .fx-search-header .fx-search-input:-webkit-autofill:focus {
            -webkit-text-fill-color: var(--text-color, #ffffff) !important;
            -webkit-box-shadow: 0 0 0px 1000px var(--surface-hover-color, #2a2a2a) inset !important;
        }
        
        .fx-search-results {
            overflow-y: auto;
            max-height: calc(85vh - 80px);
            padding: 4px;
            -webkit-overflow-scrolling: touch;
            flex: 1;
            background: var(--surface-color, #1e1e1e);
            /* Better scrollbar styling */
            scrollbar-width: thin;
            scrollbar-color: var(--accent-color, #ffd700) transparent;
        }
        
        .fx-search-results::-webkit-scrollbar {
            width: 6px;
        }
        
        .fx-search-results::-webkit-scrollbar-track {
            background: transparent;
        }
        
        .fx-search-results::-webkit-scrollbar-thumb {
            background: var(--border-color, #555);
            border-radius: 3px;
        }
        
        .fx-search-results::-webkit-scrollbar-thumb:hover {
            background: var(--border-hover-color, #666);
        }
        
        @media (max-width: 768px) {
            .fx-search-results {
                max-height: calc(85vh - 100px);
                padding: 8px;
                /* Account for safe areas */
                padding-left: max(8px, env(safe-area-inset-left));
                padding-right: max(8px, env(safe-area-inset-right));
                padding-bottom: max(8px, env(safe-area-inset-bottom));
            }
        }
        
        .fx-search-results .fx-dropdown-menu,
        .fx-search-results #fxOptionsContainer {
            display: block !important;
            position: relative;
            top: auto;
            left: auto;
            right: auto;
            margin: 0;
            max-height: none;
            border: none;
            background: transparent;
        }
        
        .fx-search-results .fx-group {
            margin-bottom: 6px;
        }
        
        .fx-search-results .fx-option {
            padding: 10px 12px;
            align-items: center;
        }
        
        .fx-search-results .fx-option-text {
            display: flex;
            align-items: center;
        }
        
        .fx-search-results .fx-option-pin {
            align-self: center;
        }
        
        /* Ensure all text in modal is visible */
        .fx-search-modal-content,
        .fx-search-modal-content * {
            color: var(--text-color, #ffffff);
        }
        
        .fx-search-modal-content .fx-group-title,
        .fx-search-modal-content button {
            color: inherit;
        }
        
        /* Text color is handled by .fx-option-text rules above */
        .fx-search-modal-content .fx-option-text {
            color: var(--text-color, #ffffff);
        }
        
        .fx-search-modal-content .fx-option.selected .fx-option-text {
            color: var(--selected-text-color, #000000) !important;
        }
        
        .fx-group {
            margin-bottom: 4px;
        }
        
        .fx-group-title {
            padding: 6px 12px;
            font-size: 10px;
            font-weight: 700;
            color: var(--group-title-color, var(--accent-color, #ffd700));
            text-transform: uppercase;
            background: var(--surface-hover-color, #252525);
            border-bottom: 1px solid var(--border-color, #333);
            letter-spacing: 0.5px;
        }
        
        .fx-option {
            padding: 10px 12px;
            color: var(--text-color, #ffffff) !important;
            cursor: pointer;
            border: none;
            background: transparent;
            width: 100%;
            text-align: left;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 10px;
            transition: all 0.15s;
            min-height: 40px; /* WCAG minimum touch target */
            -webkit-tap-highlight-color: transparent;
            position: relative;
            user-select: none;
            font-weight: 400;
            box-sizing: border-box;
        }
        
        .fx-option:hover,
        .fx-option:focus {
            background: var(--surface-hover-color, #2a2a2a);
            outline: none;
        }
        
        .fx-option:hover,
        .fx-option:focus,
        .fx-option.selected {
            border-radius: 0;
        }
        
        .fx-option:active {
            background: var(--surface-hover-color, #333);
            transform: scale(0.99);
        }
        
        /* Better touch feedback on mobile */
        @media (hover: none) and (pointer: coarse) {
            .fx-option:active {
                background: var(--surface-hover-color, #333);
                transform: scale(0.98);
            }
        }
        
        .fx-option.selected {
            background: var(--button-color, var(--accent-color, #ffd700)) !important;
            color: var(--selected-text-color, #000000) !important;
            font-weight: 600;
            border: none;
        }
        
        .fx-option.selected:focus {
            outline: none;
            background: #ffd700 !important;
        }
        
        .fx-option.selected:hover {
            background: #ffed4e !important;
        }
        
        @media (max-width: 768px) {
            .fx-option {
                padding: 12px 14px;
                font-size: 15px;
                min-height: 48px; /* Larger touch target on mobile */
            }
        }
        
        .fx-option-image {
            width: 36px;
            height: 36px;
            object-fit: cover;
            border-radius: 50%;
            border: 2px solid #444;
            flex-shrink: 0;
        }
        
        .fx-option.selected .fx-option-image {
            border-color: #000;
        }
        
        .fx-option-text {
            flex: 1;
            min-width: 0; /* Allow text to shrink if needed */
            text-overflow: ellipsis;
            white-space: nowrap;
            color: #ffffff; /* Default white text for non-selected items */
            display: flex;
            align-items: center;
            line-height: 1.4;
        }
        
        /* Black text when selected */
        .fx-option.selected .fx-option-text {
            color: #000000 !important;
        }
        
        /* White text when not selected (explicit for clarity) */
        .fx-option:not(.selected) .fx-option-text {
            color: #ffffff !important;
        }
        
        .fx-option-pin {
            display: none !important; /* Pinning disabled */
            cursor: pointer;
            font-size: 14px;
            padding: 0;
            opacity: 0.6;
            transition: opacity 0.2s, background-color 0.2s, transform 0.1s;
            background: transparent;
            border: none;
            border-radius: 4px;
            min-width: 32px;
            min-height: 32px;
            width: 32px;
            height: 32px;
            align-items: center;
            justify-content: center;
            -webkit-tap-highlight-color: transparent;
            flex-shrink: 0;
            margin-left: auto;
            margin-right: 0;
            box-sizing: border-box;
            line-height: 1;
        }
        
        .fx-option:hover .fx-option-pin {
            opacity: 0.9;
        }
        
        .fx-option-pin:hover,
        .fx-option-pin:focus {
            opacity: 1;
            background-color: rgba(255, 255, 255, 0.15);
            outline: none;
        }
        
        .fx-option-pin:active {
            background-color: rgba(255, 255, 255, 0.25);
            transform: scale(0.9);
        }
        
        /* Ensure pin button doesn't interfere with option click */
        .fx-option-pin:active,
        .fx-option-pin:focus {
            z-index: 1;
            position: relative;
        }
        
        @media (max-width: 768px) {
            .fx-option-pin {
                min-width: 36px;
                min-height: 36px;
                font-size: 16px;
            }
        }
        
        .fx-current-pin {
            display: none !important; /* Pinning disabled */
            cursor: pointer;
            font-size: 16px;
            padding: 4px;
            opacity: 0.7;
            transition: opacity 0.2s;
        }
        
        .fx-current-pin:hover {
            opacity: 1;
        }
        
        /* FX Grid Modal */
        .fx-grid-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            z-index: 10001;
            align-items: flex-start;
            justify-content: center;
            padding: 20px;
            animation: fadeIn 0.2s ease-out;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            touch-action: pan-y;
        }
        
        .fx-grid-modal.active,
        .fx-grid-modal[aria-hidden="false"] {
            display: flex;
        }
        
        .fx-grid-modal[aria-hidden="true"] {
            display: none;
        }
        
        .fx-grid-modal-content {
            width: 100%;
            max-width: 1400px;
            background: var(--surface-color, #1e1e1e);
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.6);
            overflow: hidden;
            animation: slideDown 0.2s ease-out;
            max-height: 90vh;
            display: flex;
            flex-direction: column;
            margin: 0;
            position: relative;
            pointer-events: auto;
            color: var(--text-color, #ffffff);
            border: 1px solid var(--border-color, #333);
        }
        
        .fx-grid-modal-content * {
            pointer-events: auto;
        }
        
        .fx-grid-header {
            padding: 20px;
            border-bottom: 1px solid var(--border-color, #333);
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: var(--surface-hover-color, #252525);
        }
        
        .fx-grid-header h2 {
            margin: 0;
            font-size: 24px;
            font-weight: 600;
            color: var(--text-color, #ffffff);
        }
        
        .fx-grid-close {
            background: none;
            border: none;
            color: var(--text-secondary-color, #cccccc);
            cursor: pointer;
            font-size: 28px;
            line-height: 1;
            padding: 8px;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 8px;
            transition: all 0.2s;
            -webkit-tap-highlight-color: transparent;
        }
        
        .fx-grid-close:hover,
        .fx-grid-close:focus {
            background: var(--surface-color, #2a2a2a);
            color: var(--text-color, #ffffff);
            outline: 2px solid var(--accent-color, rgba(255, 215, 0, 0.3));
            outline-offset: 2px;
        }
        
        .fx-grid-container {
            padding: 20px;
            overflow-y: auto;
            flex: 1;
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
            gap: 16px;
            align-items: start;
            -webkit-overflow-scrolling: touch;
            scrollbar-width: thin;
            scrollbar-color: var(--accent-color, #ffd700) transparent;
            box-sizing: border-box;
        }
        
        @media (min-width: 1400px) {
            .fx-grid-container {
                grid-template-columns: repeat(6, 1fr);
            }
        }
        
        .fx-grid-container > * {
            min-width: 0;
            min-height: 0;
        }
        
        .fx-grid-container::-webkit-scrollbar {
            width: 8px;
        }
        
        .fx-grid-container::-webkit-scrollbar-track {
            background: transparent;
        }
        
        .fx-grid-container::-webkit-scrollbar-thumb {
            background: var(--border-color, #555);
            border-radius: 4px;
        }
        
        .fx-grid-container::-webkit-scrollbar-thumb:hover {
            background: var(--border-hover-color, #666);
        }
        
        .fx-grid-item {
            position: relative;
            background: var(--surface-hover-color, #2a2a2a);
            border: 2px solid var(--border-color, #333);
            border-radius: 8px;
            overflow: hidden;
            cursor: pointer;
            transition: border-color 0.2s, box-shadow 0.2s;
            display: flex;
            flex-direction: column;
            aspect-ratio: 4/3;
            -webkit-tap-highlight-color: transparent;
            z-index: 1;
            box-sizing: border-box;
            width: 100%;
            height: 100%;
            contain: layout style paint;
        }
        
        .fx-grid-item.selected {
            z-index: 2;
        }
        
        .fx-grid-item:hover {
            border-color: var(--accent-color, #5250ef);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            z-index: 2;
        }
        
        .fx-grid-item:focus,
        .fx-grid-item:focus-visible {
            outline: 2px solid var(--accent-color, #5250ef);
            outline-offset: -2px;
            border-color: var(--accent-color, #5250ef);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            z-index: 3;
        }
        
        .fx-grid-item.selected {
            border-color: var(--accent-color, #5250ef);
            background: var(--accent-color, #5250ef);
            z-index: 2;
        }
        
        .fx-grid-item-preview {
            flex: 1;
            width: 100%;
            min-width: 0;
            min-height: 0;
            background: #000;
            position: relative;
            overflow: hidden;
        }
        
        .fx-grid-item-preview canvas {
            width: 100%;
            height: 100%;
            max-width: 100%;
            max-height: 100%;
            object-fit: cover;
            display: block;
        }
        
        .fx-grid-item-label {
            padding: 8px 12px;
            font-size: 12px;
            font-weight: 500;
            color: var(--text-color, #ffffff);
            text-align: center;
            background: rgba(0, 0, 0, 0.6);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            min-width: 0;
            flex-shrink: 0;
        }
        
        .fx-grid-item.selected .fx-grid-item-label {
            color: var(--selected-text-color, #000000);
            background: var(--accent-color, #5250ef);
        }
        
        .fx-grid-item-loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: var(--text-secondary-color, #999);
            font-size: 12px;
        }
        
        @media (max-width: 768px) {
            .fx-grid-modal {
                padding: 10px;
            }
            
            .fx-grid-modal-content {
                max-height: 95vh;
                border-radius: 8px;
            }
            
            .fx-grid-header {
                padding: 16px;
            }
            
            .fx-grid-header h2 {
                font-size: 20px;
            }
            
            .fx-grid-container {
                padding: 12px;
                grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
                gap: 12px;
            }
            
            .fx-grid-item-label {
                font-size: 11px;
                padding: 6px 8px;
            }
        }
        
        .fx-search-input {
            width: 100%;
            padding: 8px;
            background: var(--surface-color, #1a1a1a);
            color: var(--text-color, white);
            border: 1px solid var(--border-color, #333);
            border-radius: 4px;
            font-size: 12px;
        }
        
        .pinned-fx-container {
            margin-bottom: 10px;
            min-height: 20px;
        }
        
        .pinned-fx-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 10px;
            margin-bottom: 4px;
            background: var(--surface-hover-color, #2a2a2a);
            border: 1px solid var(--border-color, #333);
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
            user-select: none;
            transition: all 0.2s;
            width: 100%;
        }
        
        .pinned-fx-item:hover {
            background: var(--accent-color, #5250ef);
            border-color: var(--accent-color, #5250ef);
        }
        
        .pinned-fx-item-text {
            flex: 1;
            cursor: pointer;
        }
        
        .pinned-fx-item-remove {
            cursor: pointer;
            font-size: 18px;
            font-weight: bold;
            opacity: 0.7;
            padding: 0 4px;
        }
        
        .pinned-fx-item-remove:hover {
            opacity: 1;
        }
        
        /* Tutorial Modal */
        .tutorial-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            z-index: 20000;
            align-items: center;
            justify-content: center;
            padding: 20px;
            animation: fadeIn 0.3s ease-out;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
        }
        
        .tutorial-modal[aria-hidden="false"] {
            display: flex;
        }
        
        .tutorial-modal[aria-hidden="true"] {
            display: none;
        }
        
        .tutorial-modal-content {
            width: 100%;
            max-width: 600px;
            background: var(--surface-color, #1e1e1e);
            border-radius: 12px;
            box-shadow: 0 12px 48px rgba(0, 0, 0, 0.8);
            overflow: hidden;
            animation: slideUp 0.3s ease-out;
            color: var(--text-color, #ffffff);
            border: 1px solid var(--border-color, #333);
            display: flex;
            flex-direction: column;
            max-height: 90vh;
        }
        
        @keyframes slideUp {
            from {
                transform: translateY(30px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }
        
        .tutorial-header {
            padding: 24px;
            border-bottom: 1px solid var(--border-color, #333);
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: var(--surface-color, #1e1e1e);
        }
        
        .tutorial-header h2 {
            margin: 0;
            font-size: 24px;
            font-weight: 600;
            color: var(--text-color, #ffffff);
        }
        
        .tutorial-close {
            background: transparent;
            border: none;
            color: var(--text-color, #ffffff);
            font-size: 32px;
            line-height: 1;
            cursor: pointer;
            padding: 0;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            transition: background 0.2s;
        }
        
        .tutorial-close:hover {
            background: var(--surface-hover-color, rgba(255, 255, 255, 0.1));
        }
        
        .tutorial-body {
            padding: 24px;
            flex: 1;
            overflow-y: auto;
        }
        
        .tutorial-step {
            margin-bottom: 32px;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        
        .tutorial-step:last-child {
            margin-bottom: 0;
        }
        
        .tutorial-icon {
            font-size: 48px;
            text-align: center;
            margin-bottom: 8px;
        }
        
        .tutorial-step h3 {
            margin: 0;
            font-size: 20px;
            font-weight: 600;
            color: var(--text-color, #ffffff);
        }
        
        .tutorial-step p {
            margin: 0;
            font-size: 16px;
            line-height: 1.6;
            color: var(--text-secondary-color, #cccccc);
        }
        
        .tutorial-step kbd {
            background: var(--surface-hover-color, #333);
            border: 1px solid var(--border-color, #555);
            border-radius: 4px;
            padding: 2px 6px;
            font-family: monospace;
            font-size: 14px;
            color: var(--text-color, #ffffff);
        }
        
        .tutorial-footer {
            padding: 20px 24px;
            border-top: 1px solid var(--border-color, #333);
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 16px;
            background: var(--surface-color, #1e1e1e);
            flex-wrap: wrap;
        }
        
        .tutorial-checkbox {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            font-size: 14px;
            color: var(--text-secondary-color, #cccccc);
            user-select: none;
        }
        
        .tutorial-checkbox input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }
        
        .tutorial-button {
            background: var(--accent-color, #5250ef);
            color: var(--selected-text-color, #ffffff);
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.2s, transform 0.1s;
            min-width: 120px;
        }
        
        .tutorial-button:hover {
            background: var(--accent-hover-color, #6361ff);
            transform: translateY(-1px);
        }
        
        .tutorial-button:active {
            transform: translateY(0);
        }
        
        @media (max-width: 768px) {
            .tutorial-modal {
                padding: 16px;
            }
            
            .tutorial-modal-content {
                max-width: 100%;
                border-radius: 8px;
                max-height: 95vh;
            }
            
            .tutorial-header {
                padding: 20px;
            }
            
            .tutorial-header h2 {
                font-size: 20px;
            }
            
            .tutorial-body {
                padding: 20px;
            }
            
            .tutorial-step {
                margin-bottom: 24px;
            }
            
            .tutorial-icon {
                font-size: 40px;
            }
            
            .tutorial-step h3 {
                font-size: 18px;
            }
            
            .tutorial-step p {
                font-size: 15px;
            }
            
            .tutorial-footer {
                padding: 16px 20px;
                flex-direction: column;
                align-items: stretch;
            }
            
            .tutorial-button {
                width: 100%;
            }
        }
        
        /* Corner tap areas - invisible but clickable for easy menu access */
        .corner-tap-area {
            position: fixed;
            z-index: 9999;
            background: transparent;
            pointer-events: auto;
            display: block; /* Shown on all screen sizes */
        }
        
        .corner-tap-area.top-left {
            top: 0;
            left: 0;
            width: 80px;
            height: 80px;
        }
        
        .corner-tap-area.top-right {
            top: 0;
            right: 0;
            width: 80px;
            height: 80px;
        }
        
        .corner-tap-area.bottom-left {
            bottom: 0;
            left: 0;
            width: 80px;
            height: 80px;
        }
        
        .corner-tap-area.bottom-right {
            bottom: 0;
            right: 0;
            width: 80px;
            height: 80px;
        }
        
        /* Visibility is controlled by JavaScript based on device type */
    </style>
</head>
<body>
    <div id="loadingIndicator">
        <div class="spinner"></div>
        <div>Loading...</div>
    </div>
    
    <div id="controls" class="hidden">
        <!-- Hide Menu Button -->
        <button id="hideMenuButton" type="button" aria-label="Hide menu">
            <span>âœ•</span> Hide Menu
        </button>
        
        <!-- Settings Section -->
        <div class="settings-section">
            <div class="section-title" id="settingsToggle">Settings</div>
            <div class="settings-section-content">
                <label>
                    Scene:
                    <select id="sceneSelect">
                        <!-- Options will be populated dynamically from scenes/scenes.json -->
                    </select>
                </label>
                <label>
                    Camera:
                    <select id="cameraSelect"></select>
                </label>
                <div class="camera-status">
                    <span id="cameraStatusText">Camera: Stopped</span>
                </div>
                <button id="startButton">Start Camera</button>
                <button id="stopButton" style="display: none;">Stop Camera</button>
                <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid var(--border-color, #333);">
                    <label style="display: block; margin-bottom: 8px;">
                        Face Mask Zoom:
                        <span id="faceMaskZoomDisplay" style="font-weight: bold; color: var(--accent-color, #5250ef);">100%</span>
                    </label>
                    <button id="resetFaceMaskZoomButton" style="width: 100%;">Reset to Default</button>
                </div>
                <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid var(--border-color, #333);">
                    <div style="font-size: 12px; color: var(--text-secondary-color, #cccccc);">
                        <div style="margin-bottom: 4px;">
                            <strong>Version:</strong> <span id="appVersion">1.0.0</span>
                        </div>
                        <div style="margin-bottom: 4px;">
                            <strong>Build:</strong> <span id="appBuild">0</span>
                        </div>
                        <div>
                            <strong>Last Update:</strong> <span id="lastUpdateTime">Never</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Start Roulette Button -->
        <div style="margin-bottom: 20px; padding-bottom: 15px; border-bottom: 1px solid var(--border-color, #333);">
            <button id="startRouletteButton" type="button" style="width: 100%;">ðŸŽ° Start Roulette</button>
        </div>
        
        <!-- Search FX -->
        <div style="margin-bottom: 20px; padding-bottom: 15px; border-bottom: 1px solid var(--border-color, #333);">
            <button id="fxSearchTrigger" class="fx-search-trigger" type="button" style="width: 100%;">
                <span>ðŸ”</span> Search FX...
            </button>
        </div>
        
        <!-- FX Section -->
        <div class="fx-section expanded">
            <div class="section-title expanded" id="fxToggle">FX</div>
            <div class="fx-section-content">
                <label>
                    Current FX:
                    <div class="current-fx-display">
                        <span id="fxSelectedText">None (Original)</span>
                        <div class="current-fx-actions">
                            <span id="fxCurrentPin" class="fx-current-pin" style="display: none !important;" title="Pin current FX"></span>
                            <button id="clearFilterButton" class="clear-filter-button" type="button" title="Clear filter (C)" style="display: none;">âœ•</button>
                        </div>
                    </div>
                </label>
            </div>
        </div>
        
        <!-- Help Section -->
        <div class="help-section expanded">
            <div class="section-title expanded" id="helpToggle">Help</div>
            <div class="help-section-content">
                <div class="help-category">
                    <div class="help-category-title">Navigation</div>
                    <div class="help-command" data-action="toggle-ui">
                        <span class="help-command-desc">Toggle UI visibility</span>
                        <span class="help-command-key">H</span>
                    </div>
                    <div class="help-command" data-action="open-search">
                        <span class="help-command-desc">Open FX search</span>
                        <span class="help-command-key"><kbd>F</kbd></span>
                    </div>
                    <div class="help-command" data-action="toggle-wireframe">
                        <span class="help-command-desc">Toggle wireframe overlay</span>
                        <span class="help-command-key">W</span>
                    </div>
                    <div class="help-command" data-action="toggle-grid">
                        <span class="help-command-desc">Show grid</span>
                        <span class="help-command-key">G</span>
                    </div>
                </div>
                
                <div class="help-category">
                    <div class="help-category-title">Grid Navigation</div>
                    <div class="help-command" data-action="grid-navigate">
                        <span class="help-command-desc">Move around in grid</span>
                        <span class="help-command-key">â†‘ â†“ â† â†’</span>
                    </div>
                    <div class="help-command" data-action="grid-select">
                        <span class="help-command-desc">Select highlighted filter</span>
                        <span class="help-command-key">Enter</span>
                    </div>
                </div>
                
                <div class="help-category">
                    <div class="help-category-title">Filter Controls</div>
                    <div class="help-command" data-action="prev-filter">
                        <span class="help-command-desc">Previous filter</span>
                        <span class="help-command-key">â†‘ / â†</span>
                    </div>
                    <div class="help-command" data-action="next-filter">
                        <span class="help-command-desc">Next filter</span>
                        <span class="help-command-key">â†“ / â†’</span>
                    </div>
                    <div class="help-command" data-action="random-cycle">
                        <span class="help-command-desc">Random cycle</span>
                        <span class="help-command-key">Space</span>
                    </div>
                    <div class="help-command" data-action="clear-filter">
                        <span class="help-command-desc">Clear filter</span>
                        <span class="help-command-key">C / Esc</span>
                    </div>
                </div>
                
                <div class="help-category">
                    <div class="help-category-title">Face Mask Controls</div>
                    <div class="help-command" data-action="increase-mask" id="helpIncreaseMask">
                        <span class="help-command-desc">Increase mask size</span>
                        <span class="help-command-key">+ / =</span>
                    </div>
                    <div class="help-command" data-action="decrease-mask" id="helpDecreaseMask">
                        <span class="help-command-desc">Decrease mask size</span>
                        <span class="help-command-key">- / _</span>
                    </div>
                    <div class="help-command">
                        <span class="help-command-desc">(Only active when face mask filter is selected)</span>
                        <span class="help-command-key" style="visibility: hidden;"></span>
                    </div>
                </div>
                
                <div class="help-category">
                    <div class="help-category-title">Tips</div>
                    <div style="color: var(--text-secondary-color, #cccccc); font-size: 11px; line-height: 1.5;">
                        â€¢ Use search (F) to quickly find filters<br>
                        â€¢ Press H to hide/show the UI for clean video capture<br>
                        â€¢ Tap any corner of the screen to open the menu
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Spotlight-style FX Search Modal - Outside controls for full viewport coverage -->
    <div 
        id="fxSearchModal" 
        class="fx-search-modal" 
        role="dialog" 
        aria-modal="true" 
        aria-labelledby="fxSearchModalTitle" 
        aria-hidden="true"
        tabindex="-1"
    >
        <div class="fx-search-modal-content">
            <div class="fx-search-header">
                <h2 id="fxSearchModalTitle" class="sr-only">Search Filters</h2>
                <label for="fxSearchInput" class="sr-only">Search for filters</label>
                <div class="fx-search-input-wrapper">
                    <svg class="fx-search-icon" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
                        <circle cx="11" cy="11" r="8"></circle>
                        <path d="m21 21-4.35-4.35"></path>
                    </svg>
                    <input 
                        type="text" 
                        id="fxSearchInput" 
                        class="fx-search-input" 
                        placeholder="Search filters and face masks..." 
                        autocomplete="off"
                        aria-label="Search filters"
                        aria-describedby="fxSearchHint"
                        aria-controls="fxSearchResults"
                        aria-expanded="false"
                    >
                    <button 
                        class="fx-search-clear" 
                        id="fxSearchClear" 
                        type="button" 
                        aria-label="Clear search"
                        tabindex="0"
                    >Ã—</button>
                </div>
                <span id="fxSearchHint" class="sr-only">Type to search filters. Press Escape to close, Enter to select first result.</span>
            </div>
            <div 
                class="fx-search-results" 
                id="fxSearchResults" 
                role="listbox" 
                aria-label="Filter options"
                aria-live="polite"
                aria-atomic="false"
            >
                <div id="fxOptionsContainer" class="fx-dropdown-menu" role="group"></div>
            </div>
        </div>
    </div>
    
    <!-- FX Grid Modal -->
    <div 
        id="fxGridModal" 
        class="fx-grid-modal" 
        role="dialog" 
        aria-modal="true" 
        aria-labelledby="fxGridModalTitle" 
        aria-hidden="true"
        tabindex="-1"
    >
        <div class="fx-grid-modal-content">
            <div class="fx-grid-header">
                <h2 id="fxGridModalTitle">FX Grid</h2>
                <button 
                    class="fx-grid-close" 
                    id="fxGridClose" 
                    type="button" 
                    aria-label="Close grid"
                    tabindex="0"
                >Ã—</button>
            </div>
            <div 
                class="fx-grid-container" 
                id="fxGridContainer" 
                role="grid"
                aria-label="Filter grid"
            >
                <!-- Grid items will be dynamically generated -->
            </div>
        </div>
    </div>
    
    <div id="status" class="hidden">Initializing...</div>
    
    <!-- Corner tap areas - invisible but clickable for easy menu access -->
    <div class="corner-tap-area top-left" id="cornerTopLeft" aria-label="Tap to open menu"></div>
    <div class="corner-tap-area top-right" id="cornerTopRight" aria-label="Tap to open menu"></div>
    <div class="corner-tap-area bottom-left" id="cornerBottomLeft" aria-label="Tap to open menu"></div>
    <div class="corner-tap-area bottom-right" id="cornerBottomRight" aria-label="Tap to open menu"></div>
    
    <div id="currentFxOverlay">
        <span class="fx-label">FX:</span>
        <span class="fx-name" id="currentFxOverlayName">None</span>
    </div>
    
    <div id="videoContainer">
        <video id="videoInput" autoplay playsinline muted></video>
        <canvas id="canvasOutput"></canvas>
    </div>
    
    <!-- MediaPipe Face Detection (WASM) -->
    <script type="module">
        import { FaceLandmarker, FilesetResolver } from 'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3';
        
        // Production detection: hide console logs in production (not localhost or file://)
        const isDevelopment = (() => {
            const hostname = window.location.hostname;
            const protocol = window.location.protocol;
            // Development if: localhost, 127.0.0.1, file:// protocol, or any IP address (likely local dev)
            return hostname === 'localhost' || 
                   hostname === '127.0.0.1' || 
                   hostname.startsWith('192.168.') ||
                   hostname.startsWith('10.') ||
                   protocol === 'file:';
        })();
        
        // Store original console methods
        const originalConsole = {
            log: console.log.bind(console),
            warn: console.warn.bind(console),
            info: console.info.bind(console),
            error: console.error.bind(console)
        };
        
        // Override console methods to only log in development
        console.log = function(...args) {
            if (isDevelopment) {
                originalConsole.log(...args);
            }
        };
        
        console.warn = function(...args) {
            if (isDevelopment) {
                const message = args.join(' ');
                // Suppress MediaPipe warnings even in development (they're just noise)
                if (message.includes('Face blendshape model contains CPU only ops') ||
                    message.includes('OpenGL error checking is disabled') ||
                    message.includes('Sets FaceBlendshapesGraph acceleration')) {
                    return; // Suppress MediaPipe warnings
                }
                // Suppress CORS warnings when using file:// protocol (we handle with embedded data)
                if (window.location.protocol === 'file:' && 
                    (message.includes('CORS') || message.includes('Cross origin') || 
                     message.includes('Could not load') && (message.includes('scenes') || message.includes('build-info')))) {
                    return; // Suppress CORS warnings for file:// protocol
                }
                originalConsole.warn(...args);
            }
        };
        
        console.info = function(...args) {
            if (isDevelopment) {
                const message = args.join(' ');
                // Suppress MediaPipe info messages even in development (they're just noise)
                if (message.includes('GL version:') || 
                    message.includes('renderer:') ||
                    message.includes('Graph successfully started') ||
                    message.includes('Created TensorFlow Lite') ||
                    message.includes('XNNPACK delegate')) {
                    return; // Suppress MediaPipe info messages
                }
                originalConsole.info(...args);
            }
        };
        
        // console.error always logs real errors, but we'll filter MediaPipe noise and expected errors
        console.error = function(...args) {
            const message = args.join(' ');
            
            // Suppress MediaPipe internal log messages that come through as errors
            if (message.includes('vision_wasm_internal') || message.includes('installHook.js')) {
                // Suppress MediaPipe/TensorFlow info messages that come through as errors
                if (message.includes('W1207') || message.includes('I1207') || message.includes('I1208') ||
                    message.includes('INFO:') || message.includes('Created TensorFlow') ||
                    message.includes('XNNPACK delegate') || message.includes('GL version:') ||
                    message.includes('renderer:') || message.includes('Graph successfully started')) {
                    return; // Suppress MediaPipe internal log messages
                }
            }
            
            // Suppress expected 404 errors during mask discovery
            if ((message.includes('face_mask') || message.includes('mask_')) && 
                (message.includes('404') || message.includes('Failed to load') || 
                 message.includes('GET') || message.includes('Not Found'))) {
                return; // Suppress expected mask discovery errors
            }
            
            // Suppress CORS errors when using file:// protocol (we handle with embedded data)
            if (window.location.protocol === 'file:' && 
                (message.includes('CORS') || message.includes('Cross origin') || 
                 message.includes('file://') && message.includes('blocked'))) {
                return; // Suppress CORS errors for file:// protocol
            }
            
            // Log real errors (always, not just in development)
            originalConsole.error(...args);
        };
        
        // Mobile device detection
        function isMobileDevice() {
            // Check user agent for mobile devices
            const userAgent = navigator.userAgent || navigator.vendor || window.opera;
            const mobileRegex = /android|webos|iphone|ipad|ipod|blackberry|iemobile|opera mini/i;
            
            // Also check screen width as a fallback
            const isSmallScreen = window.innerWidth <= 768;
            
            return mobileRegex.test(userAgent) || isSmallScreen;
        }
        
        // Check if device is iPad without keyboard (touch device with large screen)
        function isTabletWithoutKeyboard() {
            // Check if it's a touch device
            const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
            
            // Check if it's iPad (has touch points but might not have keyboard)
            const userAgent = navigator.userAgent || navigator.vendor || window.opera;
            const isIPad = /ipad/i.test(userAgent) || (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
            
            // Check screen size (tablets typically have larger screens)
            const isLargeScreen = window.innerWidth >= 768 && window.innerWidth <= 1024;
            
            return (isTouchDevice && (isIPad || isLargeScreen));
        }
        
        // Check if corner tap areas should be enabled
        function shouldShowCornerTaps() {
            // Allow corner taps on all screen sizes for easy menu access
            return true;
        }
        
        // State
        let faceLandmarker = null;
        let wasmModule = null;
        let localStream = null;
        let testImage = null; // For testing with static images
        let isProcessing = false;
        let currentFilter = '';
        let frameCount = 0;
        let animationFrameId = null;
        let allFilters = [];
        let showWireframe = false;
        let pinnedFilters = [];
        let controlsVisible = true;
        let isRandomCycling = false;
        let randomCycleInterval = null;
        let faceMaskImages = {}; // Cache for face mask images
        let discoveredFaceMasks = []; // Dynamically discovered face mask names
        let maskProcessingCanvas = null; // Cached canvas for mask processing (reused to reduce allocations)
        let maskProcessingCtx = null; // Cached context
        let offscreenCanvas = null; // OffscreenCanvas for better performance (if supported)
        let offscreenCtx = null; // OffscreenCanvas context
        let lastFrameTime = 0; // Frame rate limiting
        const targetFPS = 60;
        let faceMaskScale = 1.0; // Scale factor for face mask size adjustment
        const frameInterval = 1000 / targetFPS;
        
        // Version and build tracking
        const APP_VERSION = '1.0.0';
        let BUILD_INFO = null; // Will be loaded from build-info.json
        
        // Load build info from build-info.json (generated by build script)
        async function loadBuildInfo() {
            // If using file:// protocol, use embedded data immediately
            if (isFileProtocol()) {
                BUILD_INFO = EMBEDDED_BUILD_INFO;
                console.log('Using embedded build info (file:// protocol)');
                return BUILD_INFO;
            }
            
            try {
                const response = await fetch('build-info.json?' + Date.now());
                if (response.ok) {
                    BUILD_INFO = await response.json();
                    console.log('Loaded build info:', BUILD_INFO);
                    return BUILD_INFO;
                } else {
                    console.warn('build-info.json not found or not accessible:', response.status, response.statusText);
                }
            } catch (e) {
                console.warn('Could not load build-info.json:', e.message);
            }
            
            // Fallback: use embedded data or file modification time
            console.warn('Using fallback build info');
            BUILD_INFO = EMBEDDED_BUILD_INFO || {
                buildNumber: 0,
                buildTimestamp: Date.now(),
                commitHash: 'unknown',
                commitTime: Date.now()
            };
            return BUILD_INFO;
        }
        
        // Get build number from build info
        function getBuildNumber() {
            if (BUILD_INFO) {
                return BUILD_INFO.buildNumber || 0;
            }
            return 0;
        }
        
        // Get build timestamp from build info
        function getBuildTimestamp() {
            if (BUILD_INFO && BUILD_INFO.commitTime) {
                return BUILD_INFO.commitTime;
            }
            if (BUILD_INFO && BUILD_INFO.buildTimestamp) {
                return BUILD_INFO.buildTimestamp;
            }
            return Date.now();
        }
        
        // Format time since last update
        function formatTimeSince(timestamp) {
            const now = Date.now();
            const diff = now - timestamp;
            const seconds = Math.floor(diff / 1000);
            const minutes = Math.floor(seconds / 60);
            const hours = Math.floor(minutes / 60);
            const days = Math.floor(hours / 24);
            const weeks = Math.floor(days / 7);
            const months = Math.floor(days / 30);
            
            if (seconds < 60) {
                return `${seconds} sec${seconds !== 1 ? 's' : ''} ago`;
            } else if (minutes < 60) {
                return `${minutes} min${minutes !== 1 ? 's' : ''} ago`;
            } else if (hours < 24) {
                return `${hours} hr${hours !== 1 ? 's' : ''} ago`;
            } else if (days < 7) {
                return `${days} day${days !== 1 ? 's' : ''} ago`;
            } else if (weeks < 4) {
                return `${weeks} week${weeks !== 1 ? 's' : ''} ago`;
            } else if (months < 12) {
                return `${months} month${months !== 1 ? 's' : ''} ago`;
            } else {
                const years = Math.floor(months / 12);
                return `${years} year${years !== 1 ? 's' : ''} ago`;
            }
        }
        
        // Update version display
        function updateVersionDisplay() {
            const versionEl = document.getElementById('appVersion');
            const buildEl = document.getElementById('appBuild');
            const updateEl = document.getElementById('lastUpdateTime');
            
            if (versionEl) {
                versionEl.textContent = APP_VERSION;
            }
            
            if (buildEl) {
                const buildNum = getBuildNumber();
                buildEl.textContent = buildNum.toString();
            }
            
            if (updateEl) {
                const buildTimestamp = getBuildTimestamp();
                updateEl.textContent = formatTimeSince(buildTimestamp);
            }
        }
        
        // Update time display periodically
        function startTimeUpdateInterval() {
            const updateEl = document.getElementById('lastUpdateTime');
            if (updateEl) {
                setInterval(async () => {
                    // Reload build info to get the latest timestamp
                    await loadBuildInfo();
                    const buildTimestamp = getBuildTimestamp();
                    updateEl.textContent = formatTimeSince(buildTimestamp);
                }, 60000); // Update every minute
            }
        }
        
        // Filter categories - will be built from current scene's fx configuration
        // Face masks will be added dynamically after discovery
        let FILTER_CATEGORIES = {
            'DROPOUT': []
        };
        
        // Default filter categories (for organizing when using flat array)
        const DEFAULT_FILTER_CATEGORIES = {
            'DROPOUT': [],
            'Distortion': ['ultimate_distortion', 'bulge', 'stretch', 'swirl', 'fisheye', 'pinch', 'wave', 'mirror',
                          'twirl', 'ripple', 'sphere', 'tunnel', 'water_ripple',
                          'radial_blur', 'cylinder', 'barrel', 'pincushion', 'whirlpool', 'radial_zoom',
                          'concave', 'convex', 'spiral', 'radial_stretch', 'radial_compress',
                          'vertical_wave', 'horizontal_wave', 'skew_horizontal', 'skew_vertical',
                          'rotate_zoom', 'radial_wave', 'zoom_in', 'zoom_out', 'fast_zoom_in',
                          'fast_zoom_out', 'shake', 'pulse', 'spiral_zoom', 'extreme_closeup',
                          'puzzle', 'rotate', 'rotate_45', 'rotate_90', 'flip_horizontal',
                          'flip_vertical', 'flip_both', 'upside_down', 'quad_mirror', 'tile', 'radial_tile',
                          'zoom_blur', 'melt', 'kaleidoscope', 'glitch', 'double_vision',
                          'multi_ripple', 'radial_squeeze', 'elastic_stretch', 'lens_distortion',
                          'wave_distortion', 'squeeze_horizontal', 'squeeze_vertical', 'radial_wobble', 'complex_ripple',
                          'squish_face', 'stretch_face', 'funhouse_mirror', 'pinch_cheeks', 'bulge_eyes',
                          'warp_face', 'funny_squash', 'funny_stretch', 'wobble_face', 'elastic_face',
                          'gentle_ripple', 'smush_face'],
            'Color & Style': ['black_white', 'sepia', 'vintage', 'neon_glow',
                             'pixelate', 'blur', 'sharpen', 'emboss', 'red_tint', 'blue_tint',
                             'green_tint', 'rainbow', 'negative', 'posterize', 'sketch', 'cartoon',
                             'thermal', 'ice', 'ocean', 'plasma', 'jet', 'turbo', 'inferno',
                             'magma', 'viridis', 'cool', 'hot', 'spring', 'summer', 'autumn',
                             'winter', 'rainbow_shift', 'acid_trip', 'vhs', 'retro', 'cyberpunk',
                             'anime', 'glow', 'solarize', 'edge_detect', 'halftone']
        };
        
        // Build filter categories from current scene
        function buildFilterCategories() {
            const currentSceneKey = sceneSelect ? sceneSelect.value : 'dropout';
            const currentScene = SCENES[currentSceneKey];
            
            // Preserve DROPOUT face masks (added dynamically)
            const existingDropoutMasks = (FILTER_CATEGORIES['DROPOUT'] || []).filter(
                f => f.includes('face_mask')
            );
            
            // Start with DROPOUT (face masks preserved)
            FILTER_CATEGORIES = {
                'DROPOUT': existingDropoutMasks
            };
            
            // Process scene's fx configuration
            if (currentScene && currentScene.fx) {
                if (Array.isArray(currentScene.fx)) {
                    // Flat array: filter default categories to only include enabled filters
                    const enabledFilters = new Set(currentScene.fx);
                    
                    Object.entries(DEFAULT_FILTER_CATEGORIES).forEach(([category, filters]) => {
                        if (category !== 'DROPOUT') {
                            FILTER_CATEGORIES[category] = filters.filter(f => enabledFilters.has(f));
                        }
                    });
                } else if (typeof currentScene.fx === 'object') {
                    // Groups: use the groups directly
                    Object.entries(currentScene.fx).forEach(([groupName, filters]) => {
                        if (groupName !== 'DROPOUT') {
                            FILTER_CATEGORIES[groupName] = Array.isArray(filters) ? filters : [];
                        }
                    });
                }
            } else {
                // No fx config: use all default categories
                Object.entries(DEFAULT_FILTER_CATEGORIES).forEach(([category, filters]) => {
                    if (category !== 'DROPOUT') {
                        FILTER_CATEGORIES[category] = [...filters];
                    }
                });
            }
            
            // Rebuild flat filter list
            allFilters.length = 0;
            Object.values(FILTER_CATEGORIES).forEach(categoryFilters => {
                allFilters.push(...categoryFilters);
            });
        }
        
        // Elements
        const videoInput = document.getElementById('videoInput');
        const canvasOutput = document.getElementById('canvasOutput');
        const ctx = canvasOutput.getContext('2d', { willReadFrequently: true });
        const cameraSelect = document.getElementById('cameraSelect');
        // Legacy dropdown removed - using modal search instead
        const fxSelectedText = document.getElementById('fxSelectedText');
        const fxCurrentPin = document.getElementById('fxCurrentPin');
        const clearFilterButton = document.getElementById('clearFilterButton');
        const fxOptionsContainer = document.getElementById('fxOptionsContainer');
        const fxSearchInput = document.getElementById('fxSearchInput');
        const fxSearchTrigger = document.getElementById('fxSearchTrigger');
        const fxSearchModal = document.getElementById('fxSearchModal');
        const fxSearchClear = document.getElementById('fxSearchClear');
        const fxGridModal = document.getElementById('fxGridModal');
        const fxGridContainer = document.getElementById('fxGridContainer');
        const fxGridClose = document.getElementById('fxGridClose');
        const pinnedFxContainer = document.getElementById('pinnedFxContainer');
        const currentFxOverlay = document.getElementById('currentFxOverlay');
        const currentFxOverlayName = document.getElementById('currentFxOverlayName');
        const startButton = document.getElementById('startButton');
        const stopButton = document.getElementById('stopButton');
        const statusDiv = document.getElementById('status');
        const cameraStatusText = document.getElementById('cameraStatusText');
        const controls = document.getElementById('controls');
        const sceneSelect = document.getElementById('sceneSelect');
        const loadingIndicator = document.getElementById('loadingIndicator');
        const testImageInput = document.getElementById('testImageInput');
        const videoContainer = document.getElementById('videoContainer');
        // Legacy dropdown elements (may not exist if using modal search)
        const fxDropdownMenu = document.getElementById('fxDropdownMenu');
        const fxDropdownButton = document.getElementById('fxDropdownButton');
        const clearTestImageButton = document.getElementById('clearTestImageButton');
        
        // Check WASM support
        const wasmSupported = typeof WebAssembly !== 'undefined';
        
        // Format filter name for display
        function formatFilterName(filter) {
            if (!filter) return 'None (Original)';
            return filter.split('_').map(word => 
                word.charAt(0).toUpperCase() + word.slice(1)
            ).join(' ');
        }
        
        // Update status (status widget removed, only update camera status in settings)
        function updateStatus(message, className = '') {
            // Status widget is hidden, but keep function for compatibility
            // Update camera status text in settings section
            if (cameraStatusText) {
                if (className === 'connected' && message.includes('Camera')) {
                    cameraStatusText.textContent = 'Camera: Active';
                    cameraStatusText.parentElement.className = 'camera-status connected';
                } else if (message.includes('Camera stopped') || message.includes('Stopped')) {
                    cameraStatusText.textContent = 'Camera: Stopped';
                    cameraStatusText.parentElement.className = 'camera-status stopped';
                } else if (className === 'error' && message.includes('Camera')) {
                    cameraStatusText.textContent = 'Camera: Error';
                    cameraStatusText.parentElement.className = 'camera-status error';
                }
            }
        }
        
        // Initialize MediaPipe Face Landmarker
        async function initFaceDetection() {
            try {
                // Console suppression is handled globally at the top of the script
                const vision = await FilesetResolver.forVisionTasks(
                    "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm"
                );
                
                faceLandmarker = await FaceLandmarker.createFromOptions(vision, {
                    baseOptions: {
                        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task`,
                        delegate: "GPU"
                    },
                    outputFaceBlendshapes: false,
                    runningMode: "VIDEO",
                    numFaces: 1
                });
                
                console.log('MediaPipe Face Landmarker initialized');
                return true;
            } catch (error) {
                console.error('Failed to initialize MediaPipe:', error);
                return false;
            }
        }
        
        // Initialize WASM module (placeholder - will load actual module when built)
        async function initWasm() {
            if (!wasmSupported) {
                console.warn('WebAssembly not supported. Using JavaScript filters.');
                return false;
            }
            
            try {
                // TODO: Load actual WASM module when built
                // const wwfx = new WWFXWasm();
                // await wwfx.init('wasm/wwfx_module.wasm');
                // wasmModule = wwfx;
                
                console.log('WASM module placeholder (using JS filters)');
                return true;
            } catch (error) {
                console.error('Failed to load WASM module:', error);
                return false;
            }
        }
        
        // Track current camera facing mode for mobile toggle
        let currentFacingMode = 'user'; // 'user' = front, 'environment' = back
        let hasFrontCamera = false;
        let hasBackCamera = false;
        
        // Load cameras
        async function loadCameras() {
            try {
                // Request permission first to get camera labels on mobile
                try {
                    await navigator.mediaDevices.getUserMedia({ video: true });
                } catch (e) {
                    // Permission denied or not available, continue anyway
                }
                
                const devices = await navigator.mediaDevices.enumerateDevices();
                const videoDevices = devices.filter(device => device.kind === 'videoinput');
                
                cameraSelect.innerHTML = '';
                
                // Detect front and back cameras on mobile
                hasFrontCamera = false;
                hasBackCamera = false;
                
                videoDevices.forEach(device => {
                    const option = document.createElement('option');
                    option.value = device.deviceId;
                    const label = device.label || `Camera ${cameraSelect.options.length + 1}`;
                    option.textContent = label;
                    cameraSelect.appendChild(option);
                    
                    // Check if this is a front or back camera based on label
                    const labelLower = label.toLowerCase();
                    if (labelLower.includes('front') || labelLower.includes('user') || labelLower.includes('face')) {
                        hasFrontCamera = true;
                    }
                    if (labelLower.includes('back') || labelLower.includes('rear') || labelLower.includes('environment')) {
                        hasBackCamera = true;
                    }
                });
                
                // Also check if we can detect by trying constraints (for mobile)
                if (isMobileDevice() && videoDevices.length >= 2) {
                    // If we have 2+ cameras on mobile, assume we have both front and back
                    hasFrontCamera = true;
                    hasBackCamera = true;
                }
                
                // Load saved camera
                const savedCamera = localStorage.getItem('wesworld-fx-camera');
                if (savedCamera) {
                    cameraSelect.value = savedCamera;
                }
            } catch (error) {
                console.error('Error loading cameras:', error);
            }
        }
        
        // Toggle between front and back camera
        async function toggleCamera() {
            if (!localStream) {
                return; // Can't toggle if camera isn't running
            }
            
            // Switch facing mode
            currentFacingMode = currentFacingMode === 'user' ? 'environment' : 'user';
            
            // Stop current stream and cancel animation frame
            localStream.getTracks().forEach(track => track.stop());
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
            
            // Start new stream with new facing mode
            try {
                const constraints = {
                    video: {
                        facingMode: currentFacingMode,
                        width: { ideal: 1280 },
                        height: { ideal: 720 }
                    }
                };
                
                localStream = await navigator.mediaDevices.getUserMedia(constraints);
                
                // Ensure video element has required attributes
                videoInput.setAttribute('autoplay', '');
                videoInput.setAttribute('playsinline', '');
                videoInput.setAttribute('muted', '');
                
                videoInput.srcObject = localStream;
                
                // Force play on mobile with retries
                let playAttempts = 0;
                const maxPlayAttempts = 5;
                const tryPlay = async () => {
                    try {
                        await videoInput.play();
                        console.log('Video play successful after toggle');
                    } catch (playError) {
                        playAttempts++;
                        if (playAttempts < maxPlayAttempts) {
                            console.warn(`Video play() attempt ${playAttempts} failed after toggle, retrying:`, playError);
                            setTimeout(tryPlay, 100 * playAttempts);
                        } else {
                            console.warn('Video play() failed after toggle after max attempts:', playError);
                        }
                    }
                };
                await tryPlay();
                
                // Wait for video to be ready and restart processing
                let isInitialized = false;
                const initializeAfterToggle = () => {
                    if (isInitialized) return;
                    
                    if (videoInput.readyState >= 2 && videoInput.videoWidth > 0 && videoInput.videoHeight > 0) {
                        isInitialized = true;
                        
                        canvasOutput.width = videoInput.videoWidth;
                        canvasOutput.height = videoInput.videoHeight;
                        
                        // Ensure video is playing
                        if (videoInput.paused) {
                            videoInput.play().catch(err => console.warn('Play failed in initializeAfterToggle:', err));
                        }
                        
                        // Start processing loop
                        if (!animationFrameId) {
                            processVideoFrame();
                        }
                    }
                };
                
                // Handle video ready events
                videoInput.onloadedmetadata = () => {
                    console.log('Video metadata loaded after toggle');
                    initializeAfterToggle();
                };
                
                videoInput.addEventListener('loadeddata', () => {
                    console.log('Video data loaded after toggle');
                    initializeAfterToggle();
                }, { once: true });
                
                videoInput.addEventListener('canplay', () => {
                    console.log('Video can play after toggle');
                    initializeAfterToggle();
                }, { once: true });
                
                // Fallback: check periodically
                let checkCount = 0;
                const maxChecks = 30;
                const checkInterval = setInterval(() => {
                    checkCount++;
                    if (isInitialized) {
                        clearInterval(checkInterval);
                    } else if (checkCount >= maxChecks) {
                        clearInterval(checkInterval);
                        if (!isInitialized && videoInput.readyState >= 1) {
                            console.warn('Forcing video initialization after toggle timeout');
                            canvasOutput.width = videoInput.videoWidth || 640;
                            canvasOutput.height = videoInput.videoHeight || 480;
                            isInitialized = true;
                            if (!animationFrameId) {
                                processVideoFrame();
                            }
                        }
                    } else {
                        initializeAfterToggle();
                    }
                }, 100);
                
                // Save preference
                localStorage.setItem('wesworld-fx-camera-facing', currentFacingMode);
            } catch (error) {
                console.error('Error toggling camera:', error);
                updateStatus('Camera toggle error: ' + error.message, 'error');
                // Revert facing mode on error
                currentFacingMode = currentFacingMode === 'user' ? 'environment' : 'user';
            }
        }
        
        // Load pinned filters
        function loadPinnedFilters() {
            try {
                const saved = localStorage.getItem('wesworld-fx-pinned');
                if (saved) {
                    pinnedFilters = JSON.parse(saved);
                } else {
                    pinnedFilters = [];
                }
                updatePinnedFxDisplay();
            } catch (error) {
                console.error('Error loading pinned filters:', error);
                pinnedFilters = [];
            }
        }
        
        // Save pinned filters
        function savePinnedFilters() {
            try {
                localStorage.setItem('wesworld-fx-pinned', JSON.stringify(pinnedFilters));
            } catch (error) {
                console.error('Error saving pinned filters:', error);
            }
        }
        
        // Update pinned FX display
        function updatePinnedFxDisplay() {
            if (!pinnedFxContainer) {
                return; // Pinned FX container removed from UI
            }
            pinnedFxContainer.innerHTML = '';
            
            if (pinnedFilters.length === 0) {
                return;
            }
            
            pinnedFilters.forEach(filterName => {
                const item = document.createElement('div');
                item.className = 'pinned-fx-item';
                item.dataset.filterName = filterName;
                // Make entire item clickable to load filter directly (stop roulette if running)
                item.onclick = () => {
                    // Stop any ongoing roulette
                    if (isRandomCycling && randomCycleInterval) {
                        clearInterval(randomCycleInterval);
                        randomCycleInterval = null;
                        isRandomCycling = false;
                    }
                    // Directly select the filter
                    selectFilter(filterName);
                };
                
                const text = document.createElement('span');
                text.className = 'pinned-fx-item-text';
                text.textContent = formatFilterName(filterName);
                
                const remove = document.createElement('span');
                remove.className = 'pinned-fx-item-remove';
                remove.textContent = 'Ã—';
                remove.onclick = (e) => {
                    e.stopPropagation();
                    unpinFilter(filterName);
                };
                
                item.appendChild(text);
                item.appendChild(remove);
                pinnedFxContainer.appendChild(item);
            });
        }
        
        // Pin current filter
        function pinCurrentFilter() {
            if (currentFilter && !pinnedFilters.includes(currentFilter)) {
                pinnedFilters.unshift(currentFilter);
                savePinnedFilters();
                updatePinnedFxDisplay();
                updateCurrentPinIcon();
                loadFilters();
            }
        }
        
        // Unpin filter
        function unpinFilter(filterName) {
            pinnedFilters = pinnedFilters.filter(f => f !== filterName);
            savePinnedFilters();
            updatePinnedFxDisplay();
            if (currentFilter === filterName) {
                updateCurrentPinIcon();
            }
            loadFilters();
        }
        
        // Update current pin icon (disabled - pinning is hidden)
        function updateCurrentPinIcon() {
            // Pinning is disabled - always hide the pin icon
            if (fxCurrentPin) {
                fxCurrentPin.style.display = 'none';
            }
        }
        
        // Load filters
        function loadFilters() {
            fxOptionsContainer.innerHTML = '';
            
            // Add "None" option
            const noneOption = document.createElement('button');
            noneOption.className = 'fx-option' + (currentFilter === '' ? ' selected' : '');
            noneOption.textContent = 'None (Original)';
            noneOption.value = '';
            const handleNoneClick = (e) => {
                e.preventDefault();
                e.stopPropagation();
                selectFilter('');
                closeFxSearchModal();
            };
            noneOption.onclick = handleNoneClick;
            // Also handle touch events for mobile
            noneOption.addEventListener('touchend', (e) => {
                e.preventDefault();
                e.stopPropagation();
                handleNoneClick(e);
            }, { passive: false });
            fxOptionsContainer.appendChild(noneOption);
            
            // Add filters by category
            Object.entries(FILTER_CATEGORIES).forEach(([category, filters]) => {
                const group = document.createElement('div');
                group.className = 'fx-group';
                
                const groupTitle = document.createElement('div');
                groupTitle.className = 'fx-group-title';
                groupTitle.textContent = category;
                group.appendChild(groupTitle);
                
                // Sort filters alphabetically by formatted name
                const sortedFilters = [...filters].sort((a, b) => {
                    const nameA = formatFilterName(a).toLowerCase();
                    const nameB = formatFilterName(b).toLowerCase();
                    return nameA.localeCompare(nameB);
                });
                
                sortedFilters.forEach(filter => {
                    // Skip if pinned (shown in pinned section)
                    if (pinnedFilters.includes(filter)) return;
                    
                    const option = createFxOption(filter);
                    group.appendChild(option);
                });
                
                if (group.children.length > 1) { // Has title + at least one option
                    fxOptionsContainer.appendChild(group);
                }
            });
        }
        
        // Create FX option
        function createFxOption(filter) {
            const option = document.createElement('button');
            option.className = 'fx-option' + (currentFilter === filter ? ' selected' : '');
            option.value = filter;
            option.type = 'button'; // Prevent form submission
            option.setAttribute('role', 'option');
            option.setAttribute('aria-selected', currentFilter === filter ? 'true' : 'false');
            option.setAttribute('aria-label', `Apply filter: ${formatFilterName(filter)}`);
            option.setAttribute('tabindex', '0');
            
            if (filter.includes('face_mask')) {
                const optionText = document.createElement('span');
                optionText.className = 'fx-option-text';
                optionText.textContent = formatFilterName(filter);
                
                const optionImage = document.createElement('img');
                optionImage.className = 'fx-option-image';
                const parts = filter.split('_');
                const optionName = parts[parts.length - 1];
                if (filter.startsWith('dropout_')) {
                    // Use mask_<name>.png pattern for dropout face masks
                    optionImage.src = `assets/dropout/face_mask/mask_${optionName}.png`;
                }
                optionImage.alt = formatFilterName(filter);
                optionImage.setAttribute('aria-hidden', 'true'); // Decorative image
                optionImage.onerror = function() {
                    this.style.display = 'none';
                };
                
                option.appendChild(optionImage);
                option.appendChild(optionText);
            } else {
                const optionText = document.createElement('span');
                optionText.className = 'fx-option-text';
                optionText.textContent = formatFilterName(filter);
                option.appendChild(optionText);
            }
            
            // Pin icon creation disabled - pinning is hidden
            // if (filter) {
            //     const pinIcon = document.createElement('button');
            //     ... pin icon code ...
            //     option.appendChild(pinIcon);
            // }
            
            // Handle both click and touch events for better mobile/desktop support
            const handleOptionClick = (e) => {
                e.preventDefault();
                e.stopPropagation();
                selectFilter(filter);
                closeFxSearchModal();
            };
            
            option.onclick = handleOptionClick;
            
            // Longpress detection for mobile to open search modal
            let touchStartTime = 0;
            let longPressTimer = null;
            let longPressDetected = false;
            const LONG_PRESS_DURATION = 500; // 500ms for longpress
            
            option.addEventListener('touchstart', (e) => {
                touchStartTime = Date.now();
                longPressDetected = false;
                longPressTimer = setTimeout(() => {
                    // Longpress detected - open search modal instead
                    longPressDetected = true;
                    openFxSearchModal();
                    // Focus the search input
                    setTimeout(() => {
                        if (fxSearchInput) {
                            fxSearchInput.focus();
                        }
                    }, 100);
                }, LONG_PRESS_DURATION);
            }, { passive: true });
            
            // Also handle touch events explicitly for mobile
            option.addEventListener('touchend', (e) => {
                // Clear the longpress timer
                if (longPressTimer) {
                    clearTimeout(longPressTimer);
                    longPressTimer = null;
                }
                
                // Only handle as normal click if it wasn't a longpress
                if (!longPressDetected) {
                    e.preventDefault();
                    e.stopPropagation();
                    handleOptionClick(e);
                } else {
                    // Reset the flag for next interaction
                    longPressDetected = false;
                }
            }, { passive: false });
            
            option.addEventListener('touchcancel', () => {
                // Clear timer if touch is cancelled
                if (longPressTimer) {
                    clearTimeout(longPressTimer);
                    longPressTimer = null;
                }
                longPressDetected = false;
            }, { passive: true });
            
            // Keyboard support
            option.onkeydown = (e) => {
                if (e.key === 'Enter' || e.key === ' ') {
                    e.preventDefault();
                    handleOptionClick(e);
                } else if (e.key === 'ArrowDown') {
                    e.preventDefault();
                    const next = option.nextElementSibling?.querySelector('.fx-option') || 
                                 option.closest('.fx-group')?.nextElementSibling?.querySelector('.fx-option');
                    if (next) next.focus();
                } else if (e.key === 'ArrowUp') {
                    e.preventDefault();
                    const prev = option.previousElementSibling || 
                                option.closest('.fx-group')?.previousElementSibling?.querySelectorAll('.fx-option');
                    if (prev && prev.length > 0) prev[prev.length - 1].focus();
                }
            };
            
            return option;
        }
        
        // Update clear button visibility
        function updateClearButtonVisibility() {
            if (fxSearchClear && fxSearchInput) {
                if (fxSearchInput.value.trim()) {
                    fxSearchClear.classList.add('visible');
                } else {
                    fxSearchClear.classList.remove('visible');
                }
            }
        }
        
        // Store element that had focus before modal opened (for focus trap)
        let previousActiveElement = null;
        
        // Open FX search modal
        function openFxSearchModal() {
            console.log('openFxSearchModal called', { fxSearchModal, fxSearchInput });
            if (fxSearchModal) {
                // Store current focus for restoration
                previousActiveElement = document.activeElement;
                
                // Update ARIA attributes
                fxSearchModal.setAttribute('aria-hidden', 'false');
                fxSearchModal.classList.add('active');
                // Force display style to ensure it shows
                fxSearchModal.style.display = 'flex';
                
                // Prevent body scroll when modal is open
                document.body.style.overflow = 'hidden';
                
                console.log('Modal class added, active:', fxSearchModal.classList.contains('active'));
                console.log('Modal style display:', fxSearchModal.style.display);
                
                // Load filters if not already loaded
                if (fxOptionsContainer && fxOptionsContainer.children.length === 0) {
                    loadFilters();
                }
                
                // Focus search input after modal opens (accessibility best practice)
                setTimeout(() => {
                    if (fxSearchInput) {
                        fxSearchInput.focus();
                        console.log('Search input focused');
                        // Update clear button visibility
                        if (fxSearchClear) {
                            updateClearButtonVisibility();
                        }
                        // Update aria-expanded
                        fxSearchInput.setAttribute('aria-expanded', 'true');
                    }
                }, 100);
            } else {
                console.error('fxSearchModal element not found!');
            }
        }
        
        // Close FX search modal
        function closeFxSearchModal() {
            if (fxSearchModal) {
                // Update ARIA attributes
                fxSearchModal.setAttribute('aria-hidden', 'true');
                fxSearchModal.classList.remove('active');
                fxSearchModal.style.display = 'none';
                
                // Restore body scroll
                document.body.style.overflow = '';
                
                // Clear search
                if (fxSearchInput) {
                    fxSearchInput.value = '';
                    filterFxOptions('');
                    fxSearchInput.setAttribute('aria-expanded', 'false');
                }
                
                // Restore focus to previous element (accessibility)
                if (previousActiveElement && typeof previousActiveElement.focus === 'function') {
                    try {
                        previousActiveElement.focus();
                    } catch (e) {
                        // Fallback if element is no longer focusable
                        console.warn('Could not restore focus to previous element');
                    }
                }
                previousActiveElement = null;
            }
        }
        
        // FX Grid Modal functions
        let gridPreviewCanvases = new Map(); // Map of filter name to canvas element
        let gridAnimationFrameId = null;
        let gridUpdateInterval = null;
        let gridVisibleItems = new Set();
        
        // Open FX grid modal
        function openFxGridModal() {
            if (fxGridModal) {
                // Store current focus for restoration
                previousActiveElement = document.activeElement;
                
                // Update ARIA attributes
                fxGridModal.setAttribute('aria-hidden', 'false');
                fxGridModal.classList.add('active');
                fxGridModal.style.display = 'flex';
                
                // Prevent body scroll when modal is open
                document.body.style.overflow = 'hidden';
                
                // Always reload grid to ensure it has the latest filters for current scene
                if (fxGridContainer) {
                    loadFxGrid();
                    
                    // Initialize all previews immediately
                    setTimeout(() => {
                        if (videoInput && videoInput.readyState >= 2 && videoInput.videoWidth > 0) {
                            gridPreviewCanvases.forEach((canvas, filterKey) => {
                                const filter = filterKey === 'none' ? '' : filterKey;
                                updateGridPreview(canvas, filter);
                            });
                        }
                    }, 100);
                }
                
                // Start preview updates
                startGridPreviewUpdates();
                
                // Focus first grid item for keyboard navigation
                setTimeout(() => {
                    const firstItem = fxGridContainer?.querySelector('.fx-grid-item');
                    if (firstItem) {
                        firstItem.focus();
                    }
                }, 100);
            }
        }
        
        // Close FX grid modal
        function closeFxGridModal() {
            if (fxGridModal) {
                fxGridModal.setAttribute('aria-hidden', 'true');
                fxGridModal.classList.remove('active');
                fxGridModal.style.display = 'none';
                
                // Restore body scroll
                document.body.style.overflow = '';
                
                // Stop preview updates
                stopGridPreviewUpdates();
                
                // Restore focus to previous element (accessibility)
                if (previousActiveElement && typeof previousActiveElement.focus === 'function') {
                    try {
                        previousActiveElement.focus();
                    } catch (e) {
                        console.warn('Could not restore focus to previous element');
                    }
                }
                previousActiveElement = null;
            }
        }
        
        // Load FX grid with all filters
        function loadFxGrid() {
            if (!fxGridContainer) return;
            
            fxGridContainer.innerHTML = '';
            gridPreviewCanvases.clear();
            
            // Add "None" option first
            const noneItem = createGridItem('');
            fxGridContainer.appendChild(noneItem);
            
            // Collect all filters from all categories
            const allFiltersList = [];
            Object.values(FILTER_CATEGORIES).forEach(categoryFilters => {
                allFiltersList.push(...categoryFilters);
            });
            
            // Sort all filters alphabetically by formatted name
            allFiltersList.sort((a, b) => {
                const nameA = formatFilterName(a).toLowerCase();
                const nameB = formatFilterName(b).toLowerCase();
                return nameA.localeCompare(nameB);
            });
            
            // Add sorted filters to grid
            allFiltersList.forEach(filter => {
                const gridItem = createGridItem(filter);
                fxGridContainer.appendChild(gridItem);
            });
            
            // Update visible items for performance
            updateVisibleGridItems();
        }
        
        // Create a grid item with preview canvas
        function createGridItem(filter) {
            const item = document.createElement('div');
            item.className = 'fx-grid-item' + (currentFilter === filter ? ' selected' : '');
            item.setAttribute('role', 'gridcell');
            item.setAttribute('tabindex', '0');
            item.setAttribute('aria-label', `Apply filter: ${formatFilterName(filter)}`);
            item.dataset.filter = filter || 'none';
            
            const preview = document.createElement('div');
            preview.className = 'fx-grid-item-preview';
            
            const canvas = document.createElement('canvas');
            canvas.width = 200;
            canvas.height = 150;
            canvas.dataset.filter = filter || 'none';
            preview.appendChild(canvas);
            
            const label = document.createElement('div');
            label.className = 'fx-grid-item-label';
            label.textContent = formatFilterName(filter);
            
            item.appendChild(preview);
            item.appendChild(label);
            
            // Store canvas reference (use 'none' for empty filter)
            const filterKey = filter || 'none';
            gridPreviewCanvases.set(filterKey, canvas);
            
            // Handle click
            const handleClick = (e) => {
                e.preventDefault();
                e.stopPropagation();
                selectFilter(filter);
                closeFxGridModal();
            };
            
            item.onclick = handleClick;
            item.addEventListener('touchend', (e) => {
                e.preventDefault();
                e.stopPropagation();
                handleClick(e);
            }, { passive: false });
            
            // Keyboard support
            item.onkeydown = (e) => {
                if (e.key === 'Enter' || e.key === ' ') {
                    e.preventDefault();
                    handleClick(e);
                }
            };
            
            return item;
        }
        
        // Update visible grid items for performance optimization
        function updateVisibleGridItems() {
            if (!fxGridContainer) return;
            
            const containerRect = fxGridContainer.getBoundingClientRect();
            const items = fxGridContainer.querySelectorAll('.fx-grid-item');
            
            gridVisibleItems.clear();
            items.forEach(item => {
                const rect = item.getBoundingClientRect();
                // Check if item is visible (with some margin)
                if (rect.bottom >= containerRect.top - 100 && rect.top <= containerRect.bottom + 100) {
                    const filterKey = item.dataset.filter;
                    if (filterKey) {
                        gridVisibleItems.add(filterKey);
                    }
                }
            });
        }
        
        // Start grid preview updates
        function startGridPreviewUpdates() {
            // Update visible items on scroll
            if (fxGridContainer) {
                fxGridContainer.addEventListener('scroll', updateVisibleGridItems, { passive: true });
            }
            
            // Throttle preview updates to avoid performance issues
            // Update at 10fps instead of full frame rate
            let lastUpdateTime = 0;
            const updateInterval = 100; // 10fps
            
            const updatePreviews = () => {
                if (!fxGridModal || !fxGridModal.classList.contains('active')) {
                    stopGridPreviewUpdates();
                    return;
                }
                
                const now = performance.now();
                if (now - lastUpdateTime >= updateInterval) {
                    lastUpdateTime = now;
                    
                    // Update visible items for scroll tracking
                    updateVisibleGridItems();
                    
                    // Process previews for all items (not just visible ones)
                    // This ensures all previews are rendered when the grid opens
                    if (videoInput && videoInput.readyState >= 2 && videoInput.videoWidth > 0) {
                        gridPreviewCanvases.forEach((canvas, filterKey) => {
                            const filter = filterKey === 'none' ? '' : filterKey;
                            updateGridPreview(canvas, filter);
                        });
                    }
                }
                
                gridAnimationFrameId = requestAnimationFrame(updatePreviews);
            };
            
            updatePreviews();
        }
        
        // Stop grid preview updates
        function stopGridPreviewUpdates() {
            if (gridAnimationFrameId) {
                cancelAnimationFrame(gridAnimationFrameId);
                gridAnimationFrameId = null;
            }
            
            if (fxGridContainer) {
                fxGridContainer.removeEventListener('scroll', updateVisibleGridItems);
            }
        }
        
        // Update a single grid preview
        function updateGridPreview(canvas, filter) {
            if (!videoInput || videoInput.readyState < 2 || videoInput.videoWidth === 0) {
                return;
            }
            
            try {
                const ctx = canvas.getContext('2d');
                if (!ctx) return;
                
                // Get the actual size of the preview container
                const previewContainer = canvas.parentElement;
                if (!previewContainer) return;
                
                const containerRect = previewContainer.getBoundingClientRect();
                const containerWidth = Math.max(containerRect.width || 180, 100);
                const containerHeight = Math.max(containerRect.height || 135, 75);
                
                // Set canvas size to match container (maintain aspect ratio)
                const aspectRatio = videoInput.videoWidth / videoInput.videoHeight;
                const targetHeight = containerWidth / aspectRatio;
                canvas.width = containerWidth;
                canvas.height = Math.min(targetHeight, containerHeight);
                
                // Draw video frame
                ctx.drawImage(videoInput, 0, 0, canvas.width, canvas.height);
                
                // Apply filter if specified
                if (filter) {
                    try {
                        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                        
                        if (wasmModule) {
                            // Use WASM filter processing
                            wasmModule.processFrame(canvas, canvas, filter, null, frameCount);
                        } else {
                            // Fallback to JavaScript filters
                            applyJSFilter(imageData, filter, null);
                            ctx.putImageData(imageData, 0, 0);
                        }
                    } catch (error) {
                        // Canvas might be tainted (CORS), just show video without filter
                        console.warn('Cannot apply filter to preview:', error);
                    }
                }
                
                // Draw wireframe overlay if enabled and filter is active
                if (showWireframe && filter && ctx) {
                    drawWireframeOverlay(ctx, canvas.width, canvas.height, filter);
                }
                
                // Store filter name in dataset for visibility tracking
                canvas.dataset.filter = filter || 'none';
            } catch (error) {
                // Silently handle errors (preview might fail due to CORS, etc.)
            }
        }
        
        // Navigate grid with arrow keys
        function navigateGrid(direction) {
            if (!fxGridContainer) return;
            
            const gridItems = Array.from(fxGridContainer.querySelectorAll('.fx-grid-item'));
            if (gridItems.length === 0) return;
            
            // Get currently focused item or first item
            let currentItem = document.activeElement;
            if (!currentItem || !currentItem.classList.contains('fx-grid-item')) {
                // No item focused, focus the first one
                if (gridItems.length > 0) {
                    gridItems[0].focus();
                    gridItems[0].scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                }
                return;
            }
            
            // Get current item position
            const currentRect = currentItem.getBoundingClientRect();
            const currentCenterX = currentRect.left + currentRect.width / 2;
            const currentCenterY = currentRect.top + currentRect.height / 2;
            
            let bestItem = null;
            let bestDistance = Infinity;
            const threshold = 50; // Maximum distance to consider for adjacent items
            
            gridItems.forEach(item => {
                if (item === currentItem) return;
                
                const itemRect = item.getBoundingClientRect();
                const itemCenterX = itemRect.left + itemRect.width / 2;
                const itemCenterY = itemRect.top + itemRect.height / 2;
                
                let isCandidate = false;
                let distance = Infinity;
                
                switch (direction) {
                    case 'up':
                        // Item should be above current item
                        if (itemCenterY < currentCenterY - threshold) {
                            // Prefer items that are vertically aligned (similar X position)
                            const horizontalDiff = Math.abs(itemCenterX - currentCenterX);
                            if (horizontalDiff < itemRect.width) {
                                distance = currentCenterY - itemCenterY + horizontalDiff * 0.1;
                                isCandidate = true;
                            }
                        }
                        break;
                    case 'down':
                        // Item should be below current item
                        if (itemCenterY > currentCenterY + threshold) {
                            const horizontalDiff = Math.abs(itemCenterX - currentCenterX);
                            if (horizontalDiff < itemRect.width) {
                                distance = itemCenterY - currentCenterY + horizontalDiff * 0.1;
                                isCandidate = true;
                            }
                        }
                        break;
                    case 'left':
                        // Item should be to the left of current item
                        if (itemCenterX < currentCenterX - threshold) {
                            // Prefer items that are horizontally aligned (similar Y position)
                            const verticalDiff = Math.abs(itemCenterY - currentCenterY);
                            if (verticalDiff < itemRect.height) {
                                distance = currentCenterX - itemCenterX + verticalDiff * 0.1;
                                isCandidate = true;
                            }
                        }
                        break;
                    case 'right':
                        // Item should be to the right of current item
                        if (itemCenterX > currentCenterX + threshold) {
                            const verticalDiff = Math.abs(itemCenterY - currentCenterY);
                            if (verticalDiff < itemRect.height) {
                                distance = itemCenterX - currentCenterX + verticalDiff * 0.1;
                                isCandidate = true;
                            }
                        }
                        break;
                }
                
                if (isCandidate && distance < bestDistance) {
                    bestDistance = distance;
                    bestItem = item;
                }
            });
            
            // If no candidate found, wrap around to the opposite side
            if (!bestItem) {
                switch (direction) {
                    case 'up':
                        // Find bottom-most item
                        bestItem = gridItems.reduce((bottom, item) => {
                            const itemRect = item.getBoundingClientRect();
                            const bottomRect = bottom.getBoundingClientRect();
                            return itemRect.bottom > bottomRect.bottom ? item : bottom;
                        });
                        break;
                    case 'down':
                        // Find top-most item
                        bestItem = gridItems.reduce((top, item) => {
                            const itemRect = item.getBoundingClientRect();
                            const topRect = top.getBoundingClientRect();
                            return itemRect.top < topRect.top ? item : top;
                        });
                        break;
                    case 'left':
                        // Find right-most item
                        bestItem = gridItems.reduce((right, item) => {
                            const itemRect = item.getBoundingClientRect();
                            const rightRect = right.getBoundingClientRect();
                            return itemRect.right > rightRect.right ? item : right;
                        });
                        break;
                    case 'right':
                        // Find left-most item
                        bestItem = gridItems.reduce((left, item) => {
                            const itemRect = item.getBoundingClientRect();
                            const leftRect = left.getBoundingClientRect();
                            return itemRect.left < leftRect.left ? item : left;
                        });
                        break;
                }
            }
            
            if (bestItem) {
                bestItem.focus();
                bestItem.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            }
        }
        
        // Update face mask zoom display
        function updateFaceMaskZoomDisplay() {
            const display = document.getElementById('faceMaskZoomDisplay');
            if (display) {
                const percentage = Math.round(faceMaskScale * 100);
                display.textContent = `${percentage}%`;
            }
        }
        
        // Adjust face mask size with keyboard controls
        function adjustFaceMaskSize(delta) {
            faceMaskScale = Math.max(0.5, Math.min(2.0, faceMaskScale + delta));
            try {
                localStorage.setItem('wesworld-fx-face-mask-scale', faceMaskScale.toString());
                console.log('Face mask scale adjusted to:', faceMaskScale.toFixed(2));
                updateFaceMaskZoomDisplay();
            } catch (error) {
                console.error('Error saving face mask scale to localStorage:', error);
            }
        }
        
        // Reset face mask size to default
        function resetFaceMaskSize() {
            faceMaskScale = 1.0;
            try {
                localStorage.setItem('wesworld-fx-face-mask-scale', '1.0');
                console.log('Face mask scale reset to default');
                updateFaceMaskZoomDisplay();
            } catch (error) {
                console.error('Error saving face mask scale to localStorage:', error);
            }
        }
        
        // Discover face mask files dynamically
        // This function attempts to discover available face mask PNG files
        // Expected naming convention: mask_<mask name>.png (e.g., mask_sam.png)
        // Since browser WASM cannot directly access the file system, we use JavaScript to discover files
        let directoryListingAttempted = false;
        async function discoverFaceMasks() {
            // If masks already discovered, don't rediscover
            if (discoveredFaceMasks.length > 0) {
                return discoveredFaceMasks;
            }
            
            console.log('Discovering face mask files (looking for mask_*.png pattern)...');
            discoveredFaceMasks = [];
            const basePath = 'assets/dropout/face_mask/';
            
            // First, try to discover from a directory listing if available (for server environments)
            // This is the most reliable method and doesn't require hardcoded names
            // Only try once to avoid duplicate 404 errors
            if (window.location.protocol !== 'file:' && !directoryListingAttempted) {
                directoryListingAttempted = true;
                try {
                    // Try to fetch directory listing (some servers support this)
                    // Note: Most servers don't support directory listings, so 404 is expected
                    const response = await fetch(basePath).catch(() => null);
                    
                    if (response && response.ok && response.status !== 404) {
                        const text = await response.text();
                        // Parse HTML directory listing for .png files matching mask_*.png pattern
                        const parser = new DOMParser();
                        const doc = parser.parseFromString(text, 'text/html');
                        const links = doc.querySelectorAll('a[href$=".png"]');
                        links.forEach(link => {
                            const fileName = link.getAttribute('href');
                            // Look for files matching mask_<name>.png pattern
                            if (fileName && fileName.startsWith('mask_') && fileName.endsWith('.png')) {
                                const maskName = fileName.replace('mask_', '').replace('.png', '');
                                if (maskName && !discoveredFaceMasks.includes(maskName)) {
                                    discoveredFaceMasks.push(maskName);
                                    console.log('Discovered face mask from directory listing:', maskName);
                                }
                            }
                        });
                    }
                    // Silently ignore 404s - they're expected when directory listing isn't supported
                } catch (error) {
                    // Directory listing not available (404 is expected on most servers)
                    // Silently continue to fallback method - don't log errors
                }
            }
            
            // Fallback: For file:// protocol or when directory listing fails,
            // try to discover by attempting to load files matching mask_*.png pattern
            // We'll try a reasonable range of potential mask names
            if (discoveredFaceMasks.length === 0) {
                console.log('Using fallback discovery method (trying mask_*.png pattern)...');
                
                // Common potential mask names to try (can be extended)
                // These are just common names - the system will discover any mask_*.png file
                const potentialNames = [
                    // No default masks - masks are discovered dynamically
                ];
                
                // Error suppression is handled globally - 404s during discovery are expected
                const discoveryPromises = potentialNames.map(async (maskName) => {
                    const assetPath = `${basePath}mask_${maskName}.png`;
                    
                    return new Promise((resolve) => {
                        const img = new Image();
                        
                        // For file:// protocol, don't set crossOrigin
                        if (window.location.protocol !== 'file:') {
                            img.crossOrigin = 'anonymous';
                        }
                        
                        img.onload = () => {
                            console.log('Discovered face mask:', maskName);
                            if (!discoveredFaceMasks.includes(maskName)) {
                                discoveredFaceMasks.push(maskName);
                            }
                            // Preload the image
                            faceMaskImages[assetPath] = img;
                            resolve({ name: maskName, found: true });
                        };
                        
                        img.onerror = () => {
                            // Mask not found, continue silently (404s are expected during discovery)
                            resolve({ name: maskName, found: false });
                        };
                        
                        img.src = assetPath;
                    });
                });
                
                await Promise.all(discoveryPromises);
            }
            
            console.log('Face mask discovery complete. Found:', discoveredFaceMasks);
            
            // Add discovered masks to filter categories
            if (discoveredFaceMasks.length > 0 && FILTER_CATEGORIES['DROPOUT']) {
                // Remove any existing face mask entries
                FILTER_CATEGORIES['DROPOUT'] = FILTER_CATEGORIES['DROPOUT'].filter(
                    f => !f.includes('face_mask')
                );
                
                // Add discovered masks
                discoveredFaceMasks.forEach(maskName => {
                    FILTER_CATEGORIES['DROPOUT'].push(`dropout_face_mask_${maskName}`);
                });
                
                // Rebuild allFilters array
                allFilters = [];
                Object.values(FILTER_CATEGORIES).forEach(categoryFilters => {
                    allFilters.push(...categoryFilters);
                });
                
                console.log('Updated filter categories with discovered masks');
            }
            
            return discoveredFaceMasks;
        }
        
        // Preload face mask images
        async function preloadFaceMasks() {
            // Masks should already be discovered, but ensure they are
            if (discoveredFaceMasks.length === 0) {
                await discoverFaceMasks();
            }
            
            console.log('Preloading face mask images...');
            
            // Preload all discovered masks (using mask_<name>.png pattern)
            for (const maskName of discoveredFaceMasks) {
                const assetPath = `assets/dropout/face_mask/mask_${maskName}.png`;
                if (!faceMaskImages[assetPath]) {
                    try {
                        const img = new Image();
                        
                        // For file:// protocol, don't set crossOrigin
                        if (window.location.protocol !== 'file:') {
                            img.crossOrigin = 'anonymous';
                        }
                        
                        await new Promise((resolve) => {
                            img.onload = () => {
                                console.log('Preloaded face mask:', assetPath);
                                faceMaskImages[assetPath] = img;
                                resolve();
                            };
                            img.onerror = (err) => {
                                // For file:// protocol, this is expected - images will load on-demand
                                if (window.location.protocol === 'file:') {
                                    console.log('Face mask will load on-demand (file:// protocol):', assetPath);
                                } else {
                                    console.warn('Failed to preload face mask:', assetPath);
                                }
                                resolve(); // Don't reject, just continue - will try to load on-demand
                            };
                            img.src = assetPath;
                        });
                    } catch (error) {
                        // Silently handle errors - will try to load on-demand
                        if (window.location.protocol !== 'file:') {
                            console.warn('Error preloading face mask:', assetPath, error);
                        }
                    }
                }
            }
            console.log('Face mask preloading complete');
        }
        
        // Track if we've already warned about tainted canvas (to avoid spam)
        let taintedCanvasWarned = false;
        
        // Apply face mask to canvas with eye alignment
        function applyFaceMask(ctx, faceRect, faceLandmarks, filterName) {
            // Extract mask name from filter (e.g., dropout_face_mask_<name> -> <name>)
            const parts = filterName.split('_');
            const maskName = parts[parts.length - 1];
            
            // Determine asset path (using mask_<name>.png pattern for dropout masks)
            let assetPath = '';
            if (filterName.startsWith('dropout_')) {
                assetPath = `assets/dropout/face_mask/mask_${maskName}.png`;
            } else if (filterName.startsWith('assets_')) {
                assetPath = `assets/face_mask/${maskName}.png`;
            }
            
            if (!assetPath) {
                return;
            }
            
            // Get cached image (should be preloaded)
            let img = faceMaskImages[assetPath];
            
            // If image not loaded yet, try to load it synchronously (for file:// protocol)
            if (!img || !img.complete || !img.naturalWidth || !img.naturalHeight) {
                // Try to load the image if we're on file:// protocol
                if (window.location.protocol === 'file:') {
                    try {
                        const newImg = new Image();
                        newImg.src = assetPath;
                        if (newImg.complete && newImg.naturalWidth > 0) {
                            img = newImg;
                            faceMaskImages[assetPath] = newImg;
                        } else {
                            // Image not ready, skip this frame
                            return;
                        }
                    } catch (e) {
                        return;
                    }
                } else {
                    // Image not ready yet, skip this frame
                    return;
                }
            }
            
            // Save context state
            ctx.save();
            
            // Calculate eye positions from MediaPipe landmarks
            // MediaPipe Face Landmarker provides 468 landmarks
            // Left eye landmarks: 33, 7, 163, 144, 145, 153, 154, 155, 133, 173, 157, 158, 159, 160, 161, 246
            // Right eye landmarks: 362, 382, 381, 380, 374, 373, 390, 249, 263, 466, 388, 387, 386, 385, 384, 398
            let leftEyeX = 0, leftEyeY = 0, rightEyeX = 0, rightEyeY = 0;
            let leftEyeCount = 0, rightEyeCount = 0;
            
            if (faceLandmarks && faceLandmarks.length >= 468) {
                // Left eye key points
                const leftEyeIndices = [33, 7, 163, 144, 145, 153, 154, 155, 133, 173, 157, 158, 159, 160, 161, 246];
                // Right eye key points
                const rightEyeIndices = [362, 382, 381, 380, 374, 373, 390, 249, 263, 466, 388, 387, 386, 385, 384, 398];
                
                for (const idx of leftEyeIndices) {
                    if (faceLandmarks[idx]) {
                        leftEyeX += faceLandmarks[idx].x * canvasOutput.width;
                        leftEyeY += faceLandmarks[idx].y * canvasOutput.height;
                        leftEyeCount++;
                    }
                }
                
                for (const idx of rightEyeIndices) {
                    if (faceLandmarks[idx]) {
                        rightEyeX += faceLandmarks[idx].x * canvasOutput.width;
                        rightEyeY += faceLandmarks[idx].y * canvasOutput.height;
                        rightEyeCount++;
                    }
                }
                
                if (leftEyeCount > 0 && rightEyeCount > 0) {
                    leftEyeX /= leftEyeCount;
                    leftEyeY /= leftEyeCount;
                    rightEyeX /= rightEyeCount;
                    rightEyeY /= rightEyeCount;
                } else {
                    // Fallback to bounding box center if eye detection fails
                    leftEyeX = faceRect.x + faceRect.width * 0.35;
                    leftEyeY = faceRect.y + faceRect.height * 0.4;
                    rightEyeX = faceRect.x + faceRect.width * 0.65;
                    rightEyeY = faceRect.y + faceRect.height * 0.4;
                }
            } else {
                // Fallback to bounding box if no landmarks
                leftEyeX = faceRect.x + faceRect.width * 0.35;
                leftEyeY = faceRect.y + faceRect.height * 0.4;
                rightEyeX = faceRect.x + faceRect.width * 0.65;
                rightEyeY = faceRect.y + faceRect.height * 0.4;
            }
            
            // Calculate eye center and eye distance
            const eyeCenterX = (leftEyeX + rightEyeX) / 2;
            const eyeCenterY = (leftEyeY + rightEyeY) / 2;
            const eyeDistance = Math.sqrt(
                Math.pow(rightEyeX - leftEyeX, 2) + 
                Math.pow(rightEyeY - leftEyeY, 2)
            );
            
            // Calculate rotation angle from eye positions (in radians)
            // atan2 gives angle from horizontal, converting to degrees for rotation
            const rotationAngle = Math.atan2(rightEyeY - leftEyeY, rightEyeX - leftEyeX) * (180 / Math.PI);
            
            // Get additional facial landmarks for dynamic sizing
            let noseX = 0, noseY = 0, chinX = 0, chinY = 0, foreheadX = 0, foreheadY = 0;
            let hasLandmarks = false;
            
            if (faceLandmarks && faceLandmarks.length >= 468) {
                // MediaPipe landmark indices:
                // Nose tip: 1, 2
                // Chin: 175, 199
                // Forehead center: 10
                const noseTip = faceLandmarks[1] || faceLandmarks[2];
                const chin = faceLandmarks[175] || faceLandmarks[199];
                const forehead = faceLandmarks[10];
                
                if (noseTip && chin && forehead) {
                    noseX = noseTip.x * canvasOutput.width;
                    noseY = noseTip.y * canvasOutput.height;
                    chinX = chin.x * canvasOutput.width;
                    chinY = chin.y * canvasOutput.height;
                    foreheadX = forehead.x * canvasOutput.width;
                    foreheadY = forehead.y * canvasOutput.height;
                    hasLandmarks = true;
                }
            }
            
            // Dynamic mask sizing based on face measurements (matching Python implementation)
            const maskAspectRatio = img.naturalWidth / img.naturalHeight;
            let drawW, drawH;
            
            if (hasLandmarks && eyeDistance > 0) {
                // Use landmarks for precise dynamic sizing
                // Calculate face width from eye distance (most stable measurement)
                const faceWidth = eyeDistance * 4.5; // Increased for better coverage
                
                // Calculate face height from nose to chin and forehead to nose
                const noseToChin = Math.sqrt(
                    Math.pow(chinX - noseX, 2) + 
                    Math.pow(chinY - noseY, 2)
                );
                const foreheadToNose = Math.sqrt(
                    Math.pow(noseX - foreheadX, 2) + 
                    Math.pow(noseY - foreheadY, 2)
                );
                const totalFaceHeight = noseToChin + foreheadToNose;
                
                // Make mask taller to ensure full face coverage
                const maskHeight = totalFaceHeight * 1.35; // 35% larger for better coverage
                
                // Calculate width from height to maintain aspect ratio
                const maskWidthFromHeight = maskHeight * maskAspectRatio;
                
                // Use the larger of eye-based width or height-based width
                drawW = Math.max(faceWidth, maskWidthFromHeight);
                drawH = drawW / maskAspectRatio;
                
                // Recalculate height if aspect ratio makes it too different
                if (Math.abs(drawH - maskHeight) > maskHeight * 0.2) {
                    drawH = maskHeight;
                    drawW = drawH * maskAspectRatio;
                }
            } else {
                // Fallback to bounding box method with dynamic scaling
                // Scale based on face size - larger faces get proportionally larger masks
                const baseFaceSize = 200; // Base face size for reference
                const currentFaceSize = Math.max(faceRect.width, faceRect.height);
                const sizeRatio = currentFaceSize / baseFaceSize;
                
                // Dynamic scale factor: 1.4x for small faces, 1.8x for large faces
                const dynamicScale = 1.4 + (sizeRatio * 0.4);
                
                drawW = faceRect.width * dynamicScale;
                drawH = faceRect.height * dynamicScale;
                
                // Maintain mask aspect ratio
                if (maskAspectRatio > (drawW / drawH)) {
                    drawH = drawW / maskAspectRatio;
                } else {
                    drawW = drawH * maskAspectRatio;
                }
            }
            
            // Apply user-adjustable scale factor
            drawW *= faceMaskScale;
            drawH *= faceMaskScale;
            
            // Position mask: center horizontally on eye center
            const drawX = eyeCenterX - drawW / 2;
            
            // Position vertically so eyes align - place eye center at ~35% from top of mask
            // Adjust upward by 40 pixels to better align eyes (matching Python implementation)
            const drawY = eyeCenterY - drawH * 0.35 - 40;
            
            // Professional compositing: Advanced blending with edge feathering and color matching
            // Optimized with canvas caching and OffscreenCanvas support
            try {
                // Use cached canvas or create new one (reduces allocations)
                const maskW = Math.ceil(drawW);
                const maskH = Math.ceil(drawH);
                
                // Calculate rotated mask dimensions to ensure full coverage
                const absAngle = Math.abs(rotationAngle);
                const angleRad = absAngle * Math.PI / 180;
                const rotatedW = Math.ceil(maskW * Math.abs(Math.cos(angleRad)) + maskH * Math.abs(Math.sin(angleRad)));
                const rotatedH = Math.ceil(maskW * Math.abs(Math.sin(angleRad)) + maskH * Math.abs(Math.cos(angleRad)));
                
                let maskCanvas, maskCtx;
                // Use larger canvas to accommodate rotation
                const canvasW = Math.max(maskW, rotatedW);
                const canvasH = Math.max(maskH, rotatedH);
                
                if (maskProcessingCanvas && maskProcessingCanvas.width >= canvasW && maskProcessingCanvas.height >= canvasH) {
                    // Reuse cached canvas (faster, no allocation)
                    maskCanvas = maskProcessingCanvas;
                    maskCtx = maskProcessingCtx;
                } else {
                    // Create or resize canvas
                    if (!maskProcessingCanvas) {
                        maskProcessingCanvas = document.createElement('canvas');
                        maskProcessingCtx = maskProcessingCanvas.getContext('2d', { willReadFrequently: true });
                    }
                    maskProcessingCanvas.width = canvasW;
                    maskProcessingCanvas.height = canvasH;
                    maskCanvas = maskProcessingCanvas;
                    maskCtx = maskProcessingCtx;
                }
                
                // Clear canvas and apply rotation
                maskCtx.clearRect(0, 0, canvasW, canvasH);
                maskCtx.save();
                
                // Translate to center of mask, rotate, then translate back
                const maskCenterX = canvasW / 2;
                const maskCenterY = canvasH / 2;
                maskCtx.translate(maskCenterX, maskCenterY);
                maskCtx.rotate(rotationAngle * Math.PI / 180);
                maskCtx.translate(-maskCenterX, -maskCenterY);
                
                // Draw mask centered on canvas
                const maskDrawX = (canvasW - maskW) / 2;
                const maskDrawY = (canvasH - maskH) / 2;
                maskCtx.drawImage(img, maskDrawX, maskDrawY, maskW, maskH);
                maskCtx.restore();
                
                // Extract alpha channel from rotated mask
                // Wrap in try-catch to handle tainted canvas (cross-origin images)
                let maskImageData;
                try {
                    maskImageData = maskCtx.getImageData(0, 0, canvasW, canvasH);
                } catch (e) {
                    // Canvas is tainted (cross-origin image), fallback to simple draw
                    throw new Error('Canvas tainted by cross-origin data');
                }
                
                // Get the region of interest from the main canvas (the face area)
                // Use rotated dimensions to ensure we capture the full rotated mask
                const roiW = Math.min(Math.ceil(rotatedW), canvasOutput.width);
                const roiH = Math.min(Math.ceil(rotatedH), canvasOutput.height);
                // Center ROI on eye center
                const roiX = Math.max(0, Math.min(Math.floor(eyeCenterX - roiW / 2), canvasOutput.width - roiW));
                const roiY = Math.max(0, Math.min(Math.floor(eyeCenterY - roiH / 2), canvasOutput.height - roiH));
                
                let roiImageData;
                try {
                    roiImageData = ctx.getImageData(roiX, roiY, roiW, roiH);
                } catch (e) {
                    // Canvas might be tainted, fallback to simple draw with rotation
                    ctx.globalCompositeOperation = 'source-over';
                    ctx.imageSmoothingEnabled = true;
                    ctx.imageSmoothingQuality = 'high';
                    
                    // Apply rotation transformation
                    ctx.translate(eyeCenterX, eyeCenterY);
                    ctx.rotate(rotationAngle * Math.PI / 180);
                    ctx.translate(-eyeCenterX, -eyeCenterY);
                    
                    // Draw mask centered on eye center
                    ctx.drawImage(img, eyeCenterX - drawW / 2, eyeCenterY - drawH / 2, drawW, drawH);
                    ctx.restore();
                    return;
                }
                
                // Create output image data
                const outputData = new ImageData(roiW, roiH);
                
                // Professional compositing parameters (pre-calculated for performance)
                // Use actual canvas dimensions for center calculation
                const maskCanvasCenterX = canvasW * 0.5;
                const maskCanvasCenterY = canvasH * 0.5;
                const invCenterX = 1.0 / maskCanvasCenterX;
                const invCenterY = 1.0 / maskCanvasCenterY;
                const colorBlend = 0.92;
                const colorBlendInv = 1.0 - colorBlend;
                const colorBlendOrig = colorBlendInv * 0.15;
                const edgeThreshold = 0.9;
                const edgeRange = 0.1;
                const edgeFeatherThreshold = 0.15;
                const edgeFeatherStrength = 0.4;
                
                // Pre-calculate edge detection weights (sampleRadius = 3)
                const sampleRadius = 3;
                const sampleSize = (sampleRadius * 2 + 1) * (sampleRadius * 2 + 1);
                const edgeWeights = [];
                for (let sy = -sampleRadius; sy <= sampleRadius; sy++) {
                    for (let sx = -sampleRadius; sx <= sampleRadius; sx++) {
                        const dist = Math.sqrt(sx * sx + sy * sy);
                        edgeWeights.push(dist === 0 ? 1 : 1 / (1 + dist));
                    }
                }
                
                // Optimized pixel processing with cached calculations
                const origData = roiImageData.data;
                const maskData = maskImageData.data;
                const outData = outputData.data;
                const maskWidth = canvasW;
                const maskHeight = canvasH;
                
                // Calculate mapping from ROI coordinates to mask canvas coordinates
                // Both ROI and mask canvas are centered on eye center
                // ROI pixel (x, y) maps to mask canvas pixel:
                // maskX = centerX + (x - roiW/2)
                // maskY = centerY + (y - roiH/2)
                
                // Process each pixel with optimized blending
                for (let y = 0; y < roiH; y++) {
                    const yOffset = y * roiW;
                    // Map ROI coordinates to mask canvas coordinates
                    const maskY = Math.max(0, Math.min(Math.floor(maskCanvasCenterY + (y - roiH / 2)), maskHeight - 1));
                    const maskYOffset = maskY * maskWidth;
                    const distY = (maskY - maskCanvasCenterY) * invCenterY;
                    const distYSq = distY * distY;
                    
                    for (let x = 0; x < roiW; x++) {
                        const outIdx = (yOffset + x) * 4;
                        // Map ROI coordinates to mask canvas coordinates
                        const maskX = Math.max(0, Math.min(Math.floor(maskCanvasCenterX + (x - roiW / 2)), maskWidth - 1));
                        const maskIdx = (maskYOffset + maskX) * 4;
                        
                        // Get pixels (cached array access)
                        const origR = origData[outIdx];
                        const origG = origData[outIdx + 1];
                        const origB = origData[outIdx + 2];
                        
                        const maskR = maskData[maskIdx];
                        const maskG = maskData[maskIdx + 1];
                        const maskB = maskData[maskIdx + 2];
                        let maskAlpha = maskData[maskIdx + 3] * 0.003921568627451; // / 255.0
                        
                        // Fast edge feathering: distance from center (avoid sqrt when possible)
                        const distX = (maskX - maskCanvasCenterX) * invCenterX;
                        const distFromCenter = Math.sqrt(distX * distX + distYSq);
                        
                        // Feather outer edges (beyond 90% of radius) - optimized
                        if (distFromCenter > edgeThreshold) {
                            const edgeFactor = Math.max(0, 1 - ((distFromCenter - edgeThreshold) / edgeRange));
                            maskAlpha *= edgeFactor * Math.sqrt(edgeFactor); // pow(edgeFactor, 1.5) optimized
                        }
                        
                        // Optimized edge detection: only process if alpha is in transition zone
                        if (maskAlpha > 0.01 && maskAlpha < 0.99) {
                            let edgeStrength = 0;
                            let sampleCount = 0;
                            let weightIdx = 0;
                            
                            // Fast weighted sampling with pre-calculated weights
                            for (let sy = -sampleRadius; sy <= sampleRadius; sy++) {
                                const syIdx = Math.max(0, Math.min(maskHeight - 1, maskY + sy));
                                const syOffset = syIdx * maskWidth;
                                
                                    for (let sx = -sampleRadius; sx <= sampleRadius; sx++) {
                                        const sxIdx = Math.max(0, Math.min(maskWidth - 1, maskX + sx));
                                    const sIdx = (syOffset + sxIdx) * 4;
                                    const sAlpha = maskData[sIdx + 3] * 0.003921568627451;
                                    const weight = edgeWeights[weightIdx++];
                                    
                                    edgeStrength += Math.abs(maskAlpha - sAlpha) * weight;
                                    sampleCount += weight;
                                }
                            }
                            
                            // Soften transition edges
                            if (sampleCount > 0) {
                                edgeStrength /= sampleCount;
                                if (edgeStrength > edgeFeatherThreshold) {
                                    const edgeFeather = Math.min(1, (edgeStrength - edgeFeatherThreshold) * 2);
                                    maskAlpha *= (1 - edgeFeather * edgeFeatherStrength);
                                }
                            }
                        }
                        
                        // Optimized color matching and compositing (pre-multiplied constants)
                        const matchedR = maskR * colorBlend + origR * colorBlendOrig;
                        const matchedG = maskG * colorBlend + origG * colorBlendOrig;
                        const matchedB = maskB * colorBlend + origB * colorBlendOrig;
                        
                        // Fast premultiplied alpha compositing
                        const invAlpha = 1 - maskAlpha;
                        outData[outIdx] = Math.round(matchedR * maskAlpha + origR * invAlpha);
                        outData[outIdx + 1] = Math.round(matchedG * maskAlpha + origG * invAlpha);
                        outData[outIdx + 2] = Math.round(matchedB * maskAlpha + origB * invAlpha);
                        outData[outIdx + 3] = 255;
                    }
                }
                
                // Draw the professionally composited result back to main canvas
                // If using OffscreenCanvas, transfer the data
                if (offscreenCanvas && offscreenCtx) {
                    offscreenCtx.putImageData(outputData, 0, 0);
                    const offscreenImageData = offscreenCtx.getImageData(0, 0, roiW, roiH);
                    ctx.putImageData(offscreenImageData, roiX, roiY);
                } else {
                    ctx.putImageData(outputData, roiX, roiY);
                }
                
            } catch (error) {
                // Fallback to simple draw if advanced compositing fails
                // Only warn once for tainted canvas issues to avoid spam
                const isTaintedCanvas = error.message && (
                    error.message.includes('tainted') || 
                    error.message.includes('cross-origin') ||
                    error.toString().includes('tainted') ||
                    error.toString().includes('cross-origin')
                );
                
                if (isTaintedCanvas && taintedCanvasWarned) {
                    // Silently fallback - already warned
                } else {
                    if (isTaintedCanvas) {
                        taintedCanvasWarned = true;
                        console.warn('Advanced compositing unavailable (cross-origin image). Using simple blend mode.');
                    } else {
                        console.warn('Advanced compositing failed, using simple blend:', error);
                    }
                }
                ctx.globalCompositeOperation = 'source-over';
                ctx.imageSmoothingEnabled = true;
                ctx.imageSmoothingQuality = 'high';
                
                // Apply rotation transformation
                ctx.translate(eyeCenterX, eyeCenterY);
                ctx.rotate(rotationAngle * Math.PI / 180);
                ctx.translate(-eyeCenterX, -eyeCenterY);
                
                // Draw mask centered on eye center
                ctx.drawImage(img, eyeCenterX - drawW / 2, eyeCenterY - drawH / 2, drawW, drawH);
            }
            
            // Restore context state
            ctx.restore();
        }
        
        // Clear filter function
        function clearFilter() {
            selectFilter('');
            closeFxSearchModal();
        }
        
        // Select filter
        // Clean up old URL parameters (v and b) that are no longer used
        function cleanOldURLParams() {
            if (window.location.protocol === 'file:') {
                return;
            }
            
            const url = new URL(window.location.href);
            let needsUpdate = false;
            
            // Remove old version and build parameters
            if (url.searchParams.has('v')) {
                url.searchParams.delete('v');
                needsUpdate = true;
            }
            if (url.searchParams.has('b')) {
                url.searchParams.delete('b');
                needsUpdate = true;
            }
            
            // Update URL if we removed any parameters
            if (needsUpdate) {
                window.history.replaceState({}, '', url.toString());
            }
        }
        
        // Update URL with current FX
        function updateURLWithFX(filterValue) {
            // Skip URL updates for file:// protocol
            if (window.location.protocol === 'file:') {
                return;
            }
            
            const url = new URL(window.location.href);
            
            // Remove old version and build parameters
            url.searchParams.delete('v');
            url.searchParams.delete('b');
            
            if (filterValue && filterValue !== '') {
                url.searchParams.set('fx', filterValue);
            } else {
                url.searchParams.delete('fx');
            }
            
            // Update URL without reloading page
            window.history.pushState({}, '', url);
        }
        
        function selectFilter(filterValue, skipURLUpdate = false) {
            currentFilter = filterValue || '';
            
            // Save to localStorage (works even with file:// protocol)
            try {
                localStorage.setItem('wesworld-fx-last', currentFilter);
            } catch (error) {
                console.error('Error saving last filter to localStorage:', error);
            }
            
            if (currentFilter === '') {
                fxSelectedText.textContent = 'None (Original)';
                fxCurrentPin.style.display = 'none';
                if (clearFilterButton) {
                    clearFilterButton.style.display = 'none';
                }
                // Update overlay
                if (currentFxOverlay) {
                    currentFxOverlay.classList.remove('active');
                }
                // Update title
                document.title = 'WesWorld FX';
            } else {
                fxSelectedText.textContent = formatFilterName(currentFilter);
                updateCurrentPinIcon();
                if (clearFilterButton) {
                    clearFilterButton.style.display = 'flex';
                }
                // Update overlay
                if (currentFxOverlay && currentFxOverlayName) {
                    currentFxOverlayName.textContent = formatFilterName(currentFilter);
                    currentFxOverlay.classList.add('active');
                }
                // Update title with filter name
                document.title = 'WesWorld FX - ' + formatFilterName(currentFilter);
            }
            
            // Update selected state
            if (fxOptionsContainer) {
                const allOptions = fxOptionsContainer.querySelectorAll('.fx-option');
                allOptions.forEach(opt => {
                    opt.classList.remove('selected');
                    if (opt.value === currentFilter) {
                        opt.classList.add('selected');
                    }
                });
            }
            
            // Update grid modal selected state if open
            if (fxGridContainer) {
                const allGridItems = fxGridContainer.querySelectorAll('.fx-grid-item');
                allGridItems.forEach(item => {
                    item.classList.remove('selected');
                    const itemFilter = item.dataset.filter;
                    const filterKey = currentFilter || 'none';
                    if (itemFilter === filterKey) {
                        item.classList.add('selected');
                    }
                });
            }
            
            // Update URL unless we're in the middle of a roulette
            if (!skipURLUpdate) {
                updateURLWithFX(currentFilter);
            }
            
            // Update face mask controls state
            if (typeof updateFaceMaskControlsState === 'function') {
                updateFaceMaskControlsState();
            }
        }
        
        // Cycle to next filter
        function cycleNextFilter() {
            // If we have pinned filters, cycle through those first
            if (pinnedFilters.length > 0) {
                if (currentFilter === '') {
                    // Start with first pinned filter
                    selectFilter(pinnedFilters[0]);
                } else {
                    const currentIndex = pinnedFilters.indexOf(currentFilter);
                    if (currentIndex >= 0) {
                        // Cycle within pinned filters
                        const nextIndex = (currentIndex + 1) % pinnedFilters.length;
                        selectFilter(pinnedFilters[nextIndex]);
                    } else {
                        // Current filter not in pinned, go to first pinned
                        selectFilter(pinnedFilters[0]);
                    }
                }
            } else {
                // Cycle through all filters
                const filters = ['', ...allFilters];
                const currentIndex = filters.indexOf(currentFilter);
                const nextIndex = (currentIndex + 1) % filters.length;
                selectFilter(filters[nextIndex]);
            }
        }
        
        // Cycle to previous filter
        function cyclePrevFilter() {
            // If we have pinned filters, cycle through those first
            if (pinnedFilters.length > 0) {
                if (currentFilter === '') {
                    // Start with last pinned filter
                    selectFilter(pinnedFilters[pinnedFilters.length - 1]);
                } else {
                    const currentIndex = pinnedFilters.indexOf(currentFilter);
                    if (currentIndex >= 0) {
                        // Cycle within pinned filters
                        const prevIndex = (currentIndex - 1 + pinnedFilters.length) % pinnedFilters.length;
                        selectFilter(pinnedFilters[prevIndex]);
                    } else {
                        // Current filter not in pinned, go to last pinned
                        selectFilter(pinnedFilters[pinnedFilters.length - 1]);
                    }
                }
            } else {
                // Cycle through all filters
                const filters = ['', ...allFilters];
                const currentIndex = filters.indexOf(currentFilter);
                const prevIndex = (currentIndex - 1 + filters.length) % filters.length;
                selectFilter(filters[prevIndex]);
            }
        }
        
        // Filter FX options based on search query
        function filterFxOptions(searchQuery) {
            const searchLower = searchQuery.toLowerCase().trim();
            const optionsContainer = document.getElementById('fxOptionsContainer');
            const pinnedContainer = document.getElementById('pinnedFxContainer');
            
            if (!searchLower) {
                if (optionsContainer) {
                    const allOptions = optionsContainer.querySelectorAll('.fx-option');
                    const allGroups = optionsContainer.querySelectorAll('.fx-group');
                    allOptions.forEach(option => option.style.display = '');
                    allGroups.forEach(group => group.style.display = '');
                }
                if (pinnedContainer) {
                    const pinnedItems = pinnedContainer.querySelectorAll('.pinned-fx-item');
                    pinnedItems.forEach(item => item.style.display = '');
                }
                return;
            }
            
            function matchesFilter(filterValue, displayText) {
                // Case-insensitive search that matches anywhere in the string
                const filterName = formatFilterName(filterValue).toLowerCase();
                const text = displayText.toLowerCase();
                const filterValueLower = filterValue.toLowerCase();
                
                // Extract face mask name for better matching (e.g., "sam" from "dropout_face_mask_sam")
                let faceMaskName = '';
                if (filterValue.includes('face_mask')) {
                    const parts = filterValue.split('_');
                    // Get the last part which is the mask name
                    faceMaskName = parts[parts.length - 1].toLowerCase();
                }
                
                // Split filter name and value into individual words for better partial matching
                const filterNameWords = filterName.split(/\s+/);
                const filterValueWords = filterValueLower.split('_');
                
                // Check if search query appears anywhere in any of these strings
                const exactMatch = text.includes(searchLower) || 
                                  filterName.includes(searchLower) || 
                                  filterValueLower.includes(searchLower) ||
                                  (faceMaskName && faceMaskName.includes(searchLower)) ||
                                  (faceMaskName && `mask_${faceMaskName}`.includes(searchLower));
                
                // Also check if all search words match individual words in the filter
                // This allows searching "upside" or "down" to match "upside_down"
                const searchWords = searchLower.split(/\s+/).filter(w => w.length > 0);
                if (searchWords.length > 0) {
                    const allWordsMatch = searchWords.every(searchWord => {
                        return filterNameWords.some(word => word.includes(searchWord)) ||
                               filterValueWords.some(word => word.includes(searchWord)) ||
                               text.includes(searchWord) ||
                               filterValueLower.includes(searchWord);
                    });
                    if (allWordsMatch) return true;
                }
                
                return exactMatch;
            }
            
            if (pinnedContainer) {
                const pinnedItems = pinnedContainer.querySelectorAll('.pinned-fx-item');
                pinnedItems.forEach(item => {
                    const filterName = item.dataset.filterName || '';
                    // Get text from .pinned-fx-item-text if it exists, otherwise use textContent
                    // This ensures we get clean text without the remove button (Ã—)
                    const textElement = item.querySelector('.pinned-fx-item-text');
                    let text = '';
                    if (textElement) {
                        text = textElement.textContent || '';
                    } else {
                        // Fallback: use textContent but remove the Ã— remove button
                        text = item.textContent || '';
                        text = text.replace(/Ã—/g, '').trim();
                    }
                    item.style.display = matchesFilter(filterName, text) ? '' : 'none';
                });
            }
            
            if (optionsContainer) {
                const allOptions = optionsContainer.querySelectorAll('.fx-option');
                const allGroups = optionsContainer.querySelectorAll('.fx-group');
                
                allOptions.forEach(option => {
                    const filterValue = option.value || '';
                    // Get text from .fx-option-text if it exists, otherwise use textContent
                    // This ensures we get clean text without pin icons or other elements
                    const textElement = option.querySelector('.fx-option-text');
                    let optionText = '';
                    if (textElement) {
                        optionText = textElement.textContent || '';
                    } else {
                        // For options without .fx-option-text, get textContent but remove pin icon
                        optionText = option.textContent || '';
                        // Remove emoji pin icons (ðŸ“ and ðŸ“Œ) and Ã— characters
                        optionText = optionText.replace(/ðŸ“|ðŸ“Œ|Ã—/g, '').trim();
                    }
                    option.style.display = matchesFilter(filterValue, optionText) ? '' : 'none';
                });
                
                // Hide groups that have no visible options
                allGroups.forEach(group => {
                    const visibleOptions = group.querySelectorAll('.fx-option[style=""]');
                    group.style.display = visibleOptions.length > 0 ? '' : 'none';
                });
            }
        }
        
        // Start random cycle (roulette) - cycles through filters like a slot machine
        function startRandomCycle() {
            if (isRandomCycling) {
                console.log('Roulette already running');
                return;
            }
            isRandomCycling = true;
            const filters = pinnedFilters.length > 0 ? pinnedFilters : allFilters;
            if (filters.length === 0) {
                console.log('No filters available for roulette');
                isRandomCycling = false;
                return;
            }
            console.log('Starting roulette with', filters.length, 'filters');
            let cycles = 0;
            const maxCycles = 10;
            randomCycleInterval = setInterval(() => {
                const randomFilter = filters[Math.floor(Math.random() * filters.length)];
                // Skip URL updates during roulette
                selectFilter(randomFilter, true);
                cycles++;
                if (cycles >= maxCycles) {
                    clearInterval(randomCycleInterval);
                    randomCycleInterval = null;
                    const finalFilter = filters[Math.floor(Math.random() * filters.length)];
                    // Update URL only after roulette ends
                    selectFilter(finalFilter, false);
                    isRandomCycling = false;
                    console.log('Roulette finished on:', finalFilter);
                }
            }, 100);
        }
        
        // Load test image
        function loadTestImage(imageFile) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        testImage = img;
                        clearTestImageButton.style.display = 'block';
                        console.log('Test image loaded:', img.width, 'x', img.height);
                        // Stop camera if running
                        if (localStream) {
                            stopCamera();
                        }
                        // Start processing the test image
                        processVideoFrame();
                        resolve();
                    };
                    img.onerror = reject;
                    img.src = e.target.result;
                };
                reader.onerror = reject;
                reader.readAsDataURL(imageFile);
            });
        }
        
        // Clear test image
        function clearTestImage() {
            testImage = null;
            clearTestImageButton.style.display = 'none';
            // Clear canvas
            if (ctx && canvasOutput) {
                ctx.clearRect(0, 0, canvasOutput.width, canvasOutput.height);
            }
        }
        
        // Process video frame or test image (optimized with frame rate limiting)
        async function processVideoFrame() {
            // Frame rate limiting for consistent 60fps performance
            const now = performance.now();
            if (now - lastFrameTime < frameInterval) {
                if (localStream || testImage) {
                    animationFrameId = requestAnimationFrame(processVideoFrame);
                }
                return;
            }
            lastFrameTime = now;
            
            // Check if we have everything we need
            const hasVideo = localStream && videoInput && videoInput.readyState >= 2;
            const hasTestImage = testImage && testImage.complete;
            
            if (isProcessing || !canvasOutput || !ctx || (!hasVideo && !hasTestImage)) {
                if (hasVideo || hasTestImage) {
                    animationFrameId = requestAnimationFrame(processVideoFrame);
                }
                return;
            }
            
            // Check if video is ready (only if using video)
            if (hasVideo && (videoInput.readyState < 2 || videoInput.videoWidth === 0 || videoInput.videoHeight === 0)) {
                animationFrameId = requestAnimationFrame(processVideoFrame);
                return;
            }
            
            isProcessing = true;
            
            try {
                // Set canvas size to match video
                if (canvasOutput.width !== videoInput.videoWidth || 
                    canvasOutput.height !== videoInput.videoHeight) {
                    canvasOutput.width = videoInput.videoWidth;
                    canvasOutput.height = videoInput.videoHeight;
                }
                
                // Draw video frame to canvas FIRST (always show the video)
                ctx.drawImage(videoInput, 0, 0, canvasOutput.width, canvasOutput.height);
                
                // Only process if we have a filter
                if (currentFilter) {
                    // Detect faces using MediaPipe (for face masks) - do this first
                    let faceRect = null;
                    let faceLandmarks = null;
                    if (faceLandmarker && (currentFilter.includes('face_mask'))) {
                        try {
                            // Use test image if available, otherwise use video
                            const source = testImage || videoInput;
                            const results = faceLandmarker.detectForVideo(source, performance.now());
                            
                            if (results.faceLandmarks && results.faceLandmarks.length > 0) {
                                faceLandmarks = results.faceLandmarks[0];
                                
                                // Calculate bounding box from landmarks
                                // Use key facial landmarks for better accuracy
                                // MediaPipe provides 468 landmarks, we'll use key points
                                let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                                
                                for (const landmark of faceLandmarks) {
                                    const x = landmark.x * canvasOutput.width;
                                    const y = landmark.y * canvasOutput.height;
                                    minX = Math.min(minX, x);
                                    minY = Math.min(minY, y);
                                    maxX = Math.max(maxX, x);
                                    maxY = Math.max(maxY, y);
                                }
                                
                                // Add padding for better mask coverage
                                const padding = 20;
                                const width = maxX - minX;
                                const height = maxY - minY;
                                
                                faceRect = {
                                    x: Math.max(0, minX - padding),
                                    y: Math.max(0, minY - padding),
                                    width: Math.min(canvasOutput.width - minX + padding, width + padding * 2),
                                    height: Math.min(canvasOutput.height - minY + padding, height + padding * 2),
                                    confidence: 1.0,
                                    landmarks: faceLandmarks
                                };
                            }
                        } catch (error) {
                            console.warn('Face detection error:', error);
                        }
                    }
                    
                    // For face masks, we don't need to read image data - just draw the mask
                    if (currentFilter.includes('face_mask')) {
                        // Apply face masks directly (no image data needed)
                        if (faceRect && faceLandmarks) {
                            applyFaceMask(ctx, faceRect, faceLandmarks, currentFilter);
                        }
                    } else {
                        // For other filters, try to get image data (may fail due to CORS)
                        let imageData = null;
                        try {
                            imageData = ctx.getImageData(0, 0, canvasOutput.width, canvasOutput.height);
                        } catch (error) {
                            // Canvas is tainted (CORS issue) - can't apply pixel-based filters
                            // This is expected for file:// protocol or cross-origin video
                            console.warn('Cannot read canvas data (CORS/tainted canvas). Some filters may not work.');
                            // Continue without applying filter - at least show the video
                        }
                        
                        if (imageData) {
                            // Apply filter
                            if (currentFilter && wasmModule) {
                                // Use WASM filter processing
                                wasmModule.processFrame(canvasOutput, canvasOutput, currentFilter, faceRect, frameCount);
                            } else if (currentFilter) {
                                // Fallback to JavaScript filters
                                applyJSFilter(imageData, currentFilter, faceRect);
                                ctx.putImageData(imageData, 0, 0);
                            }
                        }
                    }
                }
                
                // Draw wireframe overlay if enabled and filter is active
                if (showWireframe && currentFilter && ctx && canvasOutput) {
                    drawWireframeOverlay(ctx, canvasOutput.width, canvasOutput.height, currentFilter);
                }
                
                frameCount++;
            } catch (error) {
                console.error('Error processing frame:', error);
            } finally {
                isProcessing = false;
            }
            
            // Continue processing
            if (localStream && videoInput && !videoInput.paused) {
                animationFrameId = requestAnimationFrame(processVideoFrame);
            }
        }
        
        // Scene definitions - loaded from JSON files
        const SCENES = {};
        
        // Check if we're using file:// protocol (CORS will block fetch)
        function isFileProtocol() {
            return window.location.protocol === 'file:';
        }
        
        // Embedded scenes data for file:// protocol fallback
        const EMBEDDED_SCENES = {
            "dropout": {
                "name": "Dropout",
                "colors": {
                    "background": "#0a0a0a",
                    "surface": "#1a1a1a",
                    "surfaceHover": "#2a2a2a",
                    "text": "#ffffff",
                    "textSecondary": "#e0e0e0",
                    "accent": "#feea3b",
                    "accentHover": "#fff04a",
                    "border": "#333333",
                    "borderHover": "#feea3b",
                    "button": "#feea3b",
                    "buttonHover": "#fff04a",
                    "statusConnected": "#4caf50",
                    "statusError": "#ff4444",
                    "groupTitle": "#feea3b",
                    "selectedText": "#000000"
                },
                "fx": ["ultimate_distortion", "water_ripple", "pincushion", "multi_ripple", "radial_squeeze", "elastic_stretch",
                    "lens_distortion", "wave_distortion", "squeeze_horizontal", "squeeze_vertical",
                    "radial_wobble", "complex_ripple", "squish_face", "stretch_face", "funhouse_mirror",
                    "pinch_cheeks", "bulge_eyes", "warp_face", "funny_squash", "funny_stretch",
                    "wobble_face", "elastic_face", "gentle_ripple", "smush_face", "upside_down"]
            },
            "wesworld": {
                "name": "WesWorld",
                "colors": {
                    "background": "#000000",
                    "surface": "#1a1a1a",
                    "surfaceHover": "#2a2a2a",
                    "text": "#ffffff",
                    "textSecondary": "#cccccc",
                    "accent": "#5250ef",
                    "accentHover": "#6260ff",
                    "border": "#333333",
                    "borderHover": "#5250ef",
                    "button": "#5250ef",
                    "buttonHover": "#6260ff",
                    "statusConnected": "#4caf50",
                    "statusError": "#f44336",
                    "groupTitle": "#5250ef",
                    "selectedText": "#ffffff"
                },
                "fx": [
                    "ultimate_distortion",
                    "bulge", "stretch", "swirl", "fisheye", "pinch", "wave", "mirror",
                    "twirl", "ripple", "sphere", "tunnel", "water_ripple",
                    "radial_blur", "cylinder", "barrel", "pincushion", "whirlpool", "radial_zoom",
                    "multi_ripple", "radial_squeeze", "elastic_stretch", "lens_distortion",
                    "wave_distortion", "squeeze_horizontal", "squeeze_vertical", "radial_wobble", "complex_ripple",
                    "squish_face", "stretch_face", "funhouse_mirror", "pinch_cheeks", "bulge_eyes",
                    "warp_face", "funny_squash", "funny_stretch", "wobble_face", "elastic_face",
                    "gentle_ripple", "smush_face", "upside_down",
                    "concave", "convex", "spiral", "radial_stretch", "radial_compress",
                    "vertical_wave", "horizontal_wave", "skew_horizontal", "skew_vertical",
                    "rotate_zoom", "radial_wave", "zoom_in", "zoom_out", "fast_zoom_in",
                    "fast_zoom_out", "shake", "pulse", "spiral_zoom", "extreme_closeup",
                    "puzzle", "rotate", "rotate_45", "rotate_90", "flip_horizontal",
                    "flip_vertical", "flip_both", "upside_down", "quad_mirror", "tile", "radial_tile",
                    "zoom_blur", "melt", "kaleidoscope", "glitch", "double_vision",
                    "black_white", "sepia", "vintage", "neon_glow",
                    "pixelate", "blur", "sharpen", "emboss", "red_tint", "blue_tint",
                    "green_tint", "rainbow", "negative", "posterize", "sketch", "cartoon",
                    "thermal", "ice", "ocean", "plasma", "jet", "turbo", "inferno",
                    "magma", "viridis", "cool", "hot", "spring", "summer", "autumn",
                    "winter", "rainbow_shift", "acid_trip", "vhs", "retro", "cyberpunk",
                    "anime", "glow", "solarize", "edge_detect", "halftone"
                ]
            }
        };
        
        // Embedded scenes manifest for file:// protocol fallback
        const EMBEDDED_SCENES_MANIFEST = {
            "scenes": ["dropout", "wesworld"]
        };
        
        // Embedded build info for file:// protocol fallback
        const EMBEDDED_BUILD_INFO = {
            "buildNumber": 121,
            "buildTimestamp": 1765179928000,
            "commitHash": "8874b31",
            "commitTime": 1765179928000
        };
        
        // Fallback dropout scene (used if file loading fails)
        const FALLBACK_DROPOUT_SCENE = EMBEDDED_SCENES.dropout;
        
        // Load scene from JSON file
        async function loadSceneFromFile(sceneKey) {
            // If using file:// protocol, use embedded data immediately
            if (isFileProtocol()) {
                if (EMBEDDED_SCENES[sceneKey]) {
                    SCENES[sceneKey] = EMBEDDED_SCENES[sceneKey];
                    return SCENES[sceneKey];
                } else {
                    console.warn(`Scene ${sceneKey} not found in embedded scenes`);
                    return null;
                }
            }
            
            try {
                const response = await fetch(`scenes/${sceneKey}.json`);
                if (!response.ok) {
                    console.warn(`Failed to load scene ${sceneKey}:`, response.statusText);
                    // Try embedded data as fallback
                    if (EMBEDDED_SCENES[sceneKey]) {
                        SCENES[sceneKey] = EMBEDDED_SCENES[sceneKey];
                        return SCENES[sceneKey];
                    }
                    return null;
                }
                const scene = await response.json();
                if (scene && scene.colors) {
                    SCENES[sceneKey] = scene;
                    return scene;
                } else {
                    console.error(`Scene ${sceneKey} loaded but missing colors property`);
                    // Try embedded data as fallback
                    if (EMBEDDED_SCENES[sceneKey]) {
                        SCENES[sceneKey] = EMBEDDED_SCENES[sceneKey];
                        return SCENES[sceneKey];
                    }
                    return null;
                }
            } catch (error) {
                console.warn(`Error loading scene ${sceneKey}:`, error.message);
                // Try embedded data as fallback
                if (EMBEDDED_SCENES[sceneKey]) {
                    SCENES[sceneKey] = EMBEDDED_SCENES[sceneKey];
                    return SCENES[sceneKey];
                }
                return null;
            }
        }
        
        // Discover available scene files from manifest
        async function discoverScenes() {
            // If using file:// protocol, use embedded data immediately
            if (isFileProtocol()) {
                return EMBEDDED_SCENES_MANIFEST.scenes || [];
            }
            
            try {
                const response = await fetch('scenes/scenes.json');
                if (response.ok) {
                    const data = await response.json();
                    return data.scenes || [];
                }
            } catch (error) {
                console.warn('Could not load scenes manifest, trying embedded data...', error.message);
            }
            
            // Fallback: use embedded manifest or try to discover
            if (EMBEDDED_SCENES_MANIFEST && EMBEDDED_SCENES_MANIFEST.scenes) {
                return EMBEDDED_SCENES_MANIFEST.scenes;
            }
            
            // Last resort: try to load common scene names
            const possibleScenes = ['dropout', 'wesworld'];
            const loadedScenes = [];
            
            for (const sceneKey of possibleScenes) {
                try {
                    const response = await fetch(`scenes/${sceneKey}.json`);
                    if (response.ok) {
                        loadedScenes.push(sceneKey);
                    }
                } catch (error) {
                    // Silently skip scenes that don't exist
                }
            }
            
            // If fetch failed but we have embedded data, use that
            if (loadedScenes.length === 0 && EMBEDDED_SCENES_MANIFEST && EMBEDDED_SCENES_MANIFEST.scenes) {
                return EMBEDDED_SCENES_MANIFEST.scenes;
            }
            
            return loadedScenes;
        }
        
        // Load and apply scene
        async function loadScenes() {
            // Discover available scenes
            const availableScenes = await discoverScenes();
            
            if (availableScenes.length === 0) {
                console.error('No scenes found!');
                return;
            }
            
            // Load all available scenes
            await Promise.all(availableScenes.map(key => loadSceneFromFile(key)));
            
            // Populate scene dropdown only with successfully loaded scenes
            sceneSelect.innerHTML = '';
            const sceneKeys = Object.keys(SCENES);
            if (sceneKeys.length === 0) {
                // If no scenes loaded, add fallback
                SCENES.dropout = FALLBACK_DROPOUT_SCENE;
                sceneKeys.push('dropout');
            }
            sceneKeys.forEach(sceneKey => {
                const option = document.createElement('option');
                option.value = sceneKey;
                option.textContent = SCENES[sceneKey].name;
                sceneSelect.appendChild(option);
            });
            
            // Load saved scene from localStorage, or default to dropout
            const savedScene = localStorage.getItem('wesworld-fx-scene');
            const defaultScene = availableScenes.includes('dropout') ? 'dropout' : (availableScenes[0] || 'dropout');
            
            // Use saved scene if it exists and is valid, otherwise use default
            let sceneToLoad = defaultScene;
            if (savedScene && SCENES[savedScene]) {
                sceneToLoad = savedScene;
            }
            
            if (SCENES[sceneToLoad]) {
                sceneSelect.value = sceneToLoad;
                applyScene(SCENES[sceneToLoad]);
            } else if (Object.keys(SCENES).length > 0) {
                // Fallback to first available scene
                const firstScene = Object.keys(SCENES)[0];
                sceneSelect.value = firstScene;
                applyScene(SCENES[firstScene]);
            } else {
                // If no scenes loaded (e.g., CORS error), use fallback
                console.warn('No scenes loaded, using fallback dropout scene');
                SCENES.dropout = FALLBACK_DROPOUT_SCENE;
                sceneSelect.value = 'dropout';
                applyScene(FALLBACK_DROPOUT_SCENE);
            }
            
            // Build filter categories from current scene
            buildFilterCategories();
        }
        
        // Apply scene to page
        function applyScene(scene) {
            if (!scene) {
                console.warn('applyScene called with null/undefined scene');
                return;
            }
            
            const root = document.documentElement;
            const colorMap = {
                background: 'background-color',
                surface: 'surface-color',
                surfaceHover: 'surface-hover-color',
                text: 'text-color',
                textSecondary: 'text-secondary-color',
                accent: 'accent-color',
                accentHover: 'accent-hover-color',
                border: 'border-color',
                borderHover: 'border-hover-color',
                button: 'button-color',
                buttonHover: 'button-hover-color',
                statusConnected: 'status-connected-color',
                statusError: 'status-error-color',
                groupTitle: 'group-title-color',
                selectedText: 'selected-text-color'
            };
            
            if (scene.colors) {
                Object.entries(scene.colors).forEach(([key, value]) => {
                    if (value) {
                        const cssVar = colorMap[key] || key.replace(/([A-Z])/g, '-$1').toLowerCase();
                        root.style.setProperty(`--${cssVar}`, value);
                    }
                });
                console.log('Scene colors applied:', scene.name || 'Unknown');
            } else {
                console.warn('Scene has no colors property:', scene);
            }
            
            // Rebuild filter categories when scene changes
            buildFilterCategories();
            
            // Reload filters if they've been loaded already
            if (fxOptionsContainer) {
                loadFilters();
            }
            
            // Reload grid if it's currently open
            if (fxGridModal && fxGridModal.classList.contains('active')) {
                loadFxGrid();
            }
        }
        
        // JavaScript filter implementations (complete set)
        const FilterImplementations = {
            applyBlackWhite(data) {
                for (let i = 0; i < data.length; i += 4) {
                    const gray = data[i] * 0.299 + data[i + 1] * 0.587 + data[i + 2] * 0.114;
                    data[i] = gray; data[i + 1] = gray; data[i + 2] = gray;
                }
            },
            applySepia(data) {
                for (let i = 0; i < data.length; i += 4) {
                    const r = data[i], g = data[i + 1], b = data[i + 2];
                    data[i] = Math.min(255, (r * 0.393) + (g * 0.769) + (b * 0.189));
                    data[i + 1] = Math.min(255, (r * 0.349) + (g * 0.686) + (b * 0.168));
                    data[i + 2] = Math.min(255, (r * 0.272) + (g * 0.534) + (b * 0.131));
                }
            },
            applyNegative(data) {
                for (let i = 0; i < data.length; i += 4) {
                    data[i] = 255 - data[i]; data[i + 1] = 255 - data[i + 1]; data[i + 2] = 255 - data[i + 2];
                }
            },
            applyVintage(data) {
                for (let i = 0; i < data.length; i += 4) {
                    data[i] = Math.min(255, data[i] * 0.9 + 20);
                    data[i + 1] = Math.min(255, data[i + 1] * 0.85 + 15);
                    data[i + 2] = Math.min(255, data[i + 2] * 0.8 + 10);
                }
            },
            applyNeonGlow(data) {
                for (let i = 0; i < data.length; i += 4) {
                    const brightness = (data[i] + data[i + 1] + data[i + 2]) / 3;
                    data[i] = Math.min(255, brightness * 1.5);
                    data[i + 1] = Math.min(255, brightness * 1.2);
                    data[i + 2] = Math.min(255, brightness * 2);
                }
            },
            applyRedTint(data) {
                for (let i = 0; i < data.length; i += 4) data[i] = Math.min(255, data[i] * 1.5);
            },
            applyBlueTint(data) {
                for (let i = 0; i < data.length; i += 4) data[i + 2] = Math.min(255, data[i + 2] * 1.5);
            },
            applyGreenTint(data) {
                for (let i = 0; i < data.length; i += 4) data[i + 1] = Math.min(255, data[i + 1] * 1.5);
            },
            applyPosterize(data) {
                const levels = 4;
                for (let i = 0; i < data.length; i += 4) {
                    data[i] = Math.floor(data[i] / (256 / levels)) * (256 / levels);
                    data[i + 1] = Math.floor(data[i + 1] / (256 / levels)) * (256 / levels);
                    data[i + 2] = Math.floor(data[i + 2] / (256 / levels)) * (256 / levels);
                }
            },
            applyThermal(data) {
                for (let i = 0; i < data.length; i += 4) {
                    const gray = (data[i] + data[i + 1] + data[i + 2]) / 3;
                    if (gray < 85) {
                        data[i] = 0; data[i + 1] = 0; data[i + 2] = gray * 3;
                    } else if (gray < 170) {
                        data[i] = (gray - 85) * 3; data[i + 1] = 255; data[i + 2] = 255;
                    } else {
                        data[i] = 255; data[i + 1] = 255 - (gray - 170) * 3; data[i + 2] = 0;
                    }
                }
            },
            applyPixelate(data, width, height) {
                const pixelSize = 10;
                for (let y = 0; y < height; y += pixelSize) {
                    for (let x = 0; x < width; x += pixelSize) {
                        let r = 0, g = 0, b = 0, count = 0;
                        for (let dy = 0; dy < pixelSize && y + dy < height; dy++) {
                            for (let dx = 0; dx < pixelSize && x + dx < width; dx++) {
                                const idx = ((y + dy) * width + (x + dx)) * 4;
                                r += data[idx]; g += data[idx + 1]; b += data[idx + 2]; count++;
                            }
                        }
                        r = Math.floor(r / count); g = Math.floor(g / count); b = Math.floor(b / count);
                        for (let dy = 0; dy < pixelSize && y + dy < height; dy++) {
                            for (let dx = 0; dx < pixelSize && x + dx < width; dx++) {
                                const idx = ((y + dy) * width + (x + dx)) * 4;
                                data[idx] = r; data[idx + 1] = g; data[idx + 2] = b;
                            }
                        }
                    }
                }
            },
            applyBulge(data, width, height) {
                const centerX = width / 2, centerY = height / 2;
                const radius = Math.min(width, height) / 2, strength = 0.5;
                const temp = new Uint8ClampedArray(data);
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const dx = x - centerX, dy = y - centerY;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist < radius) {
                            const angle = Math.atan2(dy, dx);
                            const r = dist / radius;
                            const newR = r * (1 - strength * (1 - r));
                            const newX = Math.round(centerX + Math.cos(angle) * newR * radius);
                            const newY = Math.round(centerY + Math.sin(angle) * newR * radius);
                            if (newX >= 0 && newX < width && newY >= 0 && newY < height) {
                                const srcIdx = (y * width + x) * 4;
                                const dstIdx = (newY * width + newX) * 4;
                                data[srcIdx] = temp[dstIdx];
                                data[srcIdx + 1] = temp[dstIdx + 1];
                                data[srcIdx + 2] = temp[dstIdx + 2];
                                data[srcIdx + 3] = temp[dstIdx + 3];
                            }
                        }
                    }
                }
            },
            applySwirl(data, width, height) {
                const centerX = width / 2, centerY = height / 2;
                const radius = Math.min(width, height) / 2, strength = 2.0;
                const temp = new Uint8ClampedArray(data);
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const dx = x - centerX, dy = y - centerY;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist < radius) {
                            const angle = Math.atan2(dy, dx);
                            const maxAngle = strength * (1 - dist / radius);
                            const newAngle = angle + maxAngle;
                            const newX = Math.round(centerX + dist * Math.cos(newAngle));
                            const newY = Math.round(centerY + dist * Math.sin(newAngle));
                            if (newX >= 0 && newX < width && newY >= 0 && newY < height) {
                                const srcIdx = (y * width + x) * 4;
                                const dstIdx = (newY * width + newX) * 4;
                                data[srcIdx] = temp[dstIdx];
                                data[srcIdx + 1] = temp[dstIdx + 1];
                                data[srcIdx + 2] = temp[dstIdx + 2];
                                data[srcIdx + 3] = temp[dstIdx + 3];
                            }
                        }
                    }
                }
            },
            applyStretch(data, width, height) {
                const centerX = width / 2, centerY = height / 2;
                const stretchX = 1.5, stretchY = 0.7;
                const temp = new Uint8ClampedArray(data);
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const dx = (x - centerX) / stretchX;
                        const dy = (y - centerY) / stretchY;
                        const newX = Math.round(centerX + dx);
                        const newY = Math.round(centerY + dy);
                        if (newX >= 0 && newX < width && newY >= 0 && newY < height) {
                            const srcIdx = (y * width + x) * 4;
                            const dstIdx = (newY * width + newX) * 4;
                            data[srcIdx] = temp[dstIdx];
                            data[srcIdx + 1] = temp[dstIdx + 1];
                            data[srcIdx + 2] = temp[dstIdx + 2];
                            data[srcIdx + 3] = temp[dstIdx + 3];
                        }
                    }
                }
            },
            applyFisheye(data, width, height) {
                const centerX = width / 2, centerY = height / 2;
                const radius = Math.min(width, height) / 2, strength = 0.8;
                const temp = new Uint8ClampedArray(data);
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const dx = x - centerX, dy = y - centerY;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        const normalizedDist = Math.min(dist / radius, 1);
                        const newDist = normalizedDist * (1 - strength * normalizedDist * normalizedDist) * radius;
                        const angle = Math.atan2(dy, dx);
                        const newX = Math.round(centerX + newDist * Math.cos(angle));
                        const newY = Math.round(centerY + newDist * Math.sin(angle));
                        if (newX >= 0 && newX < width && newY >= 0 && newY < height) {
                            const srcIdx = (y * width + x) * 4;
                            const dstIdx = (newY * width + newX) * 4;
                            data[srcIdx] = temp[dstIdx];
                            data[srcIdx + 1] = temp[dstIdx + 1];
                            data[srcIdx + 2] = temp[dstIdx + 2];
                            data[srcIdx + 3] = temp[dstIdx + 3];
                        }
                    }
                }
            },
            applyPinch(data, width, height) {
                const centerX = width / 2, centerY = height / 2;
                const radius = Math.min(width, height) / 2, strength = 0.6;
                const temp = new Uint8ClampedArray(data);
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const dx = x - centerX, dy = y - centerY;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        const normalizedDist = Math.min(dist / radius, 1);
                        const newDist = normalizedDist * (1 + strength * (1 - normalizedDist)) * radius;
                        const angle = Math.atan2(dy, dx);
                        const newX = Math.round(centerX + newDist * Math.cos(angle));
                        const newY = Math.round(centerY + newDist * Math.sin(angle));
                        if (newX >= 0 && newX < width && newY >= 0 && newY < height) {
                            const srcIdx = (y * width + x) * 4;
                            const dstIdx = (newY * width + newX) * 4;
                            data[srcIdx] = temp[dstIdx];
                            data[srcIdx + 1] = temp[dstIdx + 1];
                            data[srcIdx + 2] = temp[dstIdx + 2];
                            data[srcIdx + 3] = temp[dstIdx + 3];
                        }
                    }
                }
            },
            applyWave(data, width, height) {
                const centerY = height / 2;
                const amplitude = 30, frequency = 0.05;
                const temp = new Uint8ClampedArray(data);
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const offset = Math.sin((y - centerY) * frequency) * amplitude;
                        const newX = Math.round(x + offset);
                        if (newX >= 0 && newX < width) {
                            const srcIdx = (y * width + x) * 4;
                            const dstIdx = (y * width + newX) * 4;
                            data[srcIdx] = temp[dstIdx];
                            data[srcIdx + 1] = temp[dstIdx + 1];
                            data[srcIdx + 2] = temp[dstIdx + 2];
                            data[srcIdx + 3] = temp[dstIdx + 3];
                        }
                    }
                }
            },
            applyMirror(data, width, height) {
                const centerX = width / 2;
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < centerX; x++) {
                        const srcIdx = (y * width + x) * 4;
                        const dstIdx = (y * width + (width - x - 1)) * 4;
                        data[dstIdx] = data[srcIdx];
                        data[dstIdx + 1] = data[srcIdx + 1];
                        data[dstIdx + 2] = data[srcIdx + 2];
                        data[dstIdx + 3] = data[srcIdx + 3];
                    }
                }
            },
            applyFlipHorizontal(data, width, height) {
                const temp = new Uint8ClampedArray(data);
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const srcIdx = (y * width + x) * 4;
                        const dstIdx = (y * width + (width - x - 1)) * 4;
                        data[srcIdx] = temp[dstIdx];
                        data[srcIdx + 1] = temp[dstIdx + 1];
                        data[srcIdx + 2] = temp[dstIdx + 2];
                        data[srcIdx + 3] = temp[dstIdx + 3];
                    }
                }
            },
            applyFlipVertical(data, width, height) {
                const temp = new Uint8ClampedArray(data);
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const srcIdx = (y * width + x) * 4;
                        const dstIdx = ((height - y - 1) * width + x) * 4;
                        data[srcIdx] = temp[dstIdx];
                        data[srcIdx + 1] = temp[dstIdx + 1];
                        data[srcIdx + 2] = temp[dstIdx + 2];
                        data[srcIdx + 3] = temp[dstIdx + 3];
                    }
                }
            },
            applyUpsideDown(data, width, height) {
                // Same as flip_vertical - flips image upside down
                const temp = new Uint8ClampedArray(data);
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const srcIdx = (y * width + x) * 4;
                        const dstIdx = ((height - y - 1) * width + x) * 4;
                        data[srcIdx] = temp[dstIdx];
                        data[srcIdx + 1] = temp[dstIdx + 1];
                        data[srcIdx + 2] = temp[dstIdx + 2];
                        data[srcIdx + 3] = temp[dstIdx + 3];
                    }
                }
            },
            applyRotate90(data, width, height) {
                const temp = new Uint8ClampedArray(data);
                const newWidth = height, newHeight = width;
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const srcIdx = (y * width + x) * 4;
                        const newX = height - y - 1;
                        const newY = x;
                        const dstIdx = (newY * newWidth + newX) * 4;
                        if (dstIdx < data.length) {
                            data[dstIdx] = temp[srcIdx];
                            data[dstIdx + 1] = temp[srcIdx + 1];
                            data[dstIdx + 2] = temp[srcIdx + 2];
                            data[dstIdx + 3] = temp[srcIdx + 3];
                        }
                    }
                }
            },
            applyBlur(data, width, height) {
                const radius = 5;
                const temp = new Uint8ClampedArray(data);
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        let r = 0, g = 0, b = 0, count = 0;
                        for (let dy = -radius; dy <= radius; dy++) {
                            for (let dx = -radius; dx <= radius; dx++) {
                                const nx = x + dx, ny = y + dy;
                                if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                                    const idx = (ny * width + nx) * 4;
                                    r += temp[idx]; g += temp[idx + 1]; b += temp[idx + 2]; count++;
                                }
                            }
                        }
                        const idx = (y * width + x) * 4;
                        data[idx] = r / count; data[idx + 1] = g / count; data[idx + 2] = b / count;
                    }
                }
            },
            applySharpen(data, width, height) {
                const kernel = [[0, -1, 0], [-1, 5, -1], [0, -1, 0]];
                const temp = new Uint8ClampedArray(data);
                for (let y = 1; y < height - 1; y++) {
                    for (let x = 1; x < width - 1; x++) {
                        let r = 0, g = 0, b = 0;
                        for (let ky = -1; ky <= 1; ky++) {
                            for (let kx = -1; kx <= 1; kx++) {
                                const idx = ((y + ky) * width + (x + kx)) * 4;
                                const weight = kernel[ky + 1][kx + 1];
                                r += temp[idx] * weight; g += temp[idx + 1] * weight; b += temp[idx + 2] * weight;
                            }
                        }
                        const idx = (y * width + x) * 4;
                        data[idx] = Math.max(0, Math.min(255, r));
                        data[idx + 1] = Math.max(0, Math.min(255, g));
                        data[idx + 2] = Math.max(0, Math.min(255, b));
                    }
                }
            },
            applyEmboss(data, width, height) {
                const kernel = [[-2, -1, 0], [-1, 1, 1], [0, 1, 2]];
                const temp = new Uint8ClampedArray(data);
                for (let y = 1; y < height - 1; y++) {
                    for (let x = 1; x < width - 1; x++) {
                        let r = 0, g = 0, b = 0;
                        for (let ky = -1; ky <= 1; ky++) {
                            for (let kx = -1; kx <= 1; kx++) {
                                const idx = ((y + ky) * width + (x + kx)) * 4;
                                const weight = kernel[ky + 1][kx + 1];
                                r += temp[idx] * weight; g += temp[idx + 1] * weight; b += temp[idx + 2] * weight;
                            }
                        }
                        const idx = (y * width + x) * 4;
                        const gray = (r + g + b) / 3;
                        data[idx] = Math.max(0, Math.min(255, gray + 128));
                        data[idx + 1] = Math.max(0, Math.min(255, gray + 128));
                        data[idx + 2] = Math.max(0, Math.min(255, gray + 128));
                    }
                }
            },
            applySketch(data, width, height) {
                this.applyBlur(data, width, height);
                for (let i = 0; i < data.length; i += 4) {
                    const gray = (data[i] + data[i + 1] + data[i + 2]) / 3;
                    const inverted = 255 - gray;
                    data[i] = data[i + 1] = data[i + 2] = Math.min(255, inverted);
                }
            },
            applyCartoon(data, width, height) {
                this.applyBlur(data, width, height);
                this.applyPosterize(data);
            },
            applyRainbow(data, width, height) {
                for (let y = 0; y < height; y++) {
                    const hue = (y / height) * 360;
                    for (let x = 0; x < width; x++) {
                        const idx = (y * width + x) * 4;
                        const gray = (data[idx] + data[idx + 1] + data[idx + 2]) / 3;
                        const rgb = this.hslToRgb(hue / 360, 1, gray / 255);
                        data[idx] = rgb[0]; data[idx + 1] = rgb[1]; data[idx + 2] = rgb[2];
                    }
                }
            },
            applyRainbowShift(data) {
                for (let i = 0; i < data.length; i += 4) {
                    const gray = (data[i] + data[i + 1] + data[i + 2]) / 3;
                    const hue = (gray / 255 + 0.5) % 1;
                    const rgb = this.hslToRgb(hue, 1, 0.5);
                    data[i] = rgb[0]; data[i + 1] = rgb[1]; data[i + 2] = rgb[2];
                }
            },
            applyIce(data) {
                for (let i = 0; i < data.length; i += 4) {
                    const gray = (data[i] + data[i + 1] + data[i + 2]) / 3;
                    data[i] = Math.min(255, gray * 0.8);
                    data[i + 1] = Math.min(255, gray * 1.2);
                    data[i + 2] = Math.min(255, gray * 1.5);
                }
            },
            applyOcean(data) {
                for (let i = 0; i < data.length; i += 4) {
                    const gray = (data[i] + data[i + 1] + data[i + 2]) / 3;
                    data[i] = Math.min(255, gray * 0.5);
                    data[i + 1] = Math.min(255, gray * 0.8);
                    data[i + 2] = Math.min(255, gray * 1.2);
                }
            },
            applyPlasma(data) {
                for (let i = 0; i < data.length; i += 4) {
                    const gray = (data[i] + data[i + 1] + data[i + 2]) / 3;
                    const hue = (gray / 255) * 0.7;
                    const rgb = this.hslToRgb(hue, 1, 0.5);
                    data[i] = rgb[0]; data[i + 1] = rgb[1]; data[i + 2] = rgb[2];
                }
            },
            applyJet(data) {
                for (let i = 0; i < data.length; i += 4) {
                    const gray = (data[i] + data[i + 1] + data[i + 2]) / 3;
                    const normalized = gray / 255;
                    if (normalized < 0.25) {
                        data[i] = 0;
                        data[i + 1] = 0;
                        data[i + 2] = Math.min(255, normalized * 4 * 255);
                    } else if (normalized < 0.5) {
                        data[i] = 0;
                        data[i + 1] = Math.min(255, (normalized - 0.25) * 4 * 255);
                        data[i + 2] = 255;
                    } else if (normalized < 0.75) {
                        data[i] = Math.min(255, (normalized - 0.5) * 4 * 255);
                        data[i + 1] = 255;
                        data[i + 2] = Math.min(255, 255 - (normalized - 0.5) * 4 * 255);
                    } else {
                        data[i] = 255;
                        data[i + 1] = Math.min(255, 255 - (normalized - 0.75) * 4 * 255);
                        data[i + 2] = 0;
                    }
                }
            },
            applyTurbo(data) {
                for (let i = 0; i < data.length; i += 4) {
                    const gray = (data[i] + data[i + 1] + data[i + 2]) / 3;
                    const normalized = gray / 255;
                    const hue = normalized * 0.8;
                    const rgb = this.hslToRgb(hue, 1, 0.5);
                    data[i] = rgb[0]; data[i + 1] = rgb[1]; data[i + 2] = rgb[2];
                }
            },
            applyInferno(data) {
                for (let i = 0; i < data.length; i += 4) {
                    const gray = (data[i] + data[i + 1] + data[i + 2]) / 3;
                    const normalized = gray / 255;
                    if (normalized < 0.5) {
                        data[i] = Math.min(255, normalized * 2 * 255);
                        data[i + 1] = 0;
                        data[i + 2] = 0;
                    } else {
                        data[i] = 255;
                        data[i + 1] = Math.min(255, (normalized - 0.5) * 2 * 255);
                        data[i + 2] = Math.min(255, (normalized - 0.5) * 2 * 128);
                    }
                }
            },
            applyMagma(data) {
                for (let i = 0; i < data.length; i += 4) {
                    const gray = (data[i] + data[i + 1] + data[i + 2]) / 3;
                    const normalized = gray / 255;
                    data[i] = Math.min(255, normalized * 255);
                    data[i + 1] = Math.min(255, normalized * normalized * 128);
                    data[i + 2] = Math.min(255, normalized * normalized * normalized * 255);
                }
            },
            applyViridis(data) {
                for (let i = 0; i < data.length; i += 4) {
                    const gray = (data[i] + data[i + 1] + data[i + 2]) / 3;
                    const normalized = gray / 255;
                    const hue = normalized * 0.6;
                    const rgb = this.hslToRgb(hue, 1, normalized * 0.5 + 0.3);
                    data[i] = rgb[0]; data[i + 1] = rgb[1]; data[i + 2] = rgb[2];
                }
            },
            applyCool(data) {
                for (let i = 0; i < data.length; i += 4) {
                    const gray = (data[i] + data[i + 1] + data[i + 2]) / 3;
                    data[i] = Math.min(255, gray * 0.5);
                    data[i + 1] = Math.min(255, gray);
                    data[i + 2] = Math.min(255, gray * 1.5);
                }
            },
            applyHot(data) {
                for (let i = 0; i < data.length; i += 4) {
                    const gray = (data[i] + data[i + 1] + data[i + 2]) / 3;
                    const normalized = gray / 255;
                    if (normalized < 0.33) {
                        data[i] = Math.min(255, normalized * 3 * 255);
                        data[i + 1] = 0;
                        data[i + 2] = 0;
                    } else if (normalized < 0.66) {
                        data[i] = 255;
                        data[i + 1] = Math.min(255, (normalized - 0.33) * 3 * 255);
                        data[i + 2] = 0;
                    } else {
                        data[i] = 255;
                        data[i + 1] = 255;
                        data[i + 2] = Math.min(255, (normalized - 0.66) * 3 * 255);
                    }
                }
            },
            applySpring(data) {
                for (let i = 0; i < data.length; i += 4) {
                    const gray = (data[i] + data[i + 1] + data[i + 2]) / 3;
                    data[i] = 255;
                    data[i + 1] = Math.min(255, gray);
                    data[i + 2] = Math.min(255, gray * 0.5);
                }
            },
            applySummer(data) {
                for (let i = 0; i < data.length; i += 4) {
                    const gray = (data[i] + data[i + 1] + data[i + 2]) / 3;
                    data[i] = Math.min(255, gray);
                    data[i + 1] = Math.min(255, gray * 1.2);
                    data[i + 2] = Math.min(255, gray * 0.3);
                }
            },
            applyAutumn(data) {
                for (let i = 0; i < data.length; i += 4) {
                    const gray = (data[i] + data[i + 1] + data[i + 2]) / 3;
                    data[i] = 255;
                    data[i + 1] = Math.min(255, gray);
                    data[i + 2] = 0;
                }
            },
            applyWinter(data) {
                for (let i = 0; i < data.length; i += 4) {
                    const gray = (data[i] + data[i + 1] + data[i + 2]) / 3;
                    data[i] = 0;
                    data[i + 1] = Math.min(255, gray * 0.5);
                    data[i + 2] = Math.min(255, gray);
                }
            },
            applyVHS(data, width, height) {
                // Add noise
                for (let i = 0; i < data.length; i += 4) {
                    const noise = Math.random() * 30;
                    data[i] = Math.min(255, data[i] + noise);
                    data[i + 1] = Math.min(255, data[i + 1] + noise);
                    data[i + 2] = Math.min(255, data[i + 2] + noise);
                }
                // Add scanlines
                for (let y = 0; y < height; y += 3) {
                    for (let x = 0; x < width; x++) {
                        const idx = (y * width + x) * 4;
                        data[idx] = Math.min(255, data[idx] * 0.8);
                        data[idx + 1] = Math.min(255, data[idx + 1] * 1.2);
                        data[idx + 2] = Math.min(255, data[idx + 2] * 0.8);
                    }
                }
            },
            applyRetro(data, width, height) {
                this.applySepia(data);
                this.applyVHS(data, width, height);
            },
            applyCyberpunk(data, width, height) {
                // Shift hue to cyan/magenta
                for (let i = 0; i < data.length; i += 4) {
                    const gray = (data[i] + data[i + 1] + data[i + 2]) / 3;
                    const hue = (gray / 255 + 0.5) % 1;
                    const rgb = this.hslToRgb(hue, 1, 0.6);
                    data[i] = rgb[0]; data[i + 1] = rgb[1]; data[i + 2] = rgb[2];
                }
                // Increase contrast
                for (let i = 0; i < data.length; i += 4) {
                    data[i] = Math.min(255, (data[i] - 128) * 1.5 + 128);
                    data[i + 1] = Math.min(255, (data[i + 1] - 128) * 1.5 + 128);
                    data[i + 2] = Math.min(255, (data[i + 2] - 128) * 1.5 + 128);
                }
            },
            hslToRgb(h, s, l) {
                let r, g, b;
                if (s === 0) {
                    r = g = b = l;
                } else {
                    const hue2rgb = (p, q, t) => {
                        if (t < 0) t += 1; if (t > 1) t -= 1;
                        if (t < 1/6) return p + (q - p) * 6 * t;
                        if (t < 1/2) return q;
                        if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                        return p;
                    };
                    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                    const p = 2 * l - q;
                    r = hue2rgb(p, q, h + 1/3);
                    g = hue2rgb(p, q, h);
                    b = hue2rgb(p, q, h - 1/3);
                }
                return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
            },
            applyAnime(data, width, height) {
                this.applyBlur(data, width, height);
                // Increase saturation
                for (let i = 0; i < data.length; i += 4) {
                    const gray = (data[i] + data[i + 1] + data[i + 2]) / 3;
                    data[i] = Math.min(255, gray + (data[i] - gray) * 1.5);
                    data[i + 1] = Math.min(255, gray + (data[i + 1] - gray) * 1.5);
                    data[i + 2] = Math.min(255, gray + (data[i + 2] - gray) * 1.5);
                }
            },
            applyGlow(data, width, height) {
                const temp = new Uint8ClampedArray(data);
                this.applyBlur(data, width, height);
                // Blend original with blurred
                for (let i = 0; i < data.length; i += 4) {
                    data[i] = Math.min(255, temp[i] * 1.2 + data[i] * 0.3);
                    data[i + 1] = Math.min(255, temp[i + 1] * 1.2 + data[i + 1] * 0.3);
                    data[i + 2] = Math.min(255, temp[i + 2] * 1.2 + data[i + 2] * 0.3);
                }
            },
            applySolarize(data) {
                for (let i = 0; i < data.length; i += 4) {
                    const threshold = 128;
                    data[i] = data[i] > threshold ? 255 - data[i] : data[i];
                    data[i + 1] = data[i + 1] > threshold ? 255 - data[i + 1] : data[i + 1];
                    data[i + 2] = data[i + 2] > threshold ? 255 - data[i + 2] : data[i + 2];
                }
            },
            applyEdgeDetect(data, width, height) {
                const kernelX = [[-1, 0, 1], [-2, 0, 2], [-1, 0, 1]];
                const kernelY = [[-1, -2, -1], [0, 0, 0], [1, 2, 1]];
                const temp = new Uint8ClampedArray(data);
                for (let y = 1; y < height - 1; y++) {
                    for (let x = 1; x < width - 1; x++) {
                        let gx = 0, gy = 0;
                        for (let ky = -1; ky <= 1; ky++) {
                            for (let kx = -1; kx <= 1; kx++) {
                                const idx = ((y + ky) * width + (x + kx)) * 4;
                                const gray = (temp[idx] + temp[idx + 1] + temp[idx + 2]) / 3;
                                gx += gray * kernelX[ky + 1][kx + 1];
                                gy += gray * kernelY[ky + 1][kx + 1];
                            }
                        }
                        const magnitude = Math.sqrt(gx * gx + gy * gy);
                        const idx = (y * width + x) * 4;
                        const val = Math.min(255, magnitude);
                        data[idx] = val;
                        data[idx + 1] = val;
                        data[idx + 2] = val;
                    }
                }
            },
            applyHalftone(data, width, height) {
                const temp = new Uint8ClampedArray(data);
                const dotSize = 4;
                for (let y = 0; y < height; y += dotSize) {
                    for (let x = 0; x < width; x += dotSize) {
                        let gray = 0, count = 0;
                        for (let dy = 0; dy < dotSize && y + dy < height; dy++) {
                            for (let dx = 0; dx < dotSize && x + dx < width; dx++) {
                                const idx = ((y + dy) * width + (x + dx)) * 4;
                                gray += (temp[idx] + temp[idx + 1] + temp[idx + 2]) / 3;
                                count++;
                            }
                        }
                        gray = gray / count;
                        const radius = (1 - gray / 255) * (dotSize / 2);
                        for (let dy = 0; dy < dotSize && y + dy < height; dy++) {
                            for (let dx = 0; dx < dotSize && x + dx < width; dx++) {
                                const idx = ((y + dy) * width + (x + dx)) * 4;
                                const dist = Math.sqrt((dx - dotSize/2) ** 2 + (dy - dotSize/2) ** 2);
                                if (dist < radius) {
                                    data[idx] = 0;
                                    data[idx + 1] = 0;
                                    data[idx + 2] = 0;
                                } else {
                                    data[idx] = 255;
                                    data[idx + 1] = 255;
                                    data[idx + 2] = 255;
                                }
                            }
                        }
                    }
                }
            },
            applyAcidTrip(data, width, height) {
                this.applySwirl(data, width, height);
                this.applyRainbow(data, width, height);
            },
            applyTwirl(data, width, height) {
                const centerX = width / 2, centerY = height / 2;
                const radius = Math.min(width, height) / 2, strength = 3.0;
                const temp = new Uint8ClampedArray(data);
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const dx = x - centerX, dy = y - centerY;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist < radius) {
                            const angle = Math.atan2(dy, dx);
                            const maxAngle = strength * (1 - dist / radius);
                            const newAngle = angle + maxAngle;
                            const newX = Math.round(centerX + dist * Math.cos(newAngle));
                            const newY = Math.round(centerY + dist * Math.sin(newAngle));
                            if (newX >= 0 && newX < width && newY >= 0 && newY < height) {
                                const srcIdx = (y * width + x) * 4;
                                const dstIdx = (newY * width + newX) * 4;
                                data[srcIdx] = temp[dstIdx];
                                data[srcIdx + 1] = temp[dstIdx + 1];
                                data[srcIdx + 2] = temp[dstIdx + 2];
                                data[srcIdx + 3] = temp[dstIdx + 3];
                            }
                        }
                    }
                }
            },
            applyRipple(data, width, height) {
                const centerX = width / 2, centerY = height / 2;
                const frequency = 0.1, amplitude = 20;
                const temp = new Uint8ClampedArray(data);
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const dx = x - centerX, dy = y - centerY;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        const ripple = Math.sin(dist * frequency) * amplitude;
                        const angle = Math.atan2(dy, dx);
                        const newX = Math.round(x + ripple * Math.cos(angle));
                        const newY = Math.round(y + ripple * Math.sin(angle));
                        if (newX >= 0 && newX < width && newY >= 0 && newY < height) {
                            const srcIdx = (y * width + x) * 4;
                            const dstIdx = (newY * width + newX) * 4;
                            data[srcIdx] = temp[dstIdx];
                            data[srcIdx + 1] = temp[dstIdx + 1];
                            data[srcIdx + 2] = temp[dstIdx + 2];
                            data[srcIdx + 3] = temp[dstIdx + 3];
                        }
                    }
                }
            },
            applySphere(data, width, height) {
                const centerX = width / 2, centerY = height / 2;
                const radius = Math.min(width, height) / 2, strength = 0.5;
                const temp = new Uint8ClampedArray(data);
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const dx = x - centerX, dy = y - centerY;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        const normalizedDist = Math.min(dist / radius, 1);
                        const newDist = normalizedDist * (1 - strength * normalizedDist) * radius;
                        const angle = Math.atan2(dy, dx);
                        const newX = Math.round(centerX + newDist * Math.cos(angle));
                        const newY = Math.round(centerY + newDist * Math.sin(angle));
                        if (newX >= 0 && newX < width && newY >= 0 && newY < height) {
                            const srcIdx = (y * width + x) * 4;
                            const dstIdx = (newY * width + newX) * 4;
                            data[srcIdx] = temp[dstIdx];
                            data[srcIdx + 1] = temp[dstIdx + 1];
                            data[srcIdx + 2] = temp[dstIdx + 2];
                            data[srcIdx + 3] = temp[dstIdx + 3];
                        }
                    }
                }
            },
            applyTunnel(data, width, height) {
                const centerX = width / 2, centerY = height / 2;
                const maxDist = Math.min(width, height) / 2, strength = 0.8;
                const temp = new Uint8ClampedArray(data);
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const dx = x - centerX, dy = y - centerY;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        const normalizedDist = Math.min(dist / maxDist, 1);
                        const newDist = normalizedDist * (1 + strength * normalizedDist) * maxDist;
                        const angle = Math.atan2(dy, dx);
                        const newX = Math.round(centerX + newDist * Math.cos(angle));
                        const newY = Math.round(centerY + newDist * Math.sin(angle));
                        if (newX >= 0 && newX < width && newY >= 0 && newY < height) {
                            const srcIdx = (y * width + x) * 4;
                            const dstIdx = (newY * width + newX) * 4;
                            data[srcIdx] = temp[dstIdx];
                            data[srcIdx + 1] = temp[dstIdx + 1];
                            data[srcIdx + 2] = temp[dstIdx + 2];
                            data[srcIdx + 3] = temp[dstIdx + 3];
                        }
                    }
                }
            },
            applyWaterRipple(data, width, height) {
                const centerX = width / 2, centerY = height / 2;
                const frequency = 0.05, amplitude = 15;
                const temp = new Uint8ClampedArray(data);
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const dx = x - centerX, dy = y - centerY;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        const ripple = Math.sin(dist * frequency) * amplitude;
                        const angle = Math.atan2(dy, dx);
                        const newX = Math.round(x + ripple * Math.cos(angle));
                        const newY = Math.round(y + ripple * Math.sin(angle));
                        if (newX >= 0 && newX < width && newY >= 0 && newY < height) {
                            const srcIdx = (y * width + x) * 4;
                            const dstIdx = (newY * width + newX) * 4;
                            data[srcIdx] = temp[dstIdx];
                            data[srcIdx + 1] = temp[dstIdx + 1];
                            data[srcIdx + 2] = temp[dstIdx + 2];
                            data[srcIdx + 3] = temp[dstIdx + 3];
                        }
                    }
                }
            },
            applyRadialBlur(data, width, height) {
                const centerX = width / 2, centerY = height / 2;
                const maxDist = Math.min(width, height) / 2, blurStrength = 5;
                const temp = new Uint8ClampedArray(data);
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const dx = x - centerX, dy = y - centerY;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        const offset = blurStrength * (dist / maxDist);
                        const angle = Math.atan2(dy, dx);
                        const newX = Math.round(x + offset * Math.cos(angle));
                        const newY = Math.round(y + offset * Math.sin(angle));
                        if (newX >= 0 && newX < width && newY >= 0 && newY < height) {
                            const srcIdx = (y * width + x) * 4;
                            const dstIdx = (newY * width + newX) * 4;
                            data[srcIdx] = temp[dstIdx];
                            data[srcIdx + 1] = temp[dstIdx + 1];
                            data[srcIdx + 2] = temp[dstIdx + 2];
                            data[srcIdx + 3] = temp[dstIdx + 3];
                        }
                    }
                }
            },
            applyCylinder(data, width, height) {
                const centerX = width / 2;
                const strength = 0.3;
                const temp = new Uint8ClampedArray(data);
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const dx = x - centerX;
                        const newX = Math.round(centerX + dx * (1 - strength * (dx / (width / 2)) ** 2));
                        if (newX >= 0 && newX < width) {
                            const srcIdx = (y * width + x) * 4;
                            const dstIdx = (y * width + newX) * 4;
                            data[srcIdx] = temp[dstIdx];
                            data[srcIdx + 1] = temp[dstIdx + 1];
                            data[srcIdx + 2] = temp[dstIdx + 2];
                            data[srcIdx + 3] = temp[dstIdx + 3];
                        }
                    }
                }
            },
            applyBarrel(data, width, height) {
                const centerX = width / 2, centerY = height / 2;
                const radius = Math.min(width, height) / 2, strength = 0.3;
                const temp = new Uint8ClampedArray(data);
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const dx = x - centerX, dy = y - centerY;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        const normalizedDist = Math.min(dist / radius, 1);
                        const newDist = normalizedDist * (1 + strength * normalizedDist * normalizedDist) * radius;
                        const angle = Math.atan2(dy, dx);
                        const newX = Math.round(centerX + newDist * Math.cos(angle));
                        const newY = Math.round(centerY + newDist * Math.sin(angle));
                        if (newX >= 0 && newX < width && newY >= 0 && newY < height) {
                            const srcIdx = (y * width + x) * 4;
                            const dstIdx = (newY * width + newX) * 4;
                            data[srcIdx] = temp[dstIdx];
                            data[srcIdx + 1] = temp[dstIdx + 1];
                            data[srcIdx + 2] = temp[dstIdx + 2];
                            data[srcIdx + 3] = temp[dstIdx + 3];
                        }
                    }
                }
            },
            applyPincushion(data, width, height) {
                const centerX = width / 2, centerY = height / 2;
                const radius = Math.min(width, height) / 2, strength = 0.4;
                const temp = new Uint8ClampedArray(data);
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const dx = x - centerX, dy = y - centerY;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        const normalizedDist = Math.min(dist / radius, 1);
                        const newDist = normalizedDist * (1 - strength * normalizedDist) * radius;
                        const angle = Math.atan2(dy, dx);
                        const newX = Math.round(centerX + newDist * Math.cos(angle));
                        const newY = Math.round(centerY + newDist * Math.sin(angle));
                        if (newX >= 0 && newX < width && newY >= 0 && newY < height) {
                            const srcIdx = (y * width + x) * 4;
                            const dstIdx = (newY * width + newX) * 4;
                            data[srcIdx] = temp[dstIdx];
                            data[srcIdx + 1] = temp[dstIdx + 1];
                            data[srcIdx + 2] = temp[dstIdx + 2];
                            data[srcIdx + 3] = temp[dstIdx + 3];
                        }
                    }
                }
            },
            applyWhirlpool(data, width, height) {
                const centerX = width / 2, centerY = height / 2;
                const radius = Math.min(width, height) / 2, strength = 4.0;
                const temp = new Uint8ClampedArray(data);
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const dx = x - centerX, dy = y - centerY;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        const angle = Math.atan2(dy, dx);
                        const maxAngle = strength * (1 - Math.min(dist / radius, 1));
                        const newAngle = angle + maxAngle;
                        const newDist = dist * 0.9;
                        const newX = Math.round(centerX + newDist * Math.cos(newAngle));
                        const newY = Math.round(centerY + newDist * Math.sin(newAngle));
                        if (newX >= 0 && newX < width && newY >= 0 && newY < height) {
                            const srcIdx = (y * width + x) * 4;
                            const dstIdx = (newY * width + newX) * 4;
                            data[srcIdx] = temp[dstIdx];
                            data[srcIdx + 1] = temp[dstIdx + 1];
                            data[srcIdx + 2] = temp[dstIdx + 2];
                            data[srcIdx + 3] = temp[dstIdx + 3];
                        }
                    }
                }
            },
            applyRadialZoom(data, width, height) {
                const centerX = width / 2, centerY = height / 2;
                const maxDist = Math.min(width, height) / 2, zoomStrength = 0.5;
                const temp = new Uint8ClampedArray(data);
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const dx = x - centerX, dy = y - centerY;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        const zoomFactor = 1.0 + zoomStrength * (1.0 - dist / maxDist);
                        const newX = Math.round(centerX + dx / zoomFactor);
                        const newY = Math.round(centerY + dy / zoomFactor);
                        if (newX >= 0 && newX < width && newY >= 0 && newY < height) {
                            const srcIdx = (y * width + x) * 4;
                            const dstIdx = (newY * width + newX) * 4;
                            data[srcIdx] = temp[dstIdx];
                            data[srcIdx + 1] = temp[dstIdx + 1];
                            data[srcIdx + 2] = temp[dstIdx + 2];
                            data[srcIdx + 3] = temp[dstIdx + 3];
                        }
                    }
                }
            },
            applyConcave(data, width, height) {
                const centerX = width / 2, centerY = height / 2;
                const radius = Math.min(width, height) / 2, strength = 0.6;
                const temp = new Uint8ClampedArray(data);
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const dx = x - centerX, dy = y - centerY;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        const normalizedDist = Math.min(dist / radius, 1);
                        const newDist = normalizedDist * (1 - strength * normalizedDist) * radius;
                        const angle = Math.atan2(dy, dx);
                        const newX = Math.round(centerX + newDist * Math.cos(angle));
                        const newY = Math.round(centerY + newDist * Math.sin(angle));
                        if (newX >= 0 && newX < width && newY >= 0 && newY < height) {
                            const srcIdx = (y * width + x) * 4;
                            const dstIdx = (newY * width + newX) * 4;
                            data[srcIdx] = temp[dstIdx];
                            data[srcIdx + 1] = temp[dstIdx + 1];
                            data[srcIdx + 2] = temp[dstIdx + 2];
                            data[srcIdx + 3] = temp[dstIdx + 3];
                        }
                    }
                }
            },
            applyConvex(data, width, height) {
                const centerX = width / 2, centerY = height / 2;
                const radius = Math.min(width, height) / 2, strength = 0.5;
                const temp = new Uint8ClampedArray(data);
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const dx = x - centerX, dy = y - centerY;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        const normalizedDist = Math.min(dist / radius, 1);
                        const newDist = normalizedDist * (1 + strength * normalizedDist) * radius;
                        const angle = Math.atan2(dy, dx);
                        const newX = Math.round(centerX + newDist * Math.cos(angle));
                        const newY = Math.round(centerY + newDist * Math.sin(angle));
                        if (newX >= 0 && newX < width && newY >= 0 && newY < height) {
                            const srcIdx = (y * width + x) * 4;
                            const dstIdx = (newY * width + newX) * 4;
                            data[srcIdx] = temp[dstIdx];
                            data[srcIdx + 1] = temp[dstIdx + 1];
                            data[srcIdx + 2] = temp[dstIdx + 2];
                            data[srcIdx + 3] = temp[dstIdx + 3];
                        }
                    }
                }
            },
            applySpiral(data, width, height) {
                const centerX = width / 2, centerY = height / 2;
                const radius = Math.min(width, height) / 2, turns = 2.0;
                const temp = new Uint8ClampedArray(data);
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const dx = x - centerX, dy = y - centerY;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        const angle = Math.atan2(dy, dx);
                        const spiralAngle = angle + turns * Math.PI * (dist / radius);
                        const newX = Math.round(centerX + dist * Math.cos(spiralAngle));
                        const newY = Math.round(centerY + dist * Math.sin(spiralAngle));
                        if (newX >= 0 && newX < width && newY >= 0 && newY < height) {
                            const srcIdx = (y * width + x) * 4;
                            const dstIdx = (newY * width + newX) * 4;
                            data[srcIdx] = temp[dstIdx];
                            data[srcIdx + 1] = temp[dstIdx + 1];
                            data[srcIdx + 2] = temp[dstIdx + 2];
                            data[srcIdx + 3] = temp[dstIdx + 3];
                        }
                    }
                }
            },
            applyRadialStretch(data, width, height) {
                const centerX = width / 2, centerY = height / 2;
                const maxDist = Math.min(width, height) / 2;
                const temp = new Uint8ClampedArray(data);
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const dx = x - centerX, dy = y - centerY;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        const stretchFactor = 1.0 + 0.5 * (dist / maxDist);
                        const angle = Math.atan2(dy, dx);
                        const newX = Math.round(centerX + dist * stretchFactor * Math.cos(angle));
                        const newY = Math.round(centerY + dist * stretchFactor * Math.sin(angle));
                        if (newX >= 0 && newX < width && newY >= 0 && newY < height) {
                            const srcIdx = (y * width + x) * 4;
                            const dstIdx = (newY * width + newX) * 4;
                            data[srcIdx] = temp[dstIdx];
                            data[srcIdx + 1] = temp[dstIdx + 1];
                            data[srcIdx + 2] = temp[dstIdx + 2];
                            data[srcIdx + 3] = temp[dstIdx + 3];
                        }
                    }
                }
            },
            applyRadialCompress(data, width, height) {
                const centerX = width / 2, centerY = height / 2;
                const maxDist = Math.min(width, height) / 2;
                const temp = new Uint8ClampedArray(data);
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const dx = x - centerX, dy = y - centerY;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        const compressFactor = 1.0 - 0.3 * (dist / maxDist);
                        const angle = Math.atan2(dy, dx);
                        const newX = Math.round(centerX + dist * compressFactor * Math.cos(angle));
                        const newY = Math.round(centerY + dist * compressFactor * Math.sin(angle));
                        if (newX >= 0 && newX < width && newY >= 0 && newY < height) {
                            const srcIdx = (y * width + x) * 4;
                            const dstIdx = (newY * width + newX) * 4;
                            data[srcIdx] = temp[dstIdx];
                            data[srcIdx + 1] = temp[dstIdx + 1];
                            data[srcIdx + 2] = temp[dstIdx + 2];
                            data[srcIdx + 3] = temp[dstIdx + 3];
                        }
                    }
                }
            },
            applyVerticalWave(data, width, height) {
                const centerX = width / 2;
                const amplitude = 25, frequency = 0.05;
                const temp = new Uint8ClampedArray(data);
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const offset = Math.sin((x - centerX) * frequency) * amplitude;
                        const newY = Math.round(y + offset);
                        if (newY >= 0 && newY < height) {
                            const srcIdx = (y * width + x) * 4;
                            const dstIdx = (newY * width + x) * 4;
                            data[srcIdx] = temp[dstIdx];
                            data[srcIdx + 1] = temp[dstIdx + 1];
                            data[srcIdx + 2] = temp[dstIdx + 2];
                            data[srcIdx + 3] = temp[dstIdx + 3];
                        }
                    }
                }
            },
            applyHorizontalWave(data, width, height) {
                const centerY = height / 2;
                const amplitude = 25, frequency = 0.05;
                const temp = new Uint8ClampedArray(data);
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const offset = Math.sin((y - centerY) * frequency) * amplitude;
                        const newX = Math.round(x + offset);
                        if (newX >= 0 && newX < width) {
                            const srcIdx = (y * width + x) * 4;
                            const dstIdx = (y * width + newX) * 4;
                            data[srcIdx] = temp[dstIdx];
                            data[srcIdx + 1] = temp[dstIdx + 1];
                            data[srcIdx + 2] = temp[dstIdx + 2];
                            data[srcIdx + 3] = temp[dstIdx + 3];
                        }
                    }
                }
            },
            applySkewHorizontal(data, width, height) {
                const centerY = height / 2, strength = 0.3;
                const temp = new Uint8ClampedArray(data);
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const offset = (y - centerY) * strength;
                        const newX = Math.round(x + offset);
                        if (newX >= 0 && newX < width) {
                            const srcIdx = (y * width + x) * 4;
                            const dstIdx = (y * width + newX) * 4;
                            data[srcIdx] = temp[dstIdx];
                            data[srcIdx + 1] = temp[dstIdx + 1];
                            data[srcIdx + 2] = temp[dstIdx + 2];
                            data[srcIdx + 3] = temp[dstIdx + 3];
                        }
                    }
                }
            },
            applySkewVertical(data, width, height) {
                const centerX = width / 2, strength = 0.3;
                const temp = new Uint8ClampedArray(data);
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const offset = (x - centerX) * strength;
                        const newY = Math.round(y + offset);
                        if (newY >= 0 && newY < height) {
                            const srcIdx = (y * width + x) * 4;
                            const dstIdx = (newY * width + x) * 4;
                            data[srcIdx] = temp[dstIdx];
                            data[srcIdx + 1] = temp[dstIdx + 1];
                            data[srcIdx + 2] = temp[dstIdx + 2];
                            data[srcIdx + 3] = temp[dstIdx + 3];
                        }
                    }
                }
            },
            applyRotateZoom(data, width, height) {
                const centerX = width / 2, centerY = height / 2;
                const maxDist = Math.min(width, height) / 2;
                const temp = new Uint8ClampedArray(data);
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const dx = x - centerX, dy = y - centerY;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        const angle = Math.atan2(dy, dx);
                        const rotation = 2.0 * Math.PI * (dist / maxDist);
                        const zoomFactor = 1.0 + 0.3 * (dist / maxDist);
                        const newAngle = angle + rotation;
                        const newDist = dist / zoomFactor;
                        const newX = Math.round(centerX + newDist * Math.cos(newAngle));
                        const newY = Math.round(centerY + newDist * Math.sin(newAngle));
                        if (newX >= 0 && newX < width && newY >= 0 && newY < height) {
                            const srcIdx = (y * width + x) * 4;
                            const dstIdx = (newY * width + newX) * 4;
                            data[srcIdx] = temp[dstIdx];
                            data[srcIdx + 1] = temp[dstIdx + 1];
                            data[srcIdx + 2] = temp[dstIdx + 2];
                            data[srcIdx + 3] = temp[dstIdx + 3];
                        }
                    }
                }
            },
            applyRadialWave(data, width, height) {
                const centerX = width / 2, centerY = height / 2;
                const frequency = 0.1, amplitude = 15;
                const temp = new Uint8ClampedArray(data);
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const dx = x - centerX, dy = y - centerY;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        const angle = Math.atan2(dy, dx);
                        const radialWave = Math.sin(dist * frequency) * amplitude;
                        const newAngle = angle + radialWave / Math.max(dist, 1);
                        const newX = Math.round(centerX + dist * Math.cos(newAngle));
                        const newY = Math.round(centerY + dist * Math.sin(newAngle));
                        if (newX >= 0 && newX < width && newY >= 0 && newY < height) {
                            const srcIdx = (y * width + x) * 4;
                            const dstIdx = (newY * width + newX) * 4;
                            data[srcIdx] = temp[dstIdx];
                            data[srcIdx + 1] = temp[dstIdx + 1];
                            data[srcIdx + 2] = temp[dstIdx + 2];
                            data[srcIdx + 3] = temp[dstIdx + 3];
                        }
                    }
                }
            },
            applyZoomIn(data, width, height) {
                const centerX = width / 2, centerY = height / 2;
                const zoomFactor = 1.3;
                const temp = new Uint8ClampedArray(data);
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const dx = x - centerX, dy = y - centerY;
                        const newX = Math.round(centerX + dx / zoomFactor);
                        const newY = Math.round(centerY + dy / zoomFactor);
                        if (newX >= 0 && newX < width && newY >= 0 && newY < height) {
                            const srcIdx = (y * width + x) * 4;
                            const dstIdx = (newY * width + newX) * 4;
                            data[srcIdx] = temp[dstIdx];
                            data[srcIdx + 1] = temp[dstIdx + 1];
                            data[srcIdx + 2] = temp[dstIdx + 2];
                            data[srcIdx + 3] = temp[dstIdx + 3];
                        }
                    }
                }
            },
            applyZoomOut(data, width, height) {
                const centerX = width / 2, centerY = height / 2;
                const zoomFactor = 0.8;
                const temp = new Uint8ClampedArray(data);
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const dx = x - centerX, dy = y - centerY;
                        const newX = Math.round(centerX + dx / zoomFactor);
                        const newY = Math.round(centerY + dy / zoomFactor);
                        if (newX >= 0 && newX < width && newY >= 0 && newY < height) {
                            const srcIdx = (y * width + x) * 4;
                            const dstIdx = (newY * width + newX) * 4;
                            data[srcIdx] = temp[dstIdx];
                            data[srcIdx + 1] = temp[dstIdx + 1];
                            data[srcIdx + 2] = temp[dstIdx + 2];
                            data[srcIdx + 3] = temp[dstIdx + 3];
                        }
                    }
                }
            },
            applyRotate(data, width, height) {
                const centerX = width / 2, centerY = height / 2;
                const rotationAngle = Math.PI / 4;
                const cosA = Math.cos(rotationAngle);
                const sinA = Math.sin(rotationAngle);
                const temp = new Uint8ClampedArray(data);
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const dx = x - centerX, dy = y - centerY;
                        const newX = Math.round(centerX + dx * cosA - dy * sinA);
                        const newY = Math.round(centerY + dx * sinA + dy * cosA);
                        if (newX >= 0 && newX < width && newY >= 0 && newY < height) {
                            const srcIdx = (y * width + x) * 4;
                            const dstIdx = (newY * width + newX) * 4;
                            data[srcIdx] = temp[dstIdx];
                            data[srcIdx + 1] = temp[dstIdx + 1];
                            data[srcIdx + 2] = temp[dstIdx + 2];
                            data[srcIdx + 3] = temp[dstIdx + 3];
                        }
                    }
                }
            },
            applyRotate45(data, width, height) {
                this.applyRotate(data, width, height);
            },
            applyFlipBoth(data, width, height) {
                this.applyFlipHorizontal(data, width, height);
                this.applyFlipVertical(data, width, height);
            },
            applyQuadMirror(data, width, height) {
                const h = height / 2, w = width / 2;
                for (let y = 0; y < h; y++) {
                    for (let x = 0; x < w; x++) {
                        const srcIdx = (y * width + x) * 4;
                        // Top-right
                        const trIdx = (y * width + (width - x - 1)) * 4;
                        data[trIdx] = data[srcIdx];
                        data[trIdx + 1] = data[srcIdx + 1];
                        data[trIdx + 2] = data[srcIdx + 2];
                        data[trIdx + 3] = data[srcIdx + 3];
                        // Bottom-left
                        const blIdx = ((height - y - 1) * width + x) * 4;
                        data[blIdx] = data[srcIdx];
                        data[blIdx + 1] = data[srcIdx + 1];
                        data[blIdx + 2] = data[srcIdx + 2];
                        data[blIdx + 3] = data[srcIdx + 3];
                        // Bottom-right
                        const brIdx = ((height - y - 1) * width + (width - x - 1)) * 4;
                        data[brIdx] = data[srcIdx];
                        data[brIdx + 1] = data[srcIdx + 1];
                        data[brIdx + 2] = data[srcIdx + 2];
                        data[brIdx + 3] = data[srcIdx + 3];
                    }
                }
            },
            applyTile(data, width, height) {
                const smallW = width / 4, smallH = height / 4;
                const temp = new Uint8ClampedArray(data);
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const srcX = x % smallW;
                        const srcY = y % smallH;
                        const srcIdx = (Math.floor(srcY) * width + Math.floor(srcX)) * 4;
                        const dstIdx = (y * width + x) * 4;
                        data[dstIdx] = temp[srcIdx];
                        data[dstIdx + 1] = temp[srcIdx + 1];
                        data[dstIdx + 2] = temp[srcIdx + 2];
                        data[dstIdx + 3] = temp[srcIdx + 3];
                    }
                }
            },
            applyRadialTile(data, width, height) {
                const smallW = width / 3, smallH = height / 3;
                const temp = new Uint8ClampedArray(data);
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const srcX = (x % smallW) + Math.floor(x / smallW) * smallW;
                        const srcY = (y % smallH) + Math.floor(y / smallH) * smallH;
                        const srcIdx = (Math.floor(srcY) * width + Math.floor(srcX)) * 4;
                        const dstIdx = (y * width + x) * 4;
                        if (srcIdx < data.length && dstIdx < data.length) {
                            data[dstIdx] = temp[srcIdx];
                            data[dstIdx + 1] = temp[srcIdx + 1];
                            data[dstIdx + 2] = temp[srcIdx + 2];
                            data[dstIdx + 3] = temp[srcIdx + 3];
                        }
                    }
                }
            },
            applyZoomBlur(data, width, height) {
                const centerX = width / 2, centerY = height / 2;
                const maxDist = Math.min(width, height) / 2;
                const temp = new Uint8ClampedArray(data);
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const dx = x - centerX, dy = y - centerY;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        const zoomFactor = 1.0 + (dist / maxDist) * 0.3;
                        const newX = Math.round(centerX + dx / zoomFactor);
                        const newY = Math.round(centerY + dy / zoomFactor);
                        if (newX >= 0 && newX < width && newY >= 0 && newY < height) {
                            const srcIdx = (y * width + x) * 4;
                            const dstIdx = (newY * width + newX) * 4;
                            data[srcIdx] = temp[dstIdx];
                            data[srcIdx + 1] = temp[dstIdx + 1];
                            data[srcIdx + 2] = temp[dstIdx + 2];
                            data[srcIdx + 3] = temp[dstIdx + 3];
                        }
                    }
                }
            },
            applyMelt(data, width, height) {
                const strength = 30;
                const temp = new Uint8ClampedArray(data);
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const offset = Math.sin(x * 0.05) * strength;
                        const newY = Math.round(y + offset);
                        if (newY >= 0 && newY < height) {
                            const srcIdx = (y * width + x) * 4;
                            const dstIdx = (newY * width + x) * 4;
                            data[srcIdx] = temp[dstIdx];
                            data[srcIdx + 1] = temp[dstIdx + 1];
                            data[srcIdx + 2] = temp[dstIdx + 2];
                            data[srcIdx + 3] = temp[dstIdx + 3];
                        }
                    }
                }
            },
            applyKaleidoscope(data, width, height) {
                const h = height / 2, w = width / 2;
                const temp = new Uint8ClampedArray(data);
                // Copy top-left quadrant to all quadrants
                for (let y = 0; y < h; y++) {
                    for (let x = 0; x < w; x++) {
                        const srcIdx = (y * width + x) * 4;
                        // Top-right (flipped horizontally)
                        const trIdx = (y * width + (width - x - 1)) * 4;
                        data[trIdx] = temp[srcIdx];
                        data[trIdx + 1] = temp[srcIdx + 1];
                        data[trIdx + 2] = temp[srcIdx + 2];
                        data[trIdx + 3] = temp[srcIdx + 3];
                        // Bottom-left (flipped vertically)
                        const blIdx = ((height - y - 1) * width + x) * 4;
                        data[blIdx] = temp[srcIdx];
                        data[blIdx + 1] = temp[srcIdx + 1];
                        data[blIdx + 2] = temp[srcIdx + 2];
                        data[blIdx + 3] = temp[srcIdx + 3];
                        // Bottom-right (flipped both)
                        const brIdx = ((height - y - 1) * width + (width - x - 1)) * 4;
                        data[brIdx] = temp[srcIdx];
                        data[brIdx + 1] = temp[srcIdx + 1];
                        data[brIdx + 2] = temp[srcIdx + 2];
                        data[brIdx + 3] = temp[srcIdx + 3];
                    }
                }
            },
            applyGlitch(data, width, height) {
                for (let y = 0; y < height; y += 20) {
                    const offset = Math.random() * 20 - 10;
                    for (let x = 0; x < width; x++) {
                        const newX = Math.round(x + offset);
                        if (newX >= 0 && newX < width && y + 10 < height) {
                            const srcIdx = ((y + 10) * width + x) * 4;
                            const dstIdx = (y * width + newX) * 4;
                            if (dstIdx < data.length && srcIdx < data.length) {
                                data[dstIdx] = data[srcIdx];
                                data[dstIdx + 1] = data[srcIdx + 1];
                                data[dstIdx + 2] = data[srcIdx + 2];
                            }
                        }
                    }
                }
            },
            applyDoubleVision(data, width, height) {
                const temp = new Uint8ClampedArray(data);
                const offset = 10;
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const idx = (y * width + x) * 4;
                        const shiftedX = x + offset;
                        if (shiftedX < width) {
                            const shiftedIdx = (y * width + shiftedX) * 4;
                            data[idx] = Math.min(255, (temp[idx] + temp[shiftedIdx]) / 2);
                            data[idx + 1] = Math.min(255, (temp[idx + 1] + temp[shiftedIdx + 1]) / 2);
                            data[idx + 2] = Math.min(255, (temp[idx + 2] + temp[shiftedIdx + 2]) / 2);
                        }
                    }
                }
            },
            applyFastZoomIn(data, width, height, frameCount) {
                const centerX = width / 2, centerY = height / 2;
                const fps = 30;
                const animationSpeed = 2.0;
                const zoomFactor = 1.0 + (frameCount / fps * animationSpeed) % 2.0;
                const temp = new Uint8ClampedArray(data);
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const dx = x - centerX, dy = y - centerY;
                        const newX = Math.round(centerX + dx / zoomFactor);
                        const newY = Math.round(centerY + dy / zoomFactor);
                        if (newX >= 0 && newX < width && newY >= 0 && newY < height) {
                            const srcIdx = (y * width + x) * 4;
                            const dstIdx = (newY * width + newX) * 4;
                            data[srcIdx] = temp[dstIdx];
                            data[srcIdx + 1] = temp[dstIdx + 1];
                            data[srcIdx + 2] = temp[dstIdx + 2];
                            data[srcIdx + 3] = temp[dstIdx + 3];
                        }
                    }
                }
            },
            applyFastZoomOut(data, width, height, frameCount) {
                const centerX = width / 2, centerY = height / 2;
                const fps = 30;
                const animationSpeed = 2.0;
                let zoomFactor = 1.5 - (frameCount / fps * animationSpeed) % 1.0;
                zoomFactor = Math.max(0.5, zoomFactor);
                const temp = new Uint8ClampedArray(data);
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const dx = x - centerX, dy = y - centerY;
                        const newX = Math.round(centerX + dx / zoomFactor);
                        const newY = Math.round(centerY + dy / zoomFactor);
                        if (newX >= 0 && newX < width && newY >= 0 && newY < height) {
                            const srcIdx = (y * width + x) * 4;
                            const dstIdx = (newY * width + newX) * 4;
                            data[srcIdx] = temp[dstIdx];
                            data[srcIdx + 1] = temp[dstIdx + 1];
                            data[srcIdx + 2] = temp[dstIdx + 2];
                            data[srcIdx + 3] = temp[dstIdx + 3];
                        }
                    }
                }
            },
            applyShake(data, width, height, frameCount) {
                const fps = 30;
                const animationSpeed = 20.0;
                const shakeAmount = 15;
                const offsetX = Math.sin(frameCount / fps * animationSpeed * 2 * Math.PI) * shakeAmount;
                const offsetY = Math.cos(frameCount / fps * animationSpeed * 2 * Math.PI) * shakeAmount;
                const temp = new Uint8ClampedArray(data);
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const newX = Math.round(x + offsetX);
                        const newY = Math.round(y + offsetY);
                        if (newX >= 0 && newX < width && newY >= 0 && newY < height) {
                            const srcIdx = (y * width + x) * 4;
                            const dstIdx = (newY * width + newX) * 4;
                            data[srcIdx] = temp[dstIdx];
                            data[srcIdx + 1] = temp[dstIdx + 1];
                            data[srcIdx + 2] = temp[dstIdx + 2];
                            data[srcIdx + 3] = temp[dstIdx + 3];
                        }
                    }
                }
            },
            applyPulse(data, width, height, frameCount) {
                const centerX = width / 2, centerY = height / 2;
                const fps = 30;
                const animationSpeed = 3.0;
                const animationCycle = (frameCount / fps * animationSpeed * 2 * Math.PI) % (2 * Math.PI);
                const zoomFactor = 1.0 + 0.15 * Math.sin(animationCycle);
                const temp = new Uint8ClampedArray(data);
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const dx = x - centerX, dy = y - centerY;
                        const newX = Math.round(centerX + dx / zoomFactor);
                        const newY = Math.round(centerY + dy / zoomFactor);
                        if (newX >= 0 && newX < width && newY >= 0 && newY < height) {
                            const srcIdx = (y * width + x) * 4;
                            const dstIdx = (newY * width + newX) * 4;
                            data[srcIdx] = temp[dstIdx];
                            data[srcIdx + 1] = temp[dstIdx + 1];
                            data[srcIdx + 2] = temp[dstIdx + 2];
                            data[srcIdx + 3] = temp[dstIdx + 3];
                        }
                    }
                }
            },
            applySpiralZoom(data, width, height, frameCount) {
                const centerX = width / 2, centerY = height / 2;
                const fps = 30;
                const animationSpeed = 2.0;
                const animationCycle = (frameCount / fps * animationSpeed * 2 * Math.PI) % (2 * Math.PI);
                const maxDist = Math.sqrt(centerX * centerX + centerY * centerY);
                const temp = new Uint8ClampedArray(data);
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const dx = x - centerX, dy = y - centerY;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        const angle = Math.atan2(dy, dx);
                        const zoomFactor = 1.0 + 0.3 * Math.sin(dist / maxDist * 4 * Math.PI + animationCycle);
                        const newAngle = angle + animationCycle * 0.5;
                        const newDist = dist / zoomFactor;
                        const newX = Math.round(centerX + newDist * Math.cos(newAngle));
                        const newY = Math.round(centerY + newDist * Math.sin(newAngle));
                        if (newX >= 0 && newX < width && newY >= 0 && newY < height) {
                            const srcIdx = (y * width + x) * 4;
                            const dstIdx = (newY * width + newX) * 4;
                            data[srcIdx] = temp[dstIdx];
                            data[srcIdx + 1] = temp[dstIdx + 1];
                            data[srcIdx + 2] = temp[dstIdx + 2];
                            data[srcIdx + 3] = temp[dstIdx + 3];
                        }
                    }
                }
            },
            applyExtremeCloseup(data, width, height, frameCount) {
                const centerX = width / 2, centerY = height / 2;
                const fps = 30;
                const animationSpeed = 1.5;
                const animationCycle = (frameCount / fps * animationSpeed * 2 * Math.PI) % (2 * Math.PI);
                let zoomFactor = 1.0 + 2.5 * (0.5 + 0.5 * Math.sin(animationCycle));
                zoomFactor = Math.max(1.0, Math.min(zoomFactor, 4.0));
                const temp = new Uint8ClampedArray(data);
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const dx = x - centerX, dy = y - centerY;
                        const newX = Math.round(centerX + dx / zoomFactor);
                        const newY = Math.round(centerY + dy / zoomFactor);
                        if (newX >= 0 && newX < width && newY >= 0 && newY < height) {
                            const srcIdx = (y * width + x) * 4;
                            const dstIdx = (newY * width + newX) * 4;
                            data[srcIdx] = temp[dstIdx];
                            data[srcIdx + 1] = temp[dstIdx + 1];
                            data[srcIdx + 2] = temp[dstIdx + 2];
                            data[srcIdx + 3] = temp[dstIdx + 3];
                        }
                    }
                }
            },
            applyPuzzle(data, width, height) {
                // Simplified puzzle effect - just shuffle blocks
                const cols = 10, rows = 8;
                const pieceW = width / cols, pieceH = height / rows;
                const temp = new Uint8ClampedArray(data);
                const pieces = [];
                for (let row = 0; row < rows; row++) {
                    for (let col = 0; col < cols; col++) {
                        pieces.push({row, col, targetRow: (row + 2) % rows, targetCol: (col + 3) % cols});
                    }
                }
                for (const piece of pieces) {
                    for (let y = 0; y < pieceH && piece.row * pieceH + y < height; y++) {
                        for (let x = 0; x < pieceW && piece.col * pieceW + x < width; x++) {
                            const srcY = piece.row * pieceH + y;
                            const srcX = piece.col * pieceW + x;
                            const dstY = piece.targetRow * pieceH + y;
                            const dstX = piece.targetCol * pieceW + x;
                            if (dstY < height && dstX < width) {
                                const srcIdx = (srcY * width + srcX) * 4;
                                const dstIdx = (dstY * width + dstX) * 4;
                                data[dstIdx] = temp[srcIdx];
                                data[dstIdx + 1] = temp[srcIdx + 1];
                                data[dstIdx + 2] = temp[srcIdx + 2];
                                data[dstIdx + 3] = temp[srcIdx + 3];
                            }
                        }
                    }
                }
            },
            applyMultiRipple(data, width, height) {
                const centerX = width / 2, centerY = height / 2;
                const temp = new Uint8ClampedArray(data);
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const dx = x - centerX, dy = y - centerY;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        // Multiple overlapping ripples for complex distortion
                        const ripple1 = Math.sin(dist * 0.05) * 15;
                        const ripple2 = Math.sin(dist * 0.08) * 10;
                        const ripple3 = Math.sin(dist * 0.12) * 8;
                        const totalRipple = ripple1 + ripple2 + ripple3;
                        const angle = Math.atan2(dy, dx);
                        const newX = Math.round(x + totalRipple * Math.cos(angle));
                        const newY = Math.round(y + totalRipple * Math.sin(angle));
                        if (newX >= 0 && newX < width && newY >= 0 && newY < height) {
                            const srcIdx = (y * width + x) * 4;
                            const dstIdx = (newY * width + newX) * 4;
                            data[srcIdx] = temp[dstIdx];
                            data[srcIdx + 1] = temp[dstIdx + 1];
                            data[srcIdx + 2] = temp[dstIdx + 2];
                            data[srcIdx + 3] = temp[dstIdx + 3];
                        }
                    }
                }
            },
            applyRadialSqueeze(data, width, height) {
                const centerX = width / 2, centerY = height / 2;
                const radius = Math.min(width, height) / 2, strength = 0.5;
                const temp = new Uint8ClampedArray(data);
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const dx = x - centerX, dy = y - centerY;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        const normalizedDist = Math.min(dist / radius, 1);
                        // Opposite of pincushion - pushes outward
                        const newDist = normalizedDist * (1 + strength * normalizedDist * normalizedDist) * radius;
                        const angle = Math.atan2(dy, dx);
                        const newX = Math.round(centerX + newDist * Math.cos(angle));
                        const newY = Math.round(centerY + newDist * Math.sin(angle));
                        if (newX >= 0 && newX < width && newY >= 0 && newY < height) {
                            const srcIdx = (y * width + x) * 4;
                            const dstIdx = (newY * width + newX) * 4;
                            data[srcIdx] = temp[dstIdx];
                            data[srcIdx + 1] = temp[dstIdx + 1];
                            data[srcIdx + 2] = temp[dstIdx + 2];
                            data[srcIdx + 3] = temp[dstIdx + 3];
                        }
                    }
                }
            },
            applyElasticStretch(data, width, height) {
                const centerX = width / 2, centerY = height / 2;
                const radius = Math.min(width, height) / 2, strength = 0.6;
                const temp = new Uint8ClampedArray(data);
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const dx = x - centerX, dy = y - centerY;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        const normalizedDist = Math.min(dist / radius, 1);
                        // Elastic rubber-like stretching
                        const elasticFactor = 1.0 + strength * Math.sin(normalizedDist * Math.PI);
                        const newDist = normalizedDist * elasticFactor * radius;
                        const angle = Math.atan2(dy, dx);
                        const newX = Math.round(centerX + newDist * Math.cos(angle));
                        const newY = Math.round(centerY + newDist * Math.sin(angle));
                        if (newX >= 0 && newX < width && newY >= 0 && newY < height) {
                            const srcIdx = (y * width + x) * 4;
                            const dstIdx = (newY * width + newX) * 4;
                            data[srcIdx] = temp[dstIdx];
                            data[srcIdx + 1] = temp[dstIdx + 1];
                            data[srcIdx + 2] = temp[dstIdx + 2];
                            data[srcIdx + 3] = temp[dstIdx + 3];
                        }
                    }
                }
            },
            applyLensDistortion(data, width, height) {
                const centerX = width / 2, centerY = height / 2;
                const radius = Math.min(width, height) / 2;
                const k1 = 0.3, k2 = 0.1; // Lens distortion coefficients
                const temp = new Uint8ClampedArray(data);
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const dx = (x - centerX) / radius;
                        const dy = (y - centerY) / radius;
                        const r2 = dx * dx + dy * dy;
                        const r4 = r2 * r2;
                        // Barrel/pincushion distortion model
                        const distortion = 1.0 + k1 * r2 + k2 * r4;
                        const newX = Math.round(centerX + dx * radius * distortion);
                        const newY = Math.round(centerY + dy * radius * distortion);
                        if (newX >= 0 && newX < width && newY >= 0 && newY < height) {
                            const srcIdx = (y * width + x) * 4;
                            const dstIdx = (newY * width + newX) * 4;
                            data[srcIdx] = temp[dstIdx];
                            data[srcIdx + 1] = temp[dstIdx + 1];
                            data[srcIdx + 2] = temp[dstIdx + 2];
                            data[srcIdx + 3] = temp[dstIdx + 3];
                        }
                    }
                }
            },
            applyWaveDistortion(data, width, height) {
                const centerX = width / 2, centerY = height / 2;
                const temp = new Uint8ClampedArray(data);
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const dx = x - centerX, dy = y - centerY;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        const angle = Math.atan2(dy, dx);
                        // Complex wave pattern with multiple frequencies
                        const waveX = Math.sin(dist * 0.08 + angle * 2) * 20;
                        const waveY = Math.cos(dist * 0.06 - angle * 2) * 20;
                        const newX = Math.round(x + waveX);
                        const newY = Math.round(y + waveY);
                        if (newX >= 0 && newX < width && newY >= 0 && newY < height) {
                            const srcIdx = (y * width + x) * 4;
                            const dstIdx = (newY * width + newX) * 4;
                            data[srcIdx] = temp[dstIdx];
                            data[srcIdx + 1] = temp[dstIdx + 1];
                            data[srcIdx + 2] = temp[dstIdx + 2];
                            data[srcIdx + 3] = temp[dstIdx + 3];
                        }
                    }
                }
            },
            applySqueezeHorizontal(data, width, height) {
                const centerX = width / 2;
                const strength = 0.4;
                const temp = new Uint8ClampedArray(data);
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const dx = (x - centerX) / (width / 2);
                        // Horizontal compression - squeezes from center
                        const squeezeFactor = 1.0 - strength * dx * dx;
                        const newX = Math.round(centerX + (x - centerX) * squeezeFactor);
                        if (newX >= 0 && newX < width) {
                            const srcIdx = (y * width + x) * 4;
                            const dstIdx = (y * width + newX) * 4;
                            data[srcIdx] = temp[dstIdx];
                            data[srcIdx + 1] = temp[dstIdx + 1];
                            data[srcIdx + 2] = temp[dstIdx + 2];
                            data[srcIdx + 3] = temp[dstIdx + 3];
                        }
                    }
                }
            },
            applySqueezeVertical(data, width, height) {
                const centerY = height / 2;
                const strength = 0.4;
                const temp = new Uint8ClampedArray(data);
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const dy = (y - centerY) / (height / 2);
                        // Vertical compression - squeezes from center
                        const squeezeFactor = 1.0 - strength * dy * dy;
                        const newY = Math.round(centerY + (y - centerY) * squeezeFactor);
                        if (newY >= 0 && newY < height) {
                            const srcIdx = (y * width + x) * 4;
                            const dstIdx = (newY * width + x) * 4;
                            data[srcIdx] = temp[dstIdx];
                            data[srcIdx + 1] = temp[dstIdx + 1];
                            data[srcIdx + 2] = temp[dstIdx + 2];
                            data[srcIdx + 3] = temp[dstIdx + 3];
                        }
                    }
                }
            },
            applyRadialWobble(data, width, height) {
                const centerX = width / 2, centerY = height / 2;
                const radius = Math.min(width, height) / 2;
                const temp = new Uint8ClampedArray(data);
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const dx = x - centerX, dy = y - centerY;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        const angle = Math.atan2(dy, dx);
                        const normalizedDist = Math.min(dist / radius, 1);
                        // Wobbling radial distortion
                        const wobble = Math.sin(angle * 6) * 15 * normalizedDist;
                        const newDist = dist + wobble;
                        const newX = Math.round(centerX + newDist * Math.cos(angle));
                        const newY = Math.round(centerY + newDist * Math.sin(angle));
                        if (newX >= 0 && newX < width && newY >= 0 && newY < height) {
                            const srcIdx = (y * width + x) * 4;
                            const dstIdx = (newY * width + newX) * 4;
                            data[srcIdx] = temp[dstIdx];
                            data[srcIdx + 1] = temp[dstIdx + 1];
                            data[srcIdx + 2] = temp[dstIdx + 2];
                            data[srcIdx + 3] = temp[dstIdx + 3];
                        }
                    }
                }
            },
            applyComplexRipple(data, width, height) {
                const centerX = width / 2, centerY = height / 2;
                const temp = new Uint8ClampedArray(data);
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const dx = x - centerX, dy = y - centerY;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        const angle = Math.atan2(dy, dx);
                        // Complex ripple with angular variation
                        const radialRipple = Math.sin(dist * 0.06) * 18;
                        const angularRipple = Math.sin(angle * 4) * 8;
                        const totalRipple = radialRipple + angularRipple;
                        const newX = Math.round(x + totalRipple * Math.cos(angle));
                        const newY = Math.round(y + totalRipple * Math.sin(angle));
                        if (newX >= 0 && newX < width && newY >= 0 && newY < height) {
                            const srcIdx = (y * width + x) * 4;
                            const dstIdx = (newY * width + newX) * 4;
                            data[srcIdx] = temp[dstIdx];
                            data[srcIdx + 1] = temp[dstIdx + 1];
                            data[srcIdx + 2] = temp[dstIdx + 2];
                            data[srcIdx + 3] = temp[dstIdx + 3];
                        }
                    }
                }
            },
            applySquishFace(data, width, height) {
                const centerX = width / 2, centerY = height / 2;
                const strength = 0.3;
                const temp = new Uint8ClampedArray(data);
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const dy = (y - centerY) / (height / 2);
                        // Horizontal compression - makes face wider and funnier
                        const squishFactor = 1.0 - strength * dy * dy;
                        const newX = Math.round(centerX + (x - centerX) / squishFactor);
                        if (newX >= 0 && newX < width) {
                            const srcIdx = (y * width + x) * 4;
                            const dstIdx = (y * width + newX) * 4;
                            data[srcIdx] = temp[dstIdx];
                            data[srcIdx + 1] = temp[dstIdx + 1];
                            data[srcIdx + 2] = temp[dstIdx + 2];
                            data[srcIdx + 3] = temp[dstIdx + 3];
                        }
                    }
                }
            },
            applyStretchFace(data, width, height) {
                const centerX = width / 2, centerY = height / 2;
                const strength = 0.4;
                const temp = new Uint8ClampedArray(data);
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const dx = (x - centerX) / (width / 2);
                        // Vertical stretch - makes face taller and funnier
                        const stretchFactor = 1.0 + strength * dx * dx;
                        const newY = Math.round(centerY + (y - centerY) / stretchFactor);
                        if (newY >= 0 && newY < height) {
                            const srcIdx = (y * width + x) * 4;
                            const dstIdx = (newY * width + x) * 4;
                            data[srcIdx] = temp[dstIdx];
                            data[srcIdx + 1] = temp[dstIdx + 1];
                            data[srcIdx + 2] = temp[dstIdx + 2];
                            data[srcIdx + 3] = temp[dstIdx + 3];
                        }
                    }
                }
            },
            applyFunhouseMirror(data, width, height) {
                const centerX = width / 2, centerY = height / 2;
                const strength = 0.25;
                const temp = new Uint8ClampedArray(data);
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const dx = (x - centerX) / (width / 2);
                        const dy = (y - centerY) / (height / 2);
                        // Asymmetric distortion - creates funny mirror effect
                        const distortX = strength * Math.sin(dy * Math.PI) * dx;
                        const distortY = strength * Math.cos(dx * Math.PI) * dy;
                        const newX = Math.round(centerX + (x - centerX) * (1 + distortX));
                        const newY = Math.round(centerY + (y - centerY) * (1 + distortY));
                        if (newX >= 0 && newX < width && newY >= 0 && newY < height) {
                            const srcIdx = (y * width + x) * 4;
                            const dstIdx = (newY * width + newX) * 4;
                            data[srcIdx] = temp[dstIdx];
                            data[srcIdx + 1] = temp[dstIdx + 1];
                            data[srcIdx + 2] = temp[dstIdx + 2];
                            data[srcIdx + 3] = temp[dstIdx + 3];
                        }
                    }
                }
            },
            applyPinchCheeks(data, width, height) {
                const centerX = width / 2, centerY = height / 2;
                const radius = Math.min(width, height) / 2;
                const strength = 0.35;
                const temp = new Uint8ClampedArray(data);
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const dx = x - centerX, dy = y - centerY;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        const normalizedDist = Math.min(dist / radius, 1);
                        const angle = Math.atan2(dy, dx);
                        // Pinch sides inward - creates funny cheek effect
                        const pinchFactor = 1.0 - strength * Math.abs(Math.cos(angle)) * normalizedDist;
                        const newDist = dist * pinchFactor;
                        const newX = Math.round(centerX + newDist * Math.cos(angle));
                        const newY = Math.round(centerY + newDist * Math.sin(angle));
                        if (newX >= 0 && newX < width && newY >= 0 && newY < height) {
                            const srcIdx = (y * width + x) * 4;
                            const dstIdx = (newY * width + newX) * 4;
                            data[srcIdx] = temp[dstIdx];
                            data[srcIdx + 1] = temp[dstIdx + 1];
                            data[srcIdx + 2] = temp[dstIdx + 2];
                            data[srcIdx + 3] = temp[dstIdx + 3];
                        }
                    }
                }
            },
            applyBulgeEyes(data, width, height) {
                const centerX = width / 2, centerY = height / 2;
                const radius = Math.min(width, height) / 2;
                const strength = 0.4;
                const temp = new Uint8ClampedArray(data);
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const dx = x - centerX, dy = y - centerY;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        const normalizedDist = Math.min(dist / radius, 1);
                        const angle = Math.atan2(dy, dx);
                        // Bulge center area outward - creates funny eye bulge
                        const bulgeFactor = 1.0 + strength * (1.0 - normalizedDist) * Math.cos(angle * 2);
                        const newDist = dist * bulgeFactor;
                        const newX = Math.round(centerX + newDist * Math.cos(angle));
                        const newY = Math.round(centerY + newDist * Math.sin(angle));
                        if (newX >= 0 && newX < width && newY >= 0 && newY < height) {
                            const srcIdx = (y * width + x) * 4;
                            const dstIdx = (newY * width + newX) * 4;
                            data[srcIdx] = temp[dstIdx];
                            data[srcIdx + 1] = temp[dstIdx + 1];
                            data[srcIdx + 2] = temp[dstIdx + 2];
                            data[srcIdx + 3] = temp[dstIdx + 3];
                        }
                    }
                }
            },
            applyWarpFace(data, width, height) {
                const centerX = width / 2, centerY = height / 2;
                const strength = 0.2;
                const temp = new Uint8ClampedArray(data);
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const dx = (x - centerX) / (width / 2);
                        const dy = (y - centerY) / (height / 2);
                        // Subtle warping that creates funny expressions
                        const warpX = strength * Math.sin(dy * Math.PI * 2) * 15;
                        const warpY = strength * Math.cos(dx * Math.PI * 2) * 15;
                        const newX = Math.round(x + warpX);
                        const newY = Math.round(y + warpY);
                        if (newX >= 0 && newX < width && newY >= 0 && newY < height) {
                            const srcIdx = (y * width + x) * 4;
                            const dstIdx = (newY * width + newX) * 4;
                            data[srcIdx] = temp[dstIdx];
                            data[srcIdx + 1] = temp[dstIdx + 1];
                            data[srcIdx + 2] = temp[dstIdx + 2];
                            data[srcIdx + 3] = temp[dstIdx + 3];
                        }
                    }
                }
            },
            applyFunnySquash(data, width, height) {
                const centerY = height / 2;
                const strength = 0.35;
                const temp = new Uint8ClampedArray(data);
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const dy = (y - centerY) / (height / 2);
                        // Vertical squash - compresses face vertically
                        const squashFactor = 1.0 + strength * dy * dy;
                        const newY = Math.round(centerY + (y - centerY) / squashFactor);
                        if (newY >= 0 && newY < height) {
                            const srcIdx = (y * width + x) * 4;
                            const dstIdx = (newY * width + x) * 4;
                            data[srcIdx] = temp[dstIdx];
                            data[srcIdx + 1] = temp[dstIdx + 1];
                            data[srcIdx + 2] = temp[dstIdx + 2];
                            data[srcIdx + 3] = temp[dstIdx + 3];
                        }
                    }
                }
            },
            applyFunnyStretch(data, width, height) {
                const centerX = width / 2;
                const strength = 0.35;
                const temp = new Uint8ClampedArray(data);
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const dx = (x - centerX) / (width / 2);
                        // Horizontal stretch - makes face wider
                        const stretchFactor = 1.0 + strength * dx * dx;
                        const newX = Math.round(centerX + (x - centerX) / stretchFactor);
                        if (newX >= 0 && newX < width) {
                            const srcIdx = (y * width + x) * 4;
                            const dstIdx = (y * width + newX) * 4;
                            data[srcIdx] = temp[dstIdx];
                            data[srcIdx + 1] = temp[dstIdx + 1];
                            data[srcIdx + 2] = temp[dstIdx + 2];
                            data[srcIdx + 3] = temp[dstIdx + 3];
                        }
                    }
                }
            },
            applyWobbleFace(data, width, height) {
                const centerX = width / 2, centerY = height / 2;
                const radius = Math.min(width, height) / 2;
                const strength = 12;
                const temp = new Uint8ClampedArray(data);
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const dx = x - centerX, dy = y - centerY;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        const angle = Math.atan2(dy, dx);
                        const normalizedDist = Math.min(dist / radius, 1);
                        // Gentle wobbling distortion
                        const wobble = strength * Math.sin(angle * 6) * normalizedDist;
                        const newDist = dist + wobble;
                        const newX = Math.round(centerX + newDist * Math.cos(angle));
                        const newY = Math.round(centerY + newDist * Math.sin(angle));
                        if (newX >= 0 && newX < width && newY >= 0 && newY < height) {
                            const srcIdx = (y * width + x) * 4;
                            const dstIdx = (newY * width + newX) * 4;
                            data[srcIdx] = temp[dstIdx];
                            data[srcIdx + 1] = temp[dstIdx + 1];
                            data[srcIdx + 2] = temp[dstIdx + 2];
                            data[srcIdx + 3] = temp[dstIdx + 3];
                        }
                    }
                }
            },
            applyElasticFace(data, width, height) {
                const centerX = width / 2, centerY = height / 2;
                const radius = Math.min(width, height) / 2;
                const strength = 0.5;
                const temp = new Uint8ClampedArray(data);
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const dx = x - centerX, dy = y - centerY;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        const normalizedDist = Math.min(dist / radius, 1);
                        const angle = Math.atan2(dy, dx);
                        // Bouncy elastic-like distortion
                        const elasticFactor = 1.0 + strength * Math.sin(normalizedDist * Math.PI * 2) * 0.3;
                        const newDist = normalizedDist * elasticFactor * radius;
                        const newX = Math.round(centerX + newDist * Math.cos(angle));
                        const newY = Math.round(centerY + newDist * Math.sin(angle));
                        if (newX >= 0 && newX < width && newY >= 0 && newY < height) {
                            const srcIdx = (y * width + x) * 4;
                            const dstIdx = (newY * width + newX) * 4;
                            data[srcIdx] = temp[dstIdx];
                            data[srcIdx + 1] = temp[dstIdx + 1];
                            data[srcIdx + 2] = temp[dstIdx + 2];
                            data[srcIdx + 3] = temp[dstIdx + 3];
                        }
                    }
                }
            },
            applyGentleRipple(data, width, height) {
                const centerX = width / 2, centerY = height / 2;
                const frequency = 0.04, amplitude = 12;
                const temp = new Uint8ClampedArray(data);
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const dx = x - centerX, dy = y - centerY;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        // Gentler ripple for subtle funny effect
                        const ripple = Math.sin(dist * frequency) * amplitude;
                        const angle = Math.atan2(dy, dx);
                        const newX = Math.round(x + ripple * Math.cos(angle));
                        const newY = Math.round(y + ripple * Math.sin(angle));
                        if (newX >= 0 && newX < width && newY >= 0 && newY < height) {
                            const srcIdx = (y * width + x) * 4;
                            const dstIdx = (newY * width + newX) * 4;
                            data[srcIdx] = temp[dstIdx];
                            data[srcIdx + 1] = temp[dstIdx + 1];
                            data[srcIdx + 2] = temp[dstIdx + 2];
                            data[srcIdx + 3] = temp[dstIdx + 3];
                        }
                    }
                }
            },
            applySmushFace(data, width, height) {
                const centerX = width / 2, centerY = height / 2;
                const radius = Math.min(width, height) / 2;
                const strength = 0.3;
                const temp = new Uint8ClampedArray(data);
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const dx = x - centerX, dy = y - centerY;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        const normalizedDist = Math.min(dist / radius, 1);
                        const angle = Math.atan2(dy, dx);
                        // Smushes face from all sides
                        const smushFactor = 1.0 - strength * normalizedDist * normalizedDist;
                        const newDist = normalizedDist * smushFactor * radius;
                        const newX = Math.round(centerX + newDist * Math.cos(angle));
                        const newY = Math.round(centerY + newDist * Math.sin(angle));
                        if (newX >= 0 && newX < width && newY >= 0 && newY < height) {
                            const srcIdx = (y * width + x) * 4;
                            const dstIdx = (newY * width + newX) * 4;
                            data[srcIdx] = temp[dstIdx];
                            data[srcIdx + 1] = temp[dstIdx + 1];
                            data[srcIdx + 2] = temp[dstIdx + 2];
                            data[srcIdx + 3] = temp[dstIdx + 3];
                        }
                    }
                }
            },
            applyUltimateDistortion(data, width, height) {
                const centerX = width / 2, centerY = height / 2;
                const temp = new Uint8ClampedArray(data);

                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const dx = (x - centerX) / (width / 2);
                        const dy = (y - centerY) / (height / 2);

                        // Funhouse mirror horizontal stretching
                        const horizontalStretch = 0.3 * Math.sin(dy * Math.PI * 2) * dx;

                        // Multiple ripple effects at different frequencies
                        const ripple1 = Math.sin(Math.sqrt(dx * dx + dy * dy) * 8) * 0.02;
                        const ripple2 = Math.sin(Math.sqrt(dx * dx + dy * dy) * 15) * 0.01;

                        // Wobbling distortion
                        const wobble = 0.1 * Math.sin(dx * Math.PI * 3) * Math.cos(dy * Math.PI * 2);

                        // Combine all distortions
                        const distortX = horizontalStretch + ripple1 + ripple2 + wobble;
                        const distortY = ripple1 * 1.5 + ripple2 * 0.8;

                        const newX = Math.round(centerX + (x - centerX) * (1 + distortX));
                        const newY = Math.round(centerY + (y - centerY) * (1 + distortY));

                        if (newX >= 0 && newX < width && newY >= 0 && newY < height) {
                            const srcIdx = (y * width + x) * 4;
                            const dstIdx = (newY * width + newX) * 4;
                            data[srcIdx] = temp[dstIdx];
                            data[srcIdx + 1] = temp[dstIdx + 1];
                            data[srcIdx + 2] = temp[dstIdx + 2];
                            data[srcIdx + 3] = temp[dstIdx + 3];
                        }
                    }
                }
            }
        };
        
        // Calculate distortion vector for a point (x, y) with given filter
        function calculateDistortionVector(x, y, width, height, filterType) {
            const centerX = width / 2;
            const centerY = height / 2;
            const dx = x - centerX;
            const dy = y - centerY;
            const dist = Math.sqrt(dx * dx + dy * dy);
            const angle = Math.atan2(dy, dx);
            const radius = Math.min(width, height) / 2;
            const normalizedDist = Math.min(dist / radius, 1);
            
            let newX = x, newY = y;
            
            // Calculate distortion based on filter type
            switch(filterType) {
                case 'water_ripple':
                case 'ripple':
                    const frequency = filterType === 'water_ripple' ? 0.05 : 0.1;
                    const amplitude = filterType === 'water_ripple' ? 15 : 20;
                    const ripple = Math.sin(dist * frequency) * amplitude;
                    newX = x + ripple * Math.cos(angle);
                    newY = y + ripple * Math.sin(angle);
                    break;
                case 'pincushion':
                    const strength = 0.4;
                    const newDist = normalizedDist * (1 - strength * normalizedDist) * radius;
                    newX = centerX + newDist * Math.cos(angle);
                    newY = centerY + newDist * Math.sin(angle);
                    break;
                case 'bulge':
                    const bulgeStrength = 0.5;
                    const bulgeRadius = radius;
                    const distSq = dist * dist;
                    const maxDistSq = bulgeRadius * bulgeRadius;
                    if (distSq < maxDistSq) {
                        const factor = 1.0 - (dist / bulgeRadius) * bulgeStrength;
                        newX = centerX + dx * factor;
                        newY = centerY + dy * factor;
                    }
                    break;
                case 'swirl':
                    const swirlStrength = 2.0;
                    if (dist < radius) {
                        const maxAngle = swirlStrength * (1.0 - normalizedDist);
                        const newAngle = angle + maxAngle;
                        newX = centerX + dist * Math.cos(newAngle);
                        newY = centerY + dist * Math.sin(newAngle);
                    }
                    break;
                case 'fisheye':
                    const fisheyeStrength = 0.5;
                    const fisheyeFactor = 1.0 - fisheyeStrength * normalizedDist;
                    newX = centerX + dx * fisheyeFactor;
                    newY = centerY + dy * fisheyeFactor;
                    break;
                case 'barrel':
                    const barrelStrength = 0.3;
                    const barrelNewDist = normalizedDist * (1 + barrelStrength * normalizedDist * normalizedDist) * radius;
                    newX = centerX + barrelNewDist * Math.cos(angle);
                    newY = centerY + barrelNewDist * Math.sin(angle);
                    break;
                case 'radial_squeeze':
                    const squeezeStrength = 0.5;
                    const squeezeNewDist = normalizedDist * (1 + squeezeStrength * normalizedDist * normalizedDist) * radius;
                    newX = centerX + squeezeNewDist * Math.cos(angle);
                    newY = centerY + squeezeNewDist * Math.sin(angle);
                    break;
                case 'squish_face':
                    const squishStrength = 0.3;
                    const squishDy = dy / (height / 2);
                    const squishFactor = 1.0 - squishStrength * squishDy * squishDy;
                    newX = centerX + dx / squishFactor;
                    newY = y;
                    break;
                case 'stretch_face':
                    const stretchFaceStrength = 0.4;
                    const stretchFaceDx = dx / (width / 2);
                    const stretchFaceFactor = 1.0 + stretchFaceStrength * stretchFaceDx * stretchFaceDx;
                    newX = x;
                    newY = centerY + dy / stretchFaceFactor;
                    break;
                case 'pinch_cheeks':
                    const pinchCheeksStrength = 0.35;
                    const pinchCheeksFactor = 1.0 - pinchCheeksStrength * Math.abs(Math.cos(angle)) * normalizedDist;
                    const pinchCheeksNewDist = dist * pinchCheeksFactor;
                    newX = centerX + pinchCheeksNewDist * Math.cos(angle);
                    newY = centerY + pinchCheeksNewDist * Math.sin(angle);
                    break;
                case 'wobble_face':
                case 'radial_wobble':
                    const wobbleStrength = 12;
                    const wobble = wobbleStrength * Math.sin(angle * 6) * normalizedDist;
                    const wobbleNewDist = dist + wobble;
                    newX = centerX + wobbleNewDist * Math.cos(angle);
                    newY = centerY + wobbleNewDist * Math.sin(angle);
                    break;
                case 'multi_ripple':
                    const ripple1 = Math.sin(dist * 0.05) * 15;
                    const ripple2 = Math.sin(dist * 0.08) * 10;
                    const ripple3 = Math.sin(dist * 0.12) * 8;
                    const totalRipple = ripple1 + ripple2 + ripple3;
                    newX = x + totalRipple * Math.cos(angle);
                    newY = y + totalRipple * Math.sin(angle);
                    break;
                case 'elastic_stretch':
                    const elasticStrength = 0.5;
                    const elasticFactor = 1.0 + elasticStrength * Math.sin(normalizedDist * Math.PI * 2) * 0.3;
                    const elasticNewDist = normalizedDist * elasticFactor * radius;
                    newX = centerX + elasticNewDist * Math.cos(angle);
                    newY = centerY + elasticNewDist * Math.sin(angle);
                    break;
                case 'wave_distortion':
                    const waveX = Math.sin(dist * 0.08 + angle * 2) * 20;
                    const waveY = Math.cos(dist * 0.06 - angle * 2) * 20;
                    newX = x + waveX;
                    newY = y + waveY;
                    break;
                case 'squeeze_horizontal':
                    const squeezeHDx = dx / (width / 2);
                    const squeezeHFactor = 1.0 - 0.4 * squeezeHDx * squeezeHDx;
                    newX = centerX + dx * squeezeHFactor;
                    newY = y;
                    break;
                case 'squeeze_vertical':
                    const squeezeVDy = dy / (height / 2);
                    const squeezeVFactor = 1.0 - 0.4 * squeezeVDy * squeezeVDy;
                    newX = x;
                    newY = centerY + dy * squeezeVFactor;
                    break;
                case 'complex_ripple':
                    const radialRipple = Math.sin(dist * 0.06) * 18;
                    const angularRipple = Math.sin(angle * 4) * 8;
                    const complexTotalRipple = radialRipple + angularRipple;
                    newX = x + complexTotalRipple * Math.cos(angle);
                    newY = y + complexTotalRipple * Math.sin(angle);
                    break;
                case 'gentle_ripple':
                    const gentleFrequency = 0.04;
                    const gentleAmplitude = 12;
                    const gentleRipple = Math.sin(dist * gentleFrequency) * gentleAmplitude;
                    newX = x + gentleRipple * Math.cos(angle);
                    newY = y + gentleRipple * Math.sin(angle);
                    break;
                case 'ultimate_distortion':
                    // Normalize coordinates to -1 to 1 range
                    const normDx = dx / (width / 2);
                    const normDy = dy / (height / 2);
                    
                    // Funhouse mirror horizontal stretching
                    const horizontalStretch = 0.3 * Math.sin(normDy * Math.PI * 2) * normDx;
                    
                    // Multiple ripple effects at different frequencies
                    const normDist = Math.sqrt(normDx * normDx + normDy * normDy);
                    const ultRipple1 = Math.sin(normDist * 8) * 0.02;
                    const ultRipple2 = Math.sin(normDist * 15) * 0.01;
                    
                    // Wobbling distortion
                    const ultWobble = 0.1 * Math.sin(normDx * Math.PI * 3) * Math.cos(normDy * Math.PI * 2);
                    
                    // Combine all distortions
                    const distortX = horizontalStretch + ultRipple1 + ultRipple2 + ultWobble;
                    const distortY = ultRipple1 * 1.5 + ultRipple2 * 0.8;
                    
                    // Apply distortion to pixel coordinates
                    newX = centerX + dx * (1 + distortX);
                    newY = centerY + dy * (1 + distortY);
                    break;
                case 'stretch':
                    const stretchHDx = dx / (width / 2);
                    const stretchHFactor = 1.0 + 0.5 * stretchHDx * stretchHDx;
                    newX = centerX + dx * stretchHFactor;
                    newY = centerY + dy / stretchHFactor;
                    break;
                case 'pinch':
                    const pinchBaseStrength = 0.4;
                    const pinchBaseFactor = 1.0 - pinchBaseStrength * normalizedDist;
                    newX = centerX + dx * pinchBaseFactor;
                    newY = centerY + dy * pinchBaseFactor;
                    break;
                case 'wave':
                    const waveStrength = 20;
                    const waveOffset = Math.sin(y * 0.1) * waveStrength;
                    newX = x + waveOffset;
                    newY = y;
                    break;
                case 'mirror':
                    // Mirror left half to right
                    if (x < centerX) {
                        newX = x;
                    } else {
                        newX = width - x;
                    }
                    newY = y;
                    break;
                case 'twirl':
                    const twirlStrength = 1.5;
                    if (dist < radius) {
                        const twirlAngle = angle + twirlStrength * (1.0 - normalizedDist);
                        newX = centerX + dist * Math.cos(twirlAngle);
                        newY = centerY + dist * Math.sin(twirlAngle);
                    }
                    break;
                case 'sphere':
                    const sphereStrength = 0.3;
                    const sphereFactor = 1.0 - sphereStrength * normalizedDist * normalizedDist;
                    newX = centerX + dx * sphereFactor;
                    newY = centerY + dy * sphereFactor;
                    break;
                case 'tunnel':
                    const tunnelStrength = 0.4;
                    const tunnelFactor = 1.0 + tunnelStrength * normalizedDist;
                    newX = centerX + dx / tunnelFactor;
                    newY = centerY + dy / tunnelFactor;
                    break;
                case 'cylinder':
                    const cylinderStrength = 0.3;
                    const cylinderFactor = 1.0 - cylinderStrength * Math.abs(Math.cos(angle)) * normalizedDist;
                    newX = centerX + dx * cylinderFactor;
                    newY = y;
                    break;
                case 'whirlpool':
                    const whirlpoolStrength = 2.5;
                    if (dist < radius) {
                        const whirlpoolAngle = angle + whirlpoolStrength * normalizedDist;
                        newX = centerX + dist * Math.cos(whirlpoolAngle);
                        newY = centerY + dist * Math.sin(whirlpoolAngle);
                    }
                    break;
                case 'radial_zoom':
                    const zoomStrength = 0.3;
                    const zoomFactor = 1.0 - zoomStrength * normalizedDist;
                    newX = centerX + dx * zoomFactor;
                    newY = centerY + dy * zoomFactor;
                    break;
                case 'concave':
                    const concaveStrength = 0.4;
                    const concaveFactor = 1.0 + concaveStrength * normalizedDist * normalizedDist;
                    newX = centerX + dx * concaveFactor;
                    newY = centerY + dy * concaveFactor;
                    break;
                case 'convex':
                    const convexStrength = 0.4;
                    const convexFactor = 1.0 - convexStrength * normalizedDist * normalizedDist;
                    newX = centerX + dx * convexFactor;
                    newY = centerY + dy * convexFactor;
                    break;
                case 'spiral':
                    const spiralStrength = 2.0;
                    if (dist < radius) {
                        const spiralAngle = angle + spiralStrength * normalizedDist;
                        newX = centerX + dist * Math.cos(spiralAngle);
                        newY = centerY + dist * Math.sin(spiralAngle);
                    }
                    break;
                case 'radial_stretch':
                    const radialStretchStrength = 0.5;
                    const radialStretchFactor = 1.0 + radialStretchStrength * normalizedDist;
                    newX = centerX + dx * radialStretchFactor;
                    newY = centerY + dy * radialStretchFactor;
                    break;
                case 'radial_compress':
                    const radialCompressStrength = 0.5;
                    const radialCompressFactor = 1.0 - radialCompressStrength * normalizedDist;
                    newX = centerX + dx * radialCompressFactor;
                    newY = centerY + dy * radialCompressFactor;
                    break;
                case 'vertical_wave':
                    const vWaveStrength = 20;
                    const vWaveOffset = Math.sin(x * 0.1) * vWaveStrength;
                    newX = x;
                    newY = y + vWaveOffset;
                    break;
                case 'horizontal_wave':
                    const hWaveStrength = 20;
                    const hWaveOffset = Math.sin(y * 0.1) * hWaveStrength;
                    newX = x + hWaveOffset;
                    newY = y;
                    break;
                case 'skew_horizontal':
                    const skewHStrength = 0.3;
                    const skewHOffset = (y - centerY) * skewHStrength;
                    newX = x + skewHOffset;
                    newY = y;
                    break;
                case 'skew_vertical':
                    const skewVStrength = 0.3;
                    const skewVOffset = (x - centerX) * skewVStrength;
                    newX = x;
                    newY = y + skewVOffset;
                    break;
                case 'rotate_zoom':
                    const rotateZoomStrength = 0.2;
                    const rotateZoomAngle = angle + rotateZoomStrength * normalizedDist;
                    const rotateZoomFactor = 1.0 - 0.2 * normalizedDist;
                    newX = centerX + dist * rotateZoomFactor * Math.cos(rotateZoomAngle);
                    newY = centerY + dist * rotateZoomFactor * Math.sin(rotateZoomAngle);
                    break;
                case 'radial_wave':
                    const radialWaveStrength = 15;
                    const radialWave = Math.sin(dist * 0.08) * radialWaveStrength;
                    newX = x + radialWave * Math.cos(angle);
                    newY = y + radialWave * Math.sin(angle);
                    break;
                case 'zoom_in':
                    const zoomInStrength = 0.4;
                    const zoomInFactor = 1.0 - zoomInStrength * normalizedDist;
                    newX = centerX + dx * zoomInFactor;
                    newY = centerY + dy * zoomInFactor;
                    break;
                case 'zoom_out':
                    const zoomOutStrength = 0.4;
                    const zoomOutFactor = 1.0 + zoomOutStrength * normalizedDist;
                    newX = centerX + dx * zoomOutFactor;
                    newY = centerY + dy * zoomOutFactor;
                    break;
                case 'fast_zoom_in':
                    const fastZoomInStrength = 0.6;
                    const fastZoomInFactor = 1.0 - fastZoomInStrength * normalizedDist;
                    newX = centerX + dx * fastZoomInFactor;
                    newY = centerY + dy * fastZoomInFactor;
                    break;
                case 'fast_zoom_out':
                    const fastZoomOutStrength = 0.6;
                    const fastZoomOutFactor = 1.0 + fastZoomOutStrength * normalizedDist;
                    newX = centerX + dx * fastZoomOutFactor;
                    newY = centerY + dy * fastZoomOutFactor;
                    break;
                case 'shake':
                    const shakeStrength = 10;
                    const shakeX = (Math.random() - 0.5) * shakeStrength;
                    const shakeY = (Math.random() - 0.5) * shakeStrength;
                    newX = x + shakeX;
                    newY = y + shakeY;
                    break;
                case 'pulse':
                    const pulseStrength = 0.2;
                    const pulseFactor = 1.0 + pulseStrength * Math.sin(normalizedDist * Math.PI * 4);
                    newX = centerX + dx * pulseFactor;
                    newY = centerY + dy * pulseFactor;
                    break;
                case 'spiral_zoom':
                    const spiralZoomStrength = 2.0;
                    const spiralZoomFactor = 1.0 - 0.3 * normalizedDist;
                    if (dist < radius) {
                        const spiralZoomAngle = angle + spiralZoomStrength * normalizedDist;
                        newX = centerX + dist * spiralZoomFactor * Math.cos(spiralZoomAngle);
                        newY = centerY + dist * spiralZoomFactor * Math.sin(spiralZoomAngle);
                    }
                    break;
                case 'extreme_closeup':
                    const extremeCloseupStrength = 0.7;
                    const extremeCloseupFactor = 1.0 - extremeCloseupStrength * normalizedDist;
                    newX = centerX + dx * extremeCloseupFactor;
                    newY = centerY + dy * extremeCloseupFactor;
                    break;
                case 'lens_distortion':
                    const lensStrength = 0.35;
                    const lensFactor = 1.0 - lensStrength * normalizedDist * normalizedDist;
                    newX = centerX + dx * lensFactor;
                    newY = centerY + dy * lensFactor;
                    break;
                case 'funhouse_mirror':
                    const funhouseStrength = 0.4;
                    const funhouseDx = dx / (width / 2);
                    const funhouseStretch = 1.0 + funhouseStrength * Math.sin(funhouseDx * Math.PI);
                    newX = centerX + dx * funhouseStretch;
                    newY = y;
                    break;
                case 'bulge_eyes':
                    const bulgeEyesStrength = 0.6;
                    const bulgeEyesRadius = radius * 0.6;
                    const bulgeEyesDist = Math.sqrt(dx * dx + dy * dy);
                    if (bulgeEyesDist < bulgeEyesRadius) {
                        const bulgeEyesFactor = 1.0 - (bulgeEyesDist / bulgeEyesRadius) * bulgeEyesStrength;
                        newX = centerX + dx * bulgeEyesFactor;
                        newY = centerY + dy * bulgeEyesFactor;
                    }
                    break;
                case 'warp_face':
                    const warpStrength = 0.3;
                    const warpDx = dx / (width / 2);
                    const warpDy = dy / (height / 2);
                    const warpX = warpDx * (1.0 + warpStrength * Math.sin(warpDy * Math.PI * 2));
                    const warpY = warpDy * (1.0 + warpStrength * Math.cos(warpDx * Math.PI * 2));
                    newX = centerX + warpX * (width / 2);
                    newY = centerY + warpY * (height / 2);
                    break;
                case 'funny_squash':
                    const funnySquashStrength = 0.4;
                    const funnySquashDy = dy / (height / 2);
                    const funnySquashFactor = 1.0 - funnySquashStrength * funnySquashDy * funnySquashDy;
                    newX = centerX + dx / funnySquashFactor;
                    newY = y;
                    break;
                case 'funny_stretch':
                    const funnyStretchStrength = 0.4;
                    const funnyStretchDx = dx / (width / 2);
                    const funnyStretchFactor = 1.0 + funnyStretchStrength * funnyStretchDx * funnyStretchDx;
                    newX = x;
                    newY = centerY + dy / funnyStretchFactor;
                    break;
                case 'elastic_face':
                    const elasticFaceStrength = 0.5;
                    const elasticFaceFactor = 1.0 + elasticFaceStrength * Math.sin(normalizedDist * Math.PI * 3) * 0.3;
                    newX = centerX + dx * elasticFaceFactor;
                    newY = centerY + dy * elasticFaceFactor;
                    break;
                case 'smush_face':
                    const smushStrength = 0.5;
                    const smushFactor = 1.0 - smushStrength * normalizedDist;
                    newX = centerX + dx * smushFactor;
                    newY = centerY + dy * smushFactor;
                    break;
                default:
                    // No distortion for unknown filters
                    return { x: x, y: y };
            }
            
            return { x: newX, y: newY };
        }
        
        // Draw wireframe overlay showing distortion
        function drawWireframeOverlay(ctx, width, height, filterType) {
            if (!filterType) return;
            
            // Only show wireframe for distortion filters (not color filters)
            const colorFilters = ['black_white', 'sepia', 'negative', 'vintage', 'neon_glow',
                'red_tint', 'blue_tint', 'green_tint', 'posterize', 'thermal', 'pixelate',
                'blur', 'sharpen', 'emboss', 'sketch', 'cartoon', 'rainbow', 'rainbow_shift',
                'ice', 'ocean', 'plasma', 'jet', 'turbo', 'inferno', 'magma', 'viridis',
                'cool', 'hot', 'spring', 'summer', 'autumn', 'winter', 'vhs', 'retro',
                'cyberpunk', 'anime', 'glow', 'solarize', 'edge_detect', 'halftone', 'acid_trip'];
            
            if (colorFilters.includes(filterType)) {
                return; // Don't show wireframe for color-only filters
            }
            
            // Get accent color from scene config
            const root = document.documentElement;
            const accentColor = getComputedStyle(root).getPropertyValue('--accent-color').trim() || '#5250ef';
            
            // Convert hex to rgba
            let r = 82, g = 80, b = 239; // Default blue
            if (accentColor.startsWith('#')) {
                const hex = accentColor.slice(1);
                r = parseInt(hex.slice(0, 2), 16);
                g = parseInt(hex.slice(2, 4), 16);
                b = parseInt(hex.slice(4, 6), 16);
            }
            
            ctx.save();
            ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, 0.6)`;
            ctx.lineWidth = 1;
            ctx.globalCompositeOperation = 'source-over';
            
            // Draw grid
            const gridSize = 30;
            const gridOffset = 5;
            
            // Horizontal lines
            for (let y = gridOffset; y < height; y += gridSize) {
                ctx.beginPath();
                let pathStarted = false;
                
                for (let x = gridOffset; x < width; x += gridOffset) {
                    const distorted = calculateDistortionVector(x, y, width, height, filterType);
                    // Check if distortion was calculated (not default)
                    if (distorted && (distorted.x !== x || distorted.y !== y || filterType !== 'default')) {
                        if (distorted.x >= 0 && distorted.x < width && distorted.y >= 0 && distorted.y < height) {
                            if (!pathStarted) {
                                ctx.moveTo(distorted.x, distorted.y);
                                pathStarted = true;
                            } else {
                                ctx.lineTo(distorted.x, distorted.y);
                            }
                        }
                    }
                }
                
                if (pathStarted) {
                    ctx.stroke();
                }
            }
            
            // Vertical lines
            for (let x = gridOffset; x < width; x += gridSize) {
                ctx.beginPath();
                let pathStarted = false;
                
                for (let y = gridOffset; y < height; y += gridOffset) {
                    const distorted = calculateDistortionVector(x, y, width, height, filterType);
                    // Check if distortion was calculated (not default)
                    if (distorted && (distorted.x !== x || distorted.y !== y || filterType !== 'default')) {
                        if (distorted.x >= 0 && distorted.x < width && distorted.y >= 0 && distorted.y < height) {
                            if (!pathStarted) {
                                ctx.moveTo(distorted.x, distorted.y);
                                pathStarted = true;
                            } else {
                                ctx.lineTo(distorted.x, distorted.y);
                            }
                        }
                    }
                }
                
                if (pathStarted) {
                    ctx.stroke();
                }
            }
            
            // Draw center point (lighter shade of accent color)
            ctx.fillStyle = `rgba(${r}, ${g}, ${b}, 0.8)`;
            ctx.beginPath();
            ctx.arc(width / 2, height / 2, 3, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.restore();
        }
        
        // JavaScript filter fallback
        function applyJSFilter(imageData, filterType, faceRect) {
            const data = imageData.data;
            const width = imageData.width;
            const height = imageData.height;
            
            // Map filter names to implementations
            const filterMap = {
                'black_white': () => FilterImplementations.applyBlackWhite(data),
                'sepia': () => FilterImplementations.applySepia(data),
                'negative': () => FilterImplementations.applyNegative(data),
                'vintage': () => FilterImplementations.applyVintage(data),
                'neon_glow': () => FilterImplementations.applyNeonGlow(data),
                'red_tint': () => FilterImplementations.applyRedTint(data),
                'blue_tint': () => FilterImplementations.applyBlueTint(data),
                'green_tint': () => FilterImplementations.applyGreenTint(data),
                'posterize': () => FilterImplementations.applyPosterize(data),
                'thermal': () => FilterImplementations.applyThermal(data),
                'pixelate': () => FilterImplementations.applyPixelate(data, width, height),
                'bulge': () => FilterImplementations.applyBulge(data, width, height),
                'swirl': () => FilterImplementations.applySwirl(data, width, height),
                'stretch': () => FilterImplementations.applyStretch(data, width, height),
                'fisheye': () => FilterImplementations.applyFisheye(data, width, height),
                'pinch': () => FilterImplementations.applyPinch(data, width, height),
                'wave': () => FilterImplementations.applyWave(data, width, height),
                'mirror': () => FilterImplementations.applyMirror(data, width, height),
                'flip_horizontal': () => FilterImplementations.applyFlipHorizontal(data, width, height),
                'flip_vertical': () => FilterImplementations.applyFlipVertical(data, width, height),
                'flip_both': () => FilterImplementations.applyFlipBoth(data, width, height),
                'upside_down': () => FilterImplementations.applyUpsideDown(data, width, height),
                'rotate': () => FilterImplementations.applyRotate(data, width, height),
                'rotate_45': () => FilterImplementations.applyRotate45(data, width, height),
                'rotate_90': () => FilterImplementations.applyRotate90(data, width, height),
                'blur': () => FilterImplementations.applyBlur(data, width, height),
                'sharpen': () => FilterImplementations.applySharpen(data, width, height),
                'emboss': () => FilterImplementations.applyEmboss(data, width, height),
                'sketch': () => FilterImplementations.applySketch(data, width, height),
                'cartoon': () => FilterImplementations.applyCartoon(data, width, height),
                'rainbow': () => FilterImplementations.applyRainbow(data, width, height),
                'rainbow_shift': () => FilterImplementations.applyRainbowShift(data),
                'ice': () => FilterImplementations.applyIce(data),
                'ocean': () => FilterImplementations.applyOcean(data),
                'plasma': () => FilterImplementations.applyPlasma(data),
                'jet': () => FilterImplementations.applyJet(data),
                'turbo': () => FilterImplementations.applyTurbo(data),
                'inferno': () => FilterImplementations.applyInferno(data),
                'magma': () => FilterImplementations.applyMagma(data),
                'viridis': () => FilterImplementations.applyViridis(data),
                'cool': () => FilterImplementations.applyCool(data),
                'hot': () => FilterImplementations.applyHot(data),
                'spring': () => FilterImplementations.applySpring(data),
                'summer': () => FilterImplementations.applySummer(data),
                'autumn': () => FilterImplementations.applyAutumn(data),
                'winter': () => FilterImplementations.applyWinter(data),
                'vhs': () => FilterImplementations.applyVHS(data, width, height),
                'retro': () => FilterImplementations.applyRetro(data, width, height),
                'cyberpunk': () => FilterImplementations.applyCyberpunk(data, width, height),
                'anime': () => FilterImplementations.applyAnime(data, width, height),
                'glow': () => FilterImplementations.applyGlow(data, width, height),
                'solarize': () => FilterImplementations.applySolarize(data),
                'edge_detect': () => FilterImplementations.applyEdgeDetect(data, width, height),
                'halftone': () => FilterImplementations.applyHalftone(data, width, height),
                'acid_trip': () => FilterImplementations.applyAcidTrip(data, width, height),
                'twirl': () => FilterImplementations.applyTwirl(data, width, height),
                'ripple': () => FilterImplementations.applyRipple(data, width, height),
                'sphere': () => FilterImplementations.applySphere(data, width, height),
                'tunnel': () => FilterImplementations.applyTunnel(data, width, height),
                'water_ripple': () => FilterImplementations.applyWaterRipple(data, width, height),
                'radial_blur': () => FilterImplementations.applyRadialBlur(data, width, height),
                'cylinder': () => FilterImplementations.applyCylinder(data, width, height),
                'barrel': () => FilterImplementations.applyBarrel(data, width, height),
                'pincushion': () => FilterImplementations.applyPincushion(data, width, height),
                'whirlpool': () => FilterImplementations.applyWhirlpool(data, width, height),
                'radial_zoom': () => FilterImplementations.applyRadialZoom(data, width, height),
                'concave': () => FilterImplementations.applyConcave(data, width, height),
                'convex': () => FilterImplementations.applyConvex(data, width, height),
                'spiral': () => FilterImplementations.applySpiral(data, width, height),
                'radial_stretch': () => FilterImplementations.applyRadialStretch(data, width, height),
                'radial_compress': () => FilterImplementations.applyRadialCompress(data, width, height),
                'vertical_wave': () => FilterImplementations.applyVerticalWave(data, width, height),
                'horizontal_wave': () => FilterImplementations.applyHorizontalWave(data, width, height),
                'skew_horizontal': () => FilterImplementations.applySkewHorizontal(data, width, height),
                'skew_vertical': () => FilterImplementations.applySkewVertical(data, width, height),
                'rotate_zoom': () => FilterImplementations.applyRotateZoom(data, width, height),
                'radial_wave': () => FilterImplementations.applyRadialWave(data, width, height),
                'zoom_in': () => FilterImplementations.applyZoomIn(data, width, height),
                'zoom_out': () => FilterImplementations.applyZoomOut(data, width, height),
                'fast_zoom_in': () => FilterImplementations.applyFastZoomIn(data, width, height, frameCount),
                'fast_zoom_out': () => FilterImplementations.applyFastZoomOut(data, width, height, frameCount),
                'shake': () => FilterImplementations.applyShake(data, width, height, frameCount),
                'pulse': () => FilterImplementations.applyPulse(data, width, height, frameCount),
                'spiral_zoom': () => FilterImplementations.applySpiralZoom(data, width, height, frameCount),
                'extreme_closeup': () => FilterImplementations.applyExtremeCloseup(data, width, height, frameCount),
                'puzzle': () => FilterImplementations.applyPuzzle(data, width, height),
                'quad_mirror': () => FilterImplementations.applyQuadMirror(data, width, height),
                'tile': () => FilterImplementations.applyTile(data, width, height),
                'radial_tile': () => FilterImplementations.applyRadialTile(data, width, height),
                'zoom_blur': () => FilterImplementations.applyZoomBlur(data, width, height),
                'melt': () => FilterImplementations.applyMelt(data, width, height),
                'kaleidoscope': () => FilterImplementations.applyKaleidoscope(data, width, height),
                'glitch': () => FilterImplementations.applyGlitch(data, width, height),
                'double_vision': () => FilterImplementations.applyDoubleVision(data, width, height),
                'multi_ripple': () => FilterImplementations.applyMultiRipple(data, width, height),
                'radial_squeeze': () => FilterImplementations.applyRadialSqueeze(data, width, height),
                'elastic_stretch': () => FilterImplementations.applyElasticStretch(data, width, height),
                'lens_distortion': () => FilterImplementations.applyLensDistortion(data, width, height),
                'wave_distortion': () => FilterImplementations.applyWaveDistortion(data, width, height),
                'squeeze_horizontal': () => FilterImplementations.applySqueezeHorizontal(data, width, height),
                'squeeze_vertical': () => FilterImplementations.applySqueezeVertical(data, width, height),
                'radial_wobble': () => FilterImplementations.applyRadialWobble(data, width, height),
                'complex_ripple': () => FilterImplementations.applyComplexRipple(data, width, height),
                'squish_face': () => FilterImplementations.applySquishFace(data, width, height),
                'stretch_face': () => FilterImplementations.applyStretchFace(data, width, height),
                'funhouse_mirror': () => FilterImplementations.applyFunhouseMirror(data, width, height),
                'pinch_cheeks': () => FilterImplementations.applyPinchCheeks(data, width, height),
                'bulge_eyes': () => FilterImplementations.applyBulgeEyes(data, width, height),
                'warp_face': () => FilterImplementations.applyWarpFace(data, width, height),
                'funny_squash': () => FilterImplementations.applyFunnySquash(data, width, height),
                'funny_stretch': () => FilterImplementations.applyFunnyStretch(data, width, height),
                'wobble_face': () => FilterImplementations.applyWobbleFace(data, width, height),
                'elastic_face': () => FilterImplementations.applyElasticFace(data, width, height),
                'gentle_ripple': () => FilterImplementations.applyGentleRipple(data, width, height),
                'smush_face': () => FilterImplementations.applySmushFace(data, width, height),
                'ultimate_distortion': () => FilterImplementations.applyUltimateDistortion(data, width, height)
            };
            
            const filterFunc = filterMap[filterType];
            if (filterFunc) {
                try {
                    filterFunc();
                } catch (error) {
                    console.error(`Error applying filter "${filterType}":`, error);
                }
            } else {
                console.warn(`Filter "${filterType}" not yet implemented in JS fallback`);
            }
        }
        
        // Start camera
        async function startCamera() {
            try {
                const deviceId = cameraSelect.value;
                
                // Load saved facing mode preference
                const savedFacingMode = localStorage.getItem('wesworld-fx-camera-facing');
                if (savedFacingMode && (savedFacingMode === 'user' || savedFacingMode === 'environment')) {
                    currentFacingMode = savedFacingMode;
                }
                
                const constraints = {
                    video: {
                        deviceId: deviceId ? { exact: deviceId } : undefined,
                        width: { ideal: 1280 },
                        height: { ideal: 720 }
                    }
                };
                
                // Use facingMode on mobile if no specific device is selected
                if (isMobileDevice() && !deviceId) {
                    constraints.video.facingMode = currentFacingMode;
                }
                
                localStream = await navigator.mediaDevices.getUserMedia(constraints);
                
                // Ensure video element has required attributes for mobile Safari
                videoInput.setAttribute('autoplay', '');
                videoInput.setAttribute('playsinline', '');
                videoInput.setAttribute('muted', '');
                
                // Stop any existing stream tracks before setting new one
                if (videoInput.srcObject) {
                    const oldStream = videoInput.srcObject;
                    oldStream.getTracks().forEach(track => track.stop());
                }
                
                videoInput.srcObject = localStream;
                
                // Force play immediately on mobile Safari
                let playAttempts = 0;
                const maxPlayAttempts = 5;
                const tryPlay = async () => {
                    try {
                        await videoInput.play();
                        console.log('Video play successful');
                    } catch (playError) {
                        playAttempts++;
                        if (playAttempts < maxPlayAttempts) {
                            console.warn(`Video play() attempt ${playAttempts} failed, retrying:`, playError);
                            setTimeout(tryPlay, 100 * playAttempts);
                        } else {
                            console.warn('Video play() failed after max attempts:', playError);
                        }
                    }
                };
                await tryPlay();
                
                if (deviceId) {
                    localStorage.setItem('wesworld-fx-camera', deviceId);
                }
                localStorage.setItem('wesworld-fx-camera-active', 'true');
                // Remember that user has started camera - enable auto-start on future page loads
                localStorage.setItem('wesworld-fx-camera-auto-start', 'true');
                
                // Multiple event handlers for better Safari mobile compatibility
                let isInitialized = false;
                const initializeVideo = () => {
                    if (isInitialized) return;
                    
                    if (videoInput.readyState >= 2 && videoInput.videoWidth > 0 && videoInput.videoHeight > 0) {
                        isInitialized = true;
                        
                        canvasOutput.width = videoInput.videoWidth;
                        canvasOutput.height = videoInput.videoHeight;
                        
                        // Ensure video is playing
                        if (videoInput.paused) {
                            videoInput.play().catch(err => console.warn('Play failed in initializeVideo:', err));
                        }
                        
                        // Start processing loop
                        if (!animationFrameId) {
                            processVideoFrame();
                        }
                        
                        updateStatus('Camera active', 'connected');
                        if (cameraStatusText) {
                            cameraStatusText.textContent = 'Camera: Active';
                            cameraStatusText.parentElement.className = 'camera-status connected';
                        }
                        startButton.style.display = 'none';
                        stopButton.style.display = 'block';
                        
                        // Collapse settings when camera is active
                        const settingsSection = document.querySelector('.settings-section');
                        const settingsToggle = document.getElementById('settingsToggle');
                        if (settingsSection && settingsToggle) {
                            settingsSection.classList.remove('expanded');
                            settingsToggle.classList.remove('expanded');
                        }
                    }
                };
                
                // Handle loadedmetadata
                videoInput.onloadedmetadata = () => {
                    console.log('Video metadata loaded');
                    initializeVideo();
                };
                
                // Handle loadeddata (fires earlier than loadedmetadata on some browsers)
                videoInput.addEventListener('loadeddata', () => {
                    console.log('Video data loaded');
                    initializeVideo();
                }, { once: true });
                
                // Handle canplay
                videoInput.addEventListener('canplay', () => {
                    console.log('Video can play');
                    initializeVideo();
                }, { once: true });
                
                // Handle playing event
                videoInput.addEventListener('playing', () => {
                    console.log('Video is playing');
                    initializeVideo();
                }, { once: true });
                
                // Fallback: check periodically if not initialized (for Safari mobile)
                let checkCount = 0;
                const maxChecks = 50; // 5 seconds max
                const checkInterval = setInterval(() => {
                    checkCount++;
                    if (isInitialized) {
                        clearInterval(checkInterval);
                    } else if (checkCount >= maxChecks) {
                        clearInterval(checkInterval);
                        // Force initialization even if dimensions aren't ready
                        if (!isInitialized && videoInput.readyState >= 1) {
                            console.warn('Forcing video initialization after timeout');
                            canvasOutput.width = videoInput.videoWidth || 640;
                            canvasOutput.height = videoInput.videoHeight || 480;
                            isInitialized = true;
                            if (!animationFrameId) {
                                processVideoFrame();
                            }
                            updateStatus('Camera active', 'connected');
                            if (cameraStatusText) {
                                cameraStatusText.textContent = 'Camera: Active';
                                cameraStatusText.parentElement.className = 'camera-status connected';
                            }
                            startButton.style.display = 'none';
                            stopButton.style.display = 'block';
                        }
                    } else {
                        initializeVideo();
                    }
                }, 100);
                
            } catch (error) {
                console.error('Error starting camera:', error);
                updateStatus('Camera error: ' + error.message, 'error');
                localStorage.setItem('wesworld-fx-camera-active', 'false');
            }
        }
        
        // Stop camera
        function stopCamera() {
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
                localStream = null;
            }
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
            videoInput.srcObject = null;
            ctx.clearRect(0, 0, canvasOutput.width, canvasOutput.height);
            startButton.style.display = 'block';
            stopButton.style.display = 'none';
            updateStatus('Camera stopped', '');
            if (cameraStatusText) {
                cameraStatusText.textContent = 'Camera: Stopped';
                cameraStatusText.parentElement.className = 'camera-status stopped';
            }
            localStorage.setItem('wesworld-fx-camera-active', 'false');
            
            // Expand settings and show start button when camera is stopped
            const settingsSection = document.querySelector('.settings-section');
            const settingsToggle = document.getElementById('settingsToggle');
            if (settingsSection && settingsToggle) {
                settingsSection.classList.add('expanded');
                settingsToggle.classList.add('expanded');
            }
            startButton.style.display = 'block';
            stopButton.style.display = 'none';
        }
        
        // Toggle UI
        function toggleUI() {
            controlsVisible = !controlsVisible;
            if (controlsVisible) {
                controls.classList.add('visible');
                controls.classList.remove('hidden');
            } else {
                controls.classList.add('hidden');
                controls.classList.remove('visible');
            }
        }
        
        // Toggle wireframe overlay
        function toggleWireframe() {
            showWireframe = !showWireframe;
            try {
                localStorage.setItem('wesworld-fx-wireframe', showWireframe.toString());
            } catch (e) {
                console.warn('Could not save wireframe preference:', e);
            }
        }
        
        // Tutorial functions
        function showTutorial() {
            const tutorialModal = document.getElementById('tutorialModal');
            if (tutorialModal) {
                tutorialModal.setAttribute('aria-hidden', 'false');
                tutorialModal.style.display = 'flex';
                // Focus the close button for accessibility
                const closeButton = document.getElementById('tutorialClose');
                if (closeButton) {
                    setTimeout(() => closeButton.focus(), 100);
                }
            }
        }
        
        function hideTutorial() {
            const tutorialModal = document.getElementById('tutorialModal');
            if (tutorialModal) {
                tutorialModal.setAttribute('aria-hidden', 'true');
                tutorialModal.style.display = 'none';
            }
        }
        
        function checkAndShowTutorial() {
            // Check if tutorial has been shown before
            const tutorialShown = localStorage.getItem('wesworld-fx-tutorial-shown');
            const dontShowAgain = localStorage.getItem('wesworld-fx-tutorial-dont-show');
            
            if (!tutorialShown && !dontShowAgain) {
                // Show tutorial on first load
                setTimeout(() => {
                    showTutorial();
                    localStorage.setItem('wesworld-fx-tutorial-shown', 'true');
                    
                    // On mobile, also open the search menu
                    if (isMobileDevice() && fxSearchModal) {
                        setTimeout(() => {
                            openFxSearchModal();
                        }, 500);
                    }
                }, 1000); // Wait a bit for page to load
            } else if (isMobileDevice() && !tutorialShown && !dontShowAgain) {
                // On mobile, open menu even if tutorial was skipped
                setTimeout(() => {
                    if (fxSearchModal) {
                        openFxSearchModal();
                    }
                }, 500);
            }
        }
        
        // Setup event listeners
        function setupEventListeners() {
            console.log('Setting up event listeners', { fxSearchTrigger, fxSearchModal, fxSearchInput });
            
            // Tutorial modal event listeners
            const tutorialModal = document.getElementById('tutorialModal');
            const tutorialClose = document.getElementById('tutorialClose');
            const tutorialGotIt = document.getElementById('tutorialGotIt');
            const tutorialDontShow = document.getElementById('tutorialDontShowAgain');
            
            if (tutorialClose) {
                tutorialClose.addEventListener('click', () => {
                    if (tutorialDontShow && tutorialDontShow.checked) {
                        localStorage.setItem('wesworld-fx-tutorial-dont-show', 'true');
                    }
                    hideTutorial();
                });
            }
            
            if (tutorialGotIt) {
                tutorialGotIt.addEventListener('click', () => {
                    if (tutorialDontShow && tutorialDontShow.checked) {
                        localStorage.setItem('wesworld-fx-tutorial-dont-show', 'true');
                    }
                    hideTutorial();
                });
            }
            
            // Close tutorial on Escape key
            if (tutorialModal) {
                tutorialModal.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape' && tutorialModal.getAttribute('aria-hidden') === 'false') {
                        if (tutorialDontShow && tutorialDontShow.checked) {
                            localStorage.setItem('wesworld-fx-tutorial-dont-show', 'true');
                        }
                        hideTutorial();
                    }
                });
                
                // Close tutorial when clicking outside
                tutorialModal.addEventListener('click', (e) => {
                    if (e.target === tutorialModal) {
                        if (tutorialDontShow && tutorialDontShow.checked) {
                            localStorage.setItem('wesworld-fx-tutorial-dont-show', 'true');
                        }
                        hideTutorial();
                    }
                });
            }
            
            // Hide menu button
            const hideMenuButton = document.getElementById('hideMenuButton');
            if (hideMenuButton) {
                hideMenuButton.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    toggleUI();
                });
                // Also handle touch for better mobile support
                hideMenuButton.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    toggleUI();
                }, { passive: false });
            }
            
            // Click outside menu to hide it, or click anywhere to show it when hidden (desktop/big window only)
            document.addEventListener('click', (e) => {
                // Only on desktop/big window (not mobile)
                if (isMobileDevice()) {
                    return;
                }
                
                // If menu is hidden, show it on any click
                if (!controlsVisible || controls.classList.contains('hidden')) {
                    // Show the menu
                    toggleUI();
                    return;
                }
                
                // Menu is visible - check if click is outside the controls element
                if (controls && !controls.contains(e.target)) {
                    // Hide the menu
                    toggleUI();
                }
            });
            
            // Settings toggle
            const settingsToggle = document.getElementById('settingsToggle');
            if (settingsToggle) {
                settingsToggle.addEventListener('click', () => {
                    // Prevent hiding menu until camera is started and active
                    const cameraStatusText = document.getElementById('cameraStatusText');
                    const isCameraActive = cameraStatusText && cameraStatusText.textContent === 'Camera: Active';
                    
                    if (!isCameraActive) {
                        // Camera not active - keep menu expanded, don't allow hiding
                        return;
                    }
                    
                    // Camera is active - allow toggle
                    const settingsSection = settingsToggle.closest('.settings-section');
                    settingsSection.classList.toggle('expanded');
                    settingsToggle.classList.toggle('expanded');
                });
            }
            
            // Help section toggle
            const helpToggle = document.getElementById('helpToggle');
            if (helpToggle) {
                helpToggle.addEventListener('click', () => {
                    const helpSection = helpToggle.closest('.help-section');
                    helpSection.classList.toggle('expanded');
                    helpToggle.classList.toggle('expanded');
                });
                // Also handle touch for better mobile support
                helpToggle.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    const helpSection = helpToggle.closest('.help-section');
                    helpSection.classList.toggle('expanded');
                    helpToggle.classList.toggle('expanded');
                }, { passive: false });
            }
            
            // Make help commands clickable/tappable for mobile
            function setupHelpCommandHandlers() {
                const helpCommands = document.querySelectorAll('.help-command[data-action]');
                
                helpCommands.forEach(cmd => {
                    const action = cmd.getAttribute('data-action');
                    
                    // Handle click
                    cmd.addEventListener('click', (e) => {
                        // Don't prevent clicks on disabled items, but log for debugging
                        if (cmd.classList.contains('disabled') && (action === 'increase-mask' || action === 'decrease-mask')) {
                            console.log('Face mask control clicked but appears disabled. Current filter:', currentFilter);
                            // Still try to execute in case the disabled state is incorrect
                        }
                        e.stopPropagation();
                        handleHelpCommandAction(action);
                    });
                    
                    // Handle touch for mobile
                    cmd.addEventListener('touchend', (e) => {
                        // Don't prevent touches on disabled items, but log for debugging
                        if (cmd.classList.contains('disabled') && (action === 'increase-mask' || action === 'decrease-mask')) {
                            console.log('Face mask control tapped but appears disabled. Current filter:', currentFilter);
                            // Still try to execute in case the disabled state is incorrect
                        }
                        e.preventDefault();
                        e.stopPropagation();
                        handleHelpCommandAction(action);
                    }, { passive: false });
                });
            }
            
            function handleHelpCommandAction(action) {
                switch(action) {
                    case 'toggle-ui':
                        toggleUI();
                        break;
                    case 'open-search':
                        openFxSearchModal();
                        break;
                    case 'toggle-wireframe':
                        toggleWireframe();
                        break;
                    case 'prev-filter':
                        cyclePrevFilter();
                        break;
                    case 'next-filter':
                        cycleNextFilter();
                        break;
                    case 'random-cycle':
                        startRandomCycle();
                        break;
                    case 'clear-filter':
                        clearFilter();
                        break;
                    case 'increase-mask':
                        // Check if face mask filter is active (supports both 'face_mask' and 'mask_' patterns)
                        console.log('Increase mask clicked. Current filter:', currentFilter, 'Type:', typeof currentFilter);
                        if (currentFilter && (currentFilter.includes('face_mask') || currentFilter.includes('mask_'))) {
                            console.log('Adjusting face mask size +0.1');
                            adjustFaceMaskSize(0.1);
                        } else {
                            console.warn('Face mask controls: No face mask filter active. Current filter:', currentFilter);
                        }
                        break;
                    case 'decrease-mask':
                        // Check if face mask filter is active (supports both 'face_mask' and 'mask_' patterns)
                        console.log('Decrease mask clicked. Current filter:', currentFilter, 'Type:', typeof currentFilter);
                        if (currentFilter && (currentFilter.includes('face_mask') || currentFilter.includes('mask_'))) {
                            console.log('Adjusting face mask size -0.1');
                            adjustFaceMaskSize(-0.1);
                        } else {
                            console.warn('Face mask controls: No face mask filter active. Current filter:', currentFilter);
                        }
                        break;
                }
            }
            
            // Update face mask control states based on current filter
            function updateFaceMaskControlsState() {
                const increaseMask = document.getElementById('helpIncreaseMask');
                const decreaseMask = document.getElementById('helpDecreaseMask');
                // Check for both 'face_mask' and 'mask_' patterns to support all face mask filters
                const isFaceMaskActive = currentFilter && (currentFilter.includes('face_mask') || currentFilter.includes('mask_'));
                
                console.log('Updating face mask controls state. Current filter:', currentFilter, 'Is active:', isFaceMaskActive);
                
                if (increaseMask) {
                    if (isFaceMaskActive) {
                        increaseMask.classList.remove('disabled');
                    } else {
                        increaseMask.classList.add('disabled');
                    }
                }
                
                if (decreaseMask) {
                    if (isFaceMaskActive) {
                        decreaseMask.classList.remove('disabled');
                    } else {
                        decreaseMask.classList.add('disabled');
                    }
                }
            }
            
            // Setup help command handlers
            setupHelpCommandHandlers();
            
            // Initial update of face mask controls state
            // This will be called again when filters are loaded
            setTimeout(() => {
                if (typeof updateFaceMaskControlsState === 'function') {
                    updateFaceMaskControlsState();
                }
            }, 100);
            
            // FX section toggle
            const fxToggle = document.getElementById('fxToggle');
            if (fxToggle) {
                fxToggle.addEventListener('click', () => {
                    const fxSection = fxToggle.closest('.fx-section');
                    fxSection.classList.toggle('expanded');
                    fxToggle.classList.toggle('expanded');
                });
                // Also handle touch for better mobile support
                fxToggle.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    const fxSection = fxToggle.closest('.fx-section');
                    fxSection.classList.toggle('expanded');
                    fxToggle.classList.toggle('expanded');
                }, { passive: false });
            }
            
            // Corner tap areas for mobile - open menu when tapped
            function setupCornerTapAreas() {
                const cornerTopLeft = document.getElementById('cornerTopLeft');
                const cornerTopRight = document.getElementById('cornerTopRight');
                const cornerBottomLeft = document.getElementById('cornerBottomLeft');
                const cornerBottomRight = document.getElementById('cornerBottomRight');
                
                const handleCornerTap = () => {
                    // Open/expand the settings menu
                    const settingsSection = document.querySelector('.settings-section');
                    const settingsToggle = document.getElementById('settingsToggle');
                    if (settingsSection && settingsToggle) {
                        settingsSection.classList.add('expanded');
                        settingsToggle.classList.add('expanded');
                    }
                    // Also show controls if hidden
                    const controlsEl = document.getElementById('controls');
                    if (controlsEl && controlsEl.classList.contains('hidden')) {
                        controlsEl.classList.remove('hidden');
                        controlsEl.classList.add('visible');
                        controlsVisible = true;
                    }
                };
                
                // Add event listeners for both click and touch
                [cornerTopLeft, cornerTopRight, cornerBottomLeft, cornerBottomRight].forEach(corner => {
                    if (corner) {
                        corner.addEventListener('click', handleCornerTap);
                        corner.addEventListener('touchend', (e) => {
                            e.preventDefault();
                            handleCornerTap();
                        });
                    }
                });
                
                // Show/hide corner tap areas based on device type
                const updateCornerTapVisibility = () => {
                    const shouldShow = shouldShowCornerTaps();
                    [cornerTopLeft, cornerTopRight, cornerBottomLeft, cornerBottomRight].forEach(corner => {
                        if (corner) {
                            corner.style.display = shouldShow ? 'block' : 'none';
                        }
                    });
                };
                
                // Initial check
                updateCornerTapVisibility();
                
                // Update on window resize
                window.addEventListener('resize', updateCornerTapVisibility);
            }
            
            // Setup corner tap areas
            setupCornerTapAreas();
            
            if (startButton) {
                startButton.addEventListener('click', startCamera);
            }
            if (stopButton) {
                stopButton.addEventListener('click', stopCamera);
            }
            
            // Auto-stop and start camera when selection changes
            if (cameraSelect) {
                cameraSelect.addEventListener('change', async (e) => {
                    const newDeviceId = e.target.value;
                    // Only restart if camera was already active
                    if (localStream) {
                        console.log('Camera selection changed, restarting with new camera...');
                        // Stop current camera
                        stopCamera();
                        // Wait a moment for cleanup, then start new camera
                        setTimeout(() => {
                            if (newDeviceId) {
                                startCamera().catch(error => {
                                    console.error('Error starting new camera:', error);
                                    updateStatus('Camera error: ' + error.message, 'error');
                                });
                            }
                        }, 100);
                    }
                });
            }
            
            // Face mask zoom reset button
            const resetFaceMaskZoomButton = document.getElementById('resetFaceMaskZoomButton');
            if (resetFaceMaskZoomButton) {
                resetFaceMaskZoomButton.addEventListener('click', () => {
                    resetFaceMaskSize();
                });
            }
            
            // Test image handlers
            if (testImageInput) {
                testImageInput.addEventListener('change', (e) => {
                    const file = e.target.files[0];
                    if (file) {
                        loadTestImage(file).catch(err => {
                            console.error('Error loading test image:', err);
                        });
                    }
                });
            }
            
            if (clearTestImageButton) {
                clearTestImageButton.addEventListener('click', () => {
                    clearTestImage();
                });
            }
            
            // FX current pin handler (disabled - pinning is hidden)
            // if (fxCurrentPin) {
            //     fxCurrentPin.addEventListener('click', (e) => {
            //         ... pin handler code ...
            //     });
            // }
            
            // Clear filter button
            if (clearFilterButton) {
                clearFilterButton.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    clearFilter();
                });
            }
            
            // Load wireframe preference
            try {
                const saved = localStorage.getItem('wesworld-fx-wireframe');
                if (saved === 'true') {
                    showWireframe = true;
                }
            } catch (e) {
                console.warn('Could not load wireframe preference:', e);
            }
            
            // Start roulette button
            const startRouletteButton = document.getElementById('startRouletteButton');
            if (startRouletteButton) {
                startRouletteButton.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    startRandomCycle();
                });
            }
            
            // Spotlight-style search trigger - toggle on click/tap
            if (fxSearchTrigger) {
                console.log('Setting up fxSearchTrigger click handler');
                // Handle both click and touch for better mobile support - toggle behavior
                const handleSearchToggle = (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    console.log('fxSearchTrigger clicked/touched');
                    // Toggle: open if closed, close if open
                    if (fxSearchModal && fxSearchModal.classList.contains('active')) {
                        closeFxSearchModal();
                    } else {
                        openFxSearchModal();
                    }
                };
                
                fxSearchTrigger.addEventListener('click', handleSearchToggle);
                // Also handle touch for better mobile support
                fxSearchTrigger.addEventListener('touchend', handleSearchToggle, { passive: false });
            } else {
                console.error('fxSearchTrigger element not found!');
            }
            
            // Clear search input button
            if (fxSearchClear) {
                fxSearchClear.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    if (fxSearchInput) {
                        fxSearchInput.value = '';
                        fxSearchInput.focus();
                        filterFxOptions('');
                        updateClearButtonVisibility();
                    }
                });
            }
            
            // Close modal when clicking/tapping outside (works for both mouse and touch)
            if (fxSearchModal) {
                // Handle both click and touch events for better mobile support
                const handleModalClose = (e) => {
                    // Close if clicking on the backdrop (modal itself, not the content)
                    // Check if click is directly on modal or outside content area
                    const clickedContent = e.target.closest('.fx-search-modal-content');
                    if (e.target === fxSearchModal || !clickedContent) {
                        e.preventDefault();
                        e.stopPropagation();
                        closeFxSearchModal();
                    }
                };
                
                // Use mousedown for better responsiveness
                fxSearchModal.addEventListener('mousedown', (e) => {
                    if (e.target === fxSearchModal) {
                        handleModalClose(e);
                    }
                });
                
                // Also handle click as fallback
                fxSearchModal.addEventListener('click', handleModalClose);
                
                // Touch events for mobile
                fxSearchModal.addEventListener('touchstart', (e) => {
                    if (e.target === fxSearchModal) {
                        // Store the touch target
                        fxSearchModal._touchTarget = e.target;
                    }
                }, { passive: true });
                
                fxSearchModal.addEventListener('touchend', (e) => {
                    // Only close if touch started and ended on the backdrop
                    if (fxSearchModal._touchTarget === fxSearchModal && 
                        (e.target === fxSearchModal || !e.target.closest('.fx-search-modal-content'))) {
                        e.preventDefault();
                        e.stopPropagation();
                        closeFxSearchModal();
                    }
                    fxSearchModal._touchTarget = null;
                }, { passive: false });
            }
            
            // FX Grid Modal event listeners
            if (fxGridClose) {
                fxGridClose.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    closeFxGridModal();
                });
                fxGridClose.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    closeFxGridModal();
                }, { passive: false });
            }
            
            // Close grid modal when clicking/tapping outside
            if (fxGridModal) {
                const handleGridModalClose = (e) => {
                    const clickedContent = e.target.closest('.fx-grid-modal-content');
                    if (e.target === fxGridModal || !clickedContent) {
                        e.preventDefault();
                        e.stopPropagation();
                        closeFxGridModal();
                    }
                };
                
                fxGridModal.addEventListener('mousedown', (e) => {
                    if (e.target === fxGridModal) {
                        handleGridModalClose(e);
                    }
                });
                
                fxGridModal.addEventListener('click', handleGridModalClose);
                
                // Touch events for mobile
                fxGridModal.addEventListener('touchstart', (e) => {
                    if (e.target === fxGridModal) {
                        fxGridModal._touchTarget = e.target;
                    }
                }, { passive: true });
                
                fxGridModal.addEventListener('touchend', (e) => {
                    if (fxGridModal._touchTarget === fxGridModal && 
                        (e.target === fxGridModal || !e.target.closest('.fx-grid-modal-content'))) {
                        e.preventDefault();
                        e.stopPropagation();
                        closeFxGridModal();
                    }
                    fxGridModal._touchTarget = null;
                }, { passive: false });
            }
            
            // Toggle UI when clicking/tapping on video (same as pressing 'h')
            // Also hide menu when tapping outside if camera is active
            if (videoContainer && canvasOutput) {
                const handleVideoToggle = (e) => {
                    // Don't toggle if clicking on controls or other UI elements
                    const clickedElement = e.target;
                    const isClickOnUI = clickedElement.closest('#controls') || 
                                       clickedElement.closest('.fx-search-modal') ||
                                       clickedElement.closest('#tutorialModal') ||
                                       clickedElement === fxSearchTrigger ||
                                       clickedElement.closest('button') ||
                                       clickedElement.closest('input') ||
                                       clickedElement.closest('select') ||
                                       clickedElement.closest('.corner-tap-area');
                    
                    // Only toggle if clicking directly on video container or canvas
                    const isClickOnVideo = clickedElement === videoContainer || 
                                         clickedElement === canvasOutput ||
                                         clickedElement === videoInput;
                    
                    if (isClickOnVideo && !isClickOnUI) {
                        // Check if camera is active
                        const cameraStatusText = document.getElementById('cameraStatusText');
                        const isCameraActive = cameraStatusText && cameraStatusText.textContent === 'Camera: Active';
                        
                        if (isCameraActive) {
                            // Hide/collapse the settings menu when camera is active
                            const settingsSection = document.querySelector('.settings-section');
                            const settingsToggle = document.getElementById('settingsToggle');
                            if (settingsSection && settingsToggle) {
                                settingsSection.classList.remove('expanded');
                                settingsToggle.classList.remove('expanded');
                            }
                        } else {
                            // If camera is not active, toggle UI visibility (same as pressing 'h')
                            toggleUI();
                        }
                    }
                };
                
                // Handle both click and touch events on container
                videoContainer.addEventListener('click', handleVideoToggle);
                videoContainer.addEventListener('touchend', (e) => {
                    // Prevent default to avoid double-firing with click
                    e.preventDefault();
                    handleVideoToggle(e);
                }, { passive: false });
                
                // Also handle directly on canvas for better mobile support
                canvasOutput.addEventListener('click', handleVideoToggle);
                canvasOutput.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    handleVideoToggle(e);
                }, { passive: false });
            }
            
            // Search input in modal
            if (fxSearchInput) {
                fxSearchInput.addEventListener('input', (e) => {
                    const searchValue = e.target.value;
                    filterFxOptions(searchValue);
                    updateClearButtonVisibility();
                    // Update aria-expanded based on results
                    const hasResults = fxOptionsContainer && 
                        fxOptionsContainer.querySelector('.fx-option:not([style*="display: none"])');
                    fxSearchInput.setAttribute('aria-expanded', hasResults ? 'true' : 'false');
                });
                
                fxSearchInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape') {
                        e.preventDefault();
                        closeFxSearchModal();
                    } else if (e.key === 'Enter') {
                        e.preventDefault();
                        const optionsContainer = document.getElementById('fxOptionsContainer');
                        if (optionsContainer) {
                            const firstVisible = optionsContainer.querySelector('.fx-option:not([style*="display: none"])');
                            if (firstVisible && firstVisible.value !== undefined) {
                                selectFilter(firstVisible.value);
                                closeFxSearchModal();
                            }
                        }
                    } else if (e.key === 'ArrowDown') {
                        // Allow arrow keys to navigate results
                        e.preventDefault();
                        const optionsContainer = document.getElementById('fxOptionsContainer');
                        if (optionsContainer) {
                            const firstVisible = optionsContainer.querySelector('.fx-option:not([style*="display: none"])');
                            if (firstVisible) {
                                firstVisible.focus();
                            }
                        }
                    }
                });
            }
            
            // Clear button handler
            if (fxSearchClear) {
                fxSearchClear.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    if (fxSearchInput) {
                        fxSearchInput.value = '';
                        fxSearchInput.focus();
                        filterFxOptions('');
                        updateClearButtonVisibility();
                        fxSearchInput.setAttribute('aria-expanded', 'false');
                    }
                });
            }
            
            // Keyboard shortcut to open search (Cmd/Ctrl + K) - handled in main keyboard shortcuts below
            
            // Scene change handler
            if (sceneSelect) {
                sceneSelect.addEventListener('change', async (e) => {
                    const sceneKey = e.target.value;
                    // Make sure scene is loaded
                    if (!SCENES[sceneKey]) {
                        await loadSceneFromFile(sceneKey);
                    }
                    if (SCENES[sceneKey]) {
                        applyScene(SCENES[sceneKey]);
                        localStorage.setItem('wesworld-fx-scene', sceneKey);
                        console.log('Scene changed to:', sceneKey);
                    } else {
                        console.error(`Failed to load scene: ${sceneKey}`);
                        // Fallback to dropout if scene fails to load
                        if (SCENES.dropout) {
                            sceneSelect.value = 'dropout';
                            applyScene(SCENES.dropout);
                            localStorage.setItem('wesworld-fx-scene', 'dropout');
                        }
                    }
                });
            }
            
            // Close dropdown when clicking outside (legacy support)
            document.addEventListener('click', (e) => {
                // Only handle if not clicking on modal or trigger
                if (fxSearchModal && fxSearchModal.contains(e.target)) return;
                if (fxSearchTrigger && fxSearchTrigger.contains(e.target)) return;
                
                // Legacy dropdown handling (if still exists)
                if (fxDropdownMenu && fxDropdownButton && !fxDropdownButton.contains(e.target) && !fxDropdownMenu.contains(e.target)) {
                    fxDropdownMenu.classList.remove('open');
                }
            });
            
            // Keyboard shortcuts
            document.addEventListener('keydown', (e) => {
                // Don't handle shortcuts if user is typing in an input field
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT' || e.target.isContentEditable) {
                    return;
                }
                
                switch(e.key) {
                    case 'h':
                    case 'H':
                        toggleUI();
                        break;
                    case 'w':
                    case 'W':
                        e.preventDefault();
                        toggleWireframe();
                        break;
                    case 'ArrowUp':
                    case 'ArrowLeft':
                        e.preventDefault();
                        // If grid modal is open, navigate grid instead
                        if (fxGridModal && fxGridModal.classList.contains('active')) {
                            navigateGrid(e.key === 'ArrowUp' ? 'up' : 'left');
                        } else {
                            cyclePrevFilter();
                        }
                        break;
                    case 'ArrowDown':
                    case 'ArrowRight':
                        e.preventDefault();
                        // If grid modal is open, navigate grid instead
                        if (fxGridModal && fxGridModal.classList.contains('active')) {
                            navigateGrid(e.key === 'ArrowDown' ? 'down' : 'right');
                        } else {
                            cycleNextFilter();
                        }
                        break;
                    case ' ':
                        e.preventDefault();
                        startRandomCycle();
                        break;
                    case 'c':
                    case 'C':
                        e.preventDefault();
                        clearFilter();
                        break;
                    case 'Escape':
                        // Close modals first, then clear filter
                        if (fxGridModal && fxGridModal.classList.contains('active')) {
                            e.preventDefault();
                            closeFxGridModal();
                        } else if (fxSearchModal && fxSearchModal.classList.contains('active')) {
                            e.preventDefault();
                            closeFxSearchModal();
                        } else {
                            e.preventDefault();
                            clearFilter();
                        }
                        break;
                    case '-':
                    case '_':
                        // Decrease face mask size when in face mask mode
                        if (currentFilter && currentFilter.includes('face_mask')) {
                            e.preventDefault();
                            adjustFaceMaskSize(-0.1);
                        }
                        break;
                    case '+':
                    case '=':
                        // Increase face mask size when in face mask mode
                        if (currentFilter && currentFilter.includes('face_mask')) {
                            e.preventDefault();
                            adjustFaceMaskSize(0.1);
                        }
                        break;
                    case 'f':
                    case 'F':
                        e.preventDefault();
                        openFxSearchModal();
                        break;
                    case 't':
                    case 'T':
                        e.preventDefault();
                        showTutorial();
                        break;
                    case 'g':
                    case 'G':
                        e.preventDefault();
                        if (fxGridModal && fxGridModal.classList.contains('active')) {
                            closeFxGridModal();
                        } else {
                            openFxGridModal();
                        }
                        break;
                }
                
                // Keyboard shortcut to open search (Cmd/Ctrl + K)
                if ((e.metaKey || e.ctrlKey) && e.key === 'k') {
                    e.preventDefault();
                    console.log('Cmd/Ctrl+K pressed in main handler');
                    openFxSearchModal();
                }
            });
            
            // Touch/swipe gesture handlers for mobile filter navigation
            let touchStartX = null;
            let touchStartY = null;
            const minSwipeDistance = 50; // Minimum distance in pixels to trigger a swipe
            
            document.addEventListener('touchstart', (e) => {
                // Don't handle swipes if user is interacting with input fields or modals
                if (e.target.tagName === 'INPUT' || 
                    e.target.tagName === 'SELECT' || 
                    e.target.isContentEditable ||
                    (fxSearchModal && fxSearchModal.contains(e.target))) {
                    return;
                }
                
                // Get the first touch point
                const touch = e.touches[0];
                touchStartX = touch.clientX;
                touchStartY = touch.clientY;
            }, { passive: true });
            
            document.addEventListener('touchend', (e) => {
                // Don't handle swipes if we didn't track a start position
                if (touchStartX === null || touchStartY === null) {
                    return;
                }
                
                // Don't handle swipes if user is interacting with input fields or modals
                if (e.target.tagName === 'INPUT' || 
                    e.target.tagName === 'SELECT' || 
                    e.target.isContentEditable ||
                    (fxSearchModal && fxSearchModal.contains(e.target))) {
                    touchStartX = null;
                    touchStartY = null;
                    return;
                }
                
                // Get the end touch point
                const touch = e.changedTouches[0];
                const touchEndX = touch.clientX;
                const touchEndY = touch.clientY;
                
                // Calculate swipe distance and direction
                const deltaX = touchEndX - touchStartX;
                const deltaY = touchEndY - touchStartY;
                const absDeltaX = Math.abs(deltaX);
                const absDeltaY = Math.abs(deltaY);
                
                // Determine if this is a valid swipe (must exceed minimum distance)
                // and be primarily in one direction
                if (absDeltaX > minSwipeDistance || absDeltaY > minSwipeDistance) {
                    // Determine primary swipe direction
                    if (absDeltaX > absDeltaY) {
                        // Horizontal swipe
                        if (deltaX > 0) {
                            // Swipe right - next filter
                            e.preventDefault();
                            cycleNextFilter();
                        } else {
                            // Swipe left - previous filter
                            e.preventDefault();
                            cyclePrevFilter();
                        }
                    } else {
                        // Vertical swipe
                        if (deltaY > 0) {
                            // Swipe down - next filter
                            e.preventDefault();
                            cycleNextFilter();
                        } else {
                            // Swipe up - previous filter
                            e.preventDefault();
                            cyclePrevFilter();
                        }
                    }
                }
                
                // Reset touch start positions
                touchStartX = null;
                touchStartY = null;
            }, { passive: false });
            
            // Handle visibility change - reload camera on mobile after permission dialog closes
            let wasHidden = false;
            const reloadCameraIfNeeded = () => {
                if (localStream && videoInput) {
                    // Check if video is not playing or has no video dimensions
                    if (videoInput.paused || videoInput.videoWidth === 0 || videoInput.videoHeight === 0) {
                        console.log('Reloading camera after page visibility change');
                        // Reload the camera stream
                        const deviceId = cameraSelect.value;
                        const constraints = {
                            video: {
                                deviceId: deviceId ? { exact: deviceId } : undefined,
                                width: { ideal: 1280 },
                                height: { ideal: 720 }
                            }
                        };
                        
                        // Use facingMode on mobile if no specific device is selected
                        if (isMobileDevice() && !deviceId) {
                            constraints.video.facingMode = currentFacingMode;
                        }
                        
                        // Stop old stream
                        if (localStream) {
                            localStream.getTracks().forEach(track => track.stop());
                        }
                        
                        // Get new stream and restart
                        navigator.mediaDevices.getUserMedia(constraints)
                            .then(stream => {
                                localStream = stream;
                                videoInput.srcObject = stream;
                                return videoInput.play();
                            })
                            .then(() => {
                                console.log('Camera reloaded successfully after visibility change');
                                // Force a refresh of the video processing
                                if (!animationFrameId && videoInput.readyState >= 2) {
                                    processVideoFrame();
                                }
                            })
                            .catch(error => {
                                console.error('Error reloading camera after visibility change:', error);
                            });
                    }
                }
            };
            
            document.addEventListener('visibilitychange', () => {
                if (document.visibilityState === 'visible') {
                    // Page became visible again - check if we need to reload camera
                    if (wasHidden) {
                        // Small delay to ensure page is fully visible
                        setTimeout(reloadCameraIfNeeded, 100);
                    }
                    wasHidden = false;
                } else if (document.visibilityState === 'hidden') {
                    wasHidden = true;
                }
            });
            
            // Also handle pageshow event for mobile Safari (backup)
            window.addEventListener('pageshow', (e) => {
                // Check if this is a back/forward navigation or page restoration
                if (e.persisted || (document.visibilityState === 'visible' && localStream)) {
                    setTimeout(reloadCameraIfNeeded, 100);
                }
            });
        }
        
        // Initialize everything
        async function init() {
            try {
                updateStatus('Loading...', 'loading');
                
                // Initialize WASM
                await initWasm();
                
                updateStatus('Loading face detection...', 'loading');
                
                // Initialize MediaPipe
                const faceDetected = await initFaceDetection();
                
                if (!faceDetected) {
                    updateStatus('Face detection failed - filters may not work', 'error');
                }
                
                // Setup UI
                await loadScenes(); // Load scenes first (sets default to dropout)
                await loadCameras();
                loadPinnedFilters();
                
                // Discover face masks first (this updates FILTER_CATEGORIES)
                await discoverFaceMasks();
                
                // Now load filters (which will include discovered face masks)
                loadFilters();
                setupEventListeners();
                
                // Update version and build display
                updateVersionDisplay();
                startTimeUpdateInterval();
                
                // Load face mask scale from localStorage
                try {
                    const savedScale = localStorage.getItem('wesworld-fx-face-mask-scale');
                    if (savedScale) {
                        faceMaskScale = parseFloat(savedScale);
                        // Clamp to valid range
                        faceMaskScale = Math.max(0.5, Math.min(2.0, faceMaskScale));
                        console.log('Loaded face mask scale from localStorage:', faceMaskScale);
                    }
                    updateFaceMaskZoomDisplay();
                } catch (error) {
                    console.error('Error loading face mask scale from localStorage:', error);
                }
                
                // Load FX from URL if present, otherwise load from localStorage (after filters are loaded)
                setTimeout(() => {
                    const urlParams = new URLSearchParams(window.location.search);
                    const fxParam = urlParams.get('fx');
                    
                    if (fxParam && allFilters.includes(fxParam)) {
                        // URL parameter takes priority
                        selectFilter(fxParam, false);
                    } else {
                        // Try to load from localStorage (works with file:// protocol)
                        try {
                            const savedFilter = localStorage.getItem('wesworld-fx-last');
                            if (savedFilter && allFilters.includes(savedFilter)) {
                                selectFilter(savedFilter, false);
                            }
                        } catch (error) {
                            console.error('Error loading last filter from localStorage:', error);
                        }
                    }
                }, 100);
                
                // Preload face masks
                await preloadFaceMasks();
                
                // Debug: Check if modal elements exist
                console.log('Modal elements check:', {
                    fxSearchTrigger: !!fxSearchTrigger,
                    fxSearchModal: !!fxSearchModal,
                    fxSearchInput: !!fxSearchInput,
                    fxSearchClear: !!fxSearchClear
                });
                
                // Test modal opening
                if (fxSearchModal) {
                    console.log('Modal element found, testing visibility');
                    // Temporarily show modal to test
                    setTimeout(() => {
                        console.log('Modal classes:', fxSearchModal.className);
                        console.log('Modal computed style:', window.getComputedStyle(fxSearchModal).display);
                    }, 1000);
                }
                
                loadingIndicator.classList.add('hidden');
                
                // Check and show tutorial on first load
                checkAndShowTutorial();
                
                // Auto-start camera automatically
                const savedCameraId = localStorage.getItem('wesworld-fx-camera');
                
                // Make sure camera select has the saved camera selected, or use first available
                if (savedCameraId && cameraSelect.value !== savedCameraId) {
                    const cameraExists = Array.from(cameraSelect.options).some(opt => opt.value === savedCameraId);
                    if (cameraExists) {
                        cameraSelect.value = savedCameraId;
                    }
                }
                
                // If no camera is selected, select the first available camera
                if (!cameraSelect.value && cameraSelect.options.length > 0) {
                    cameraSelect.value = cameraSelect.options[0].value;
                }
                
                // Check if user has previously started camera (remembered preference)
                const shouldAutoStart = localStorage.getItem('wesworld-fx-camera-auto-start') === 'true';
                
                // Start camera automatically if user has previously started it and we have a selection
                if (shouldAutoStart && cameraSelect.value) {
                    updateStatus('Starting camera...', 'loading');
                    // Wait a bit for UI to be ready, then start camera
                    setTimeout(() => {
                        startCamera().catch(error => {
                            console.warn('Auto-start camera failed:', error);
                            updateStatus('Camera auto-start failed - Click "Start Camera" to begin', 'error');
                            // If auto-start fails, clear the active flag but keep auto-start preference
                            localStorage.setItem('wesworld-fx-camera-active', 'false');
                            // Expand settings and show start button if camera failed to start
                            const settingsSection = document.querySelector('.settings-section');
                            const settingsToggle = document.getElementById('settingsToggle');
                            if (settingsSection && settingsToggle) {
                                settingsSection.classList.add('expanded');
                                settingsToggle.classList.add('expanded');
                            }
                            startButton.style.display = 'block';
                            stopButton.style.display = 'none';
                        });
                    }, 300);
                } else {
                    updateStatus('No camera available - Check camera permissions', 'error');
                    // Expand settings and show start button if no camera available
                    const settingsSection = document.querySelector('.settings-section');
                    const settingsToggle = document.getElementById('settingsToggle');
                    if (settingsSection && settingsToggle) {
                        settingsSection.classList.add('expanded');
                        settingsToggle.classList.add('expanded');
                    }
                    startButton.style.display = 'block';
                    stopButton.style.display = 'none';
                }
                
                // Auto-hide UI after 3 seconds
                setTimeout(() => {
                    if (controlsVisible) {
                        toggleUI();
                    }
                }, 3000);
                
            } catch (error) {
                console.error('Initialization error:', error);
                loadingIndicator.classList.add('hidden');
                updateStatus('Initialization failed: ' + error.message, 'error');
            }
        }
        
        // Load scene immediately when DOM is ready (before showing controls)
        function loadSceneEarly() {
            if (sceneSelect) {
                // Populate scene dropdown
                sceneSelect.innerHTML = '';
                let sceneKeys = Object.keys(SCENES);
                if (sceneKeys.length === 0) {
                    // If no scenes loaded, add fallback
                    SCENES.dropout = FALLBACK_DROPOUT_SCENE;
                    sceneKeys = ['dropout'];
                }
                sceneKeys.forEach(sceneKey => {
                    const option = document.createElement('option');
                    option.value = sceneKey;
                    option.textContent = SCENES[sceneKey].name;
                    sceneSelect.appendChild(option);
                });
                
                // Load saved scene from localStorage, or default to dropout
                const savedScene = localStorage.getItem('wesworld-fx-scene');
                const availableSceneKeys = Object.keys(SCENES);
                
                let sceneToLoad = 'dropout';
                if (savedScene && SCENES[savedScene] && availableSceneKeys.includes(savedScene)) {
                    sceneToLoad = savedScene;
                } else if (SCENES.dropout) {
                    sceneToLoad = 'dropout';
                } else if (availableSceneKeys.length > 0) {
                    sceneToLoad = availableSceneKeys[0];
                }
                
                if (SCENES[sceneToLoad]) {
                    sceneSelect.value = sceneToLoad;
                    applyScene(SCENES[sceneToLoad]);
                } else {
                    // If no scenes loaded (e.g., CORS error), use fallback
                    console.warn('No scenes loaded in loadSceneEarly, using fallback dropout scene');
                    SCENES.dropout = FALLBACK_DROPOUT_SCENE;
                    sceneSelect.value = 'dropout';
                    applyScene(FALLBACK_DROPOUT_SCENE);
                }
                
                // Show controls after scene is loaded
                if (controls) {
                    controls.classList.remove('hidden');
                    controls.classList.add('visible');
                }
            }
        }
        
        // Clean up old URL parameters on page load
        cleanOldURLParams();
        
        // Load scene as soon as DOM elements are available
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', async () => {
                await loadBuildInfo();
                loadSceneEarly();
                updateVersionDisplay();
                startTimeUpdateInterval();
                init();
            });
        } else {
            (async () => {
                await loadBuildInfo();
                loadSceneEarly();
                updateVersionDisplay();
                startTimeUpdateInterval();
                init();
            })();
        }
    </script>
</body>
</html>


